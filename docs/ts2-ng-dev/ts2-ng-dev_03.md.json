["```ts\nlet text: string = \"Hi, I am a string. Now you know!\";\n```", "```ts\nconst outro: string = 'Now you know!';\n\nlet text: string = `Hi, I am not just a simple string.\n I am actually a paragraph. ${outro}`;\n```", "```ts\nlet whole: number = 6;\nlet decimal: number = 2.5; let hex: number = 0xf00d; let binary: number = 0b1010; let octal: number = 0o744;\n```", "```ts\nlet isHappy: boolean = true;\nlet done: boolean = false;\n```", "```ts\nlet textArray: string[];\n\ntextArray = [\"java\", \"kotlin\", \"typescript\", \"the rest...\"]\n```", "```ts\nlet numberArray: Array<number> = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n```", "```ts\nlet sum: number = 20\n\n// No return type function\nfunction addToGlobalSum(numToAdd): void { \n number + numToAdd }\n\naddToGlobalSum(30) \nconsole.log(number) // 50\n```", "```ts\n// Stores a string\nlet name: any = 'John Doe' \n\n// Stores a number\nlet age: any = 24\n\n// Stores a boolean\nlet employed: any = true\n\n// ...even data structures\nlet person: any[] =['John Doe', 24, true] \n```", "```ts\nlet flexibleArray: [string, number, boolean];\n\nflexibleArray = ['John Doe', 24, true] \n```", "```ts\nlet anotherFlexArray: [string, number];\n\nanotherFlexArray = ['John Doe', 24];\n\nAssign true to index 2\nanotherFlexArray[2] = true;\n\n// anotherFlexArray becomes ['John Doe', 24, true]\n```", "```ts\nenum Status {Started, InProgress, Completed}\n\nlet status:Status = Status.InProgress // 1\n```", "```ts\nenum Status {Started = 1, InProgress, Completed}\n\nlet status:Status = Status.InProgress // 2\n```", "```ts\nenum Status {Started = 33, InProgress = 66, Completed = 100}\n\nlet status:Status = Status.InProgress + '% done' // 66% done\n```", "```ts\nenum Status {Started = 33, InProgress = 66, Completed = 100}\n\nlet status:string = Status[66] // InProgress\n\n```", "```ts\nfunction stringToArray(char) {\n return char.split(' ')\n}\n```", "```ts\n// Typed parameters\nfunction stringIndex(char: string, index: number) {\n const arr = char.split(' ')\n return arr[number];\n}\n```", "```ts\nfunction stringIndex(char: string, index: number) {\n const arr = char.split(' ')\n return arr[number];\n}\n\nstringIndex(true, 'silly') // Types don't match\n```", "```ts\nconst stringIndex = function (char: string, index: number) {\n const arr = char.split(' ')\n return arr[number];\n}\n```", "```ts\nconst stringIndex = (char: string, index: number) => char.split(' ')[number];\n```", "```ts\nfunction stringIndex(char: string, index: number): string {\n const arr = char.split(' ')\n return arr[number];\n}\n```", "```ts\nfunction stringIndex(char: string, index?: number): string {\n // Just return string as is\n // if index is not passed in\n if(!index) return char;\n // else, return the index \n // that was passed in\n const arr = char.split(' ')\n return arr[number];\n}\n```", "```ts\n// Option bag\nlet options = {show: true, container: '#main'};\n```", "```ts\n// Typed object\nlet options: {show: boolean, container: string};\n\n// Assing values\noptions = {show: true, container: '#main'};\n```", "```ts\ninterface OptionBag {\n show: boolean,\n container: string\n}\n```", "```ts\n// Typed object\nlet options: OptionBag = {show: true, container: '#main'};\n```", "```ts\ninterface OptionBag {\n show: boolean,\n container: string\n}\n\nlet options: OptionBag = {show: true}; // Error\n```", "```ts\ninterface OptionBag {\n show: boolean,\n container?: string\n}\n\nlet options: OptionBag = {show: true}; // No Error\n```", "```ts\n// Get element\nfunction getContainerElement(options: OptionBag):HTMLElement {\n let containerElement: HTMLElement\n if(!options.container) {\n // container was not passed in\n containerElement = document.querySelector('body');\n } else {\n // container was passed in\n containerElement = document.querySelector(options.container);\n }\n\n return containerElement\n}\n```", "```ts\ninterface StaticSettings {\n readonly width: number,\n readonly height: number\n}\n\n// There are no problems here\nlet settings: StaticSettings = {width: 1500, height: 750}\n\n// ...but this will throw an error\nsettings.width = 1000\n// or\nsettings.height = 500\n```", "```ts\ninterface Note {\n wordCount: number\n}\n```", "```ts\nclass NoteTaker implements Note {\n // Implement wordCount from\n // Note interface\n wordCount: number;\n constructor(count: number) {\n this.wordCount = count\n }\n}\n```", "```ts\ninterface Note {\n wordCount: number;\n updateCount(count: number): void\n}\n```", "```ts\nclass NoteTaker implements Note {\n // Implement wordCount from\n // Note interface\n wordCount: number;\n constructor(count: number) {\n this.wordCount = count\n }\n\n updateCount(count: number): void {\n wordCount += count\n }\n}\n```", "```ts\nclass Report {\n errPayload;\n\n // To become readonly\n error() {\n console.log(`The following error occured ${errPayload}`)\n }\n}\n```", "```ts\nfunction readonly(target, key, descriptor) {\n descriptor.writable = false;\n return descriptor\n}\n```", "```ts\nclass Report {\n errPayload;\n\n // Decorated method \n @readonly\n error() {\n console.log(`The following error occured ${errPayload}`)\n }\n}\n```", "```ts\nconst report = new Report()\n\n// This would never work\n// because 'error' is read only\nreport.error = function() {\n console.log('I won't even be called')\n}\n```", "```ts\n// decorator function\nfunction config(target) {\n target.options = {\n id: '#main',\n show: true\n }\n}\n\n// class\n@config\nclass App {}\n\n// options added\nconsole.log(App.options) // {id: '#main', show: true}\n```", "```ts\n// decorator factory function\nfunction config(options) {\n // decorator function\n return function(target) {\n target.options = options\n }\n}\n\n// class decorator\n// with arguments\n@config({id: '#main', show: true})\nclass App {}\n\n// options added\nconsole.log(App.options) // {id: '#main', show: true}\n```"]