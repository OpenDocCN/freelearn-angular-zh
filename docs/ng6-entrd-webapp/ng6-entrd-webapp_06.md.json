["```ts\nsrc/app/app.module.ts\n...\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms'\n...\n@NgModule({\n  ...\n  imports: [\n    ...\n    FormsModule,\n    ReactiveFormsModule,\n    ...\n```", "```ts\nsrc/app/material.module.ts\nimport {\n  ...\n  MatFormFieldModule,\n  MatInputModule,\n} from '@angular/material'\n...\n@NgModule({\n  imports: [\n    ...\n    MatFormFieldModule,\n    MatInputModule,\n  ],\n  exports: [\n    ...\n    MatFormFieldModule,\n    MatInputModule,\n  ],\n})\n```", "```ts\n$ npx ng g c citySearch --module=app.module\n```", "```ts\nsrc/app/city-search/city-search.component.html\n<form>\n  <mat-form-field>\n    <mat-icon matPrefix>search</mat-icon>\n    <input matInput placeholder=\"Enter city or zip\" aria-label=\"City or Zip\" [formControl]=\"search\">\n  </mat-form-field>\n</form>\n```", "```ts\nsrc/app/city-search/city-search.component.ts\nimport { FormControl } from '@angular/forms'\n...\nexport class CitySearchComponent implements OnInit {\n  search = new FormControl()\n  ...\n```", "```ts\nsrc/app/app.component.ts\n...\n  </div>    \n  <div fxLayoutAlign=\"center\">\n    <app-city-search></app-city-search>\n  </div>\n  <div fxLayout=\"row\">\n...\n```", "```ts\napp/src/weather/weather.service.ts  \n  getCurrentWeather(\n    search: string | number,\n    country?: string\n  ): Observable<ICurrentWeather> {\n    let uriParams = ''\n    if (typeof search === 'string') {\n      uriParams = `q=${search}`\n    } else {\n      uriParams = `zip=${search}`\n    }\n\n    if (country) {\n      uriParams = `${uriParams},${country}`\n    }\n\n    return this.getCurrentWeatherHelper(uriParams)\n  }\n```", "```ts instead of a single-quote character `'`, which leverages the template literals functionality that allows embedded expressions in JavaScript:\n\n```", "```ts\n\nAs a positive side effect,\u00a0`getCurrentWeatherHelper`\u00a0adheres to the Open/Closed principle, because it is open to extension by our ability to change the function's behavior by supplying different\u00a0`uriParams`\u00a0and is closed to modification, because it won't have to be changed frequently.\n\nTo demonstrate the latter point, let's implement a new function to get the current weather by latitude and longitude.\n\n3.  Implement\u00a0`getCurrentWeatherByCoords`:\n\n```", "```ts\n\nAs you can see, `getCurrentWeatherHelper` can easily be extended without any modification.\n\n4.  Ensure that you update\u00a0`IWeatherService` with the changes made earlier.\n\nAs a result of adhering to SOLID design principles, we make it easier\u00a0to robustly unit test flow-control logic and ultimately end up writing code that is more resilient to bugs and is cheaper to maintain.\n\n# Implementing search\n\nNow, let's connect the new service method to the input field:\n\n1.  Update\u00a0`citySearch`\u00a0to inject the\u00a0`weatherService`\u00a0and subscribe to input changes:\n\n```", "```ts\n\nWe are treating all input as `string` at this point. The user input can be a city, zip code or a city and country code, or zip code and country code separated by a comma. While city or zip code is required, country code is optional. We can use the `String.split` function to parse any potential comma separated input and then trim any whitespace out from the beginning and the end of the string with `String.trim`. We then ensure that we trim all parts of the string by iterating over them with `Array.map`.\n\nWe then deal with the optional parameter with ternary operator `?:`, only passing in a value if it exists, otherwise leaving it undefined.\n\n2.  Implement the search handler:\n\n```", "```ts\n\n3.  Add a hint for the user about the optional country functionality:\n\n```", "```ts\n\nAt this point, the subscribe handler will make calls to the server and log its output to the console.\n\nObserve how this works with Chrome Dev Tools. Note how often the `search` function is run and also that we are not handling service errors.\n\n# Limiting user inputs with throttle/debounce\n\nAs is, we submit a request to the server with every keystroke. This is not a desirable behavior, because it can lead to a bad user experience, drain battery life, result in wasted network requests, and create performance issues both on the client and server side.\u00a0Users make typos; they can change their mind about what they are inputting and rarely ever, the first few characters of information input result in useful results.\n\nWe can still listen to every keystroke,\u00a0but we don't have to react to every keystroke. By leveraging throttle/debounce, we can limit the number of events generated to a predetermined interval and still\u00a0maintain the type-as-you-search functionality.\n\nNote that\u00a0`throttle` and `debounce` are not functional equivalents, and their behavior will differ from framework to framework. In addition to throttling, we expect to capture the last input that the user has typed. In the `lodash` framework, the throttle function fulfills this requirement, whereas in `RxJS`, debounce fulfills it. Beware that this discrepancy may be fixed in future framework updates.\n\nIt is very easy to inject throttling into the observable stream using `RxJS/debounceTime`.\n\nImplement `debounceTime`\u00a0with `pipe`:\n\n```", "```ts\n\n`debounceTime` will, at a maximum, run a search every second, but also run a last search after the user has stopped typing. In comparison,\u00a0`RxJS/throttleTime` will only run a search every second, on the second, and will not necessarily capture the last few characters the user may have input.\n\nRxJS also has the\u00a0`throttle` and `debounce` functions, which you can use to implement custom logic to limit input that is not necessarily time-based.\n\nSince this is a time- and event-driven functionality, break point debugging is not feasible. You may monitor the network calls within the\u00a0Chrome Dev Tools | Network tab, but to get a more real-time feeling of how often your search handler is actually being invoked, add a `console.log` statement.\n\nIt is not a good practice to check in code with active `console.log` statements. As covered in\u00a0[Chapter 3](4e68114e-68b7-4fe6-a853-81347e981667.xhtml), *Prepare Angular App for Production Release*, `console.log` is a poor-man's debugging method. The statements make it difficult to read the actual code, which itself bears a high cost of maintainability. So, whether they are commented out or not, do not check in code with `console.log` statements.\n\n# Implementing input validation and error messaging\n\n`FormControl` is highly customizable. It allows you to set a default initial value, add validators, or listen to changes on blur, change, and submit events, as follows:\n\n```", "```ts\n\nWe won't be initializing the `FormControl` with a value, but we need to implement a validator to disallow one character inputs:\n\n1.  Import `Validators` from `@angular/forms`:\n\n```", "```ts\n\n2.  Modify `FormControl` to add a minimum length validator:\n\n```", "```ts\n\n3.  Modify the template to show a validation error message:\n\n```", "```ts\n\nNote the addition of some extra margin to make room for lengthy error messages.\n\nIf you are handling different kinds of errors, the `hasError` syntax in the template can get repetitive. You may want to implement a more scalable solution that can be customized through code, as shown:\n\n```", "```ts\n\n4.  Modify the `search` function to not execute a search with invalid input:\n\n```", "```ts\n\nInstead of doing a simple check to see whether\u00a0`searchValue`\u00a0is defined and not an empty string, we can tap in to the validation engine for a more robust check by calling `this.search.invalid`.\n\n# Template driven forms with two-way binding\n\nThe alternative to Reactive forms are Template driven forms. If you're familiar with `ng-model` from AngularJS, you'll find that the new `ngModel` directive is an API compatible replacement for it.\n\nBehind the scenes,\u00a0`ngModel` implements a `FormControl` that can automatically attach itself to a `FormGroup`. `ngModel` can be used at the `<form>` level or individual `<input>` level. You can read more about `ngModel` at\u00a0[https://angular.io/api/forms/NgModel](https://angular.io/api/forms/NgModel).\n\nIn the Local Weather app, I have included a commented-out component in `app.component.ts` named `app-city-search-tpldriven`. You can uncomment this component in `app.component` to experiment with it. Let's see how the alternate template implementation looks like:\n\n```", "```ts\n\nNote the `[()]`\u00a0\"box of bananas\" two-way binding syntax being used with `ngModel`.\n\nThe differences in the component are implemented as follows:\n\n```", "```ts\n\nAs you can see, most of the logic is implemented in the template, and the programmer is required to maintain an active mental model of what's in the template and the controller and switch back and forth between the two files to make changes to event handlers and validation logic.\n\nFurthermore, we have lost the input limiting and the ability to prevent service calls when the input is in an invalid state. It is, of course, possible to still implement these features, but they require convoluted solutions and do not neatly fit into the new Angular syntax and concepts.\n\n# Enabling component interaction\n\nIn order to update current weather information, we need the `city-search` component to interact with the `current-weather` component.\u00a0There are four main techniques to enable component interaction in Angular:\n\n*   Global events\n*   Parent components listening for information bubbling up from\u00a0children\u00a0 components\n*   Sibling, parent, or children components within a module that work off of similar data streams\n*   Parent components passing information to children components\n\n# Global events\n\nThis a technique that's been leveraged since the early days of programming in general. In JavaScript, you may have achieved this with global function delegates or jQuery's event system. In AngularJS, you may have created a service and stored values in it.\n\nIn Angular, you can still create a root level service, store values in it, use Angular's `EventEmitter` class, which is really meant for directives, or use an\u00a0`rxjs/Subscription`\u00a0to create a fancy messaging bus for yourself.\n\nAs a pattern, global events are open to rampant abuse and rather than helping maintain a decoupled application architecture, it leads to global state over time. Global state or even localized state at the controller level, where functions read and write to variables in any given class, is enemy number one of writing maintainable and unit testable software.\n\nUltimately, if you're storing all your application data\u00a0or routing all events\u00a0in one service to enable component interaction, you're merely inventing a better mouse trap. This is an anti-pattern that should be avoided at all costs. In a later section, you will find that essentially we will still be using services to enable component interaction; however, I want to point out that there's a fine line that exists between a flexible architecture that enables decoupling and the global or centralized decoupling approach that does not scale well.\n\n# Child-parent relationships with event emitters\n\nYour child component should be completely unaware of its parent. This is key to creating reusable components.\n\nWe can implement the communication between the city search component and the current weather component leveraging app component as a parent element and let the `app` module controller orchestrate the data.\n\nLet's see how this implementation will look:\n\n1.  The `city-search` component exposes an `EventEmitter` through an `@Output` property:\n\n```", "```ts\n\n2.  The `app` component consumes that and calls the `weatherService`, setting the `currentWeather` variable:\n\n```", "```ts\n\nWe have been able to successfully bubble up the information, but now we must be able to pass it down to the `current-weather` component.\n\n# Parent-child relationships with input binding\n\nBy definition, your parent component will be aware of what child components it is working with.\u00a0Since the\u00a0`currentWeather`\u00a0property is bound to the `current` property on the\u00a0`current-weather` component, the results pass down to be displayed. This is achieved by creating an `@Input` property:\n\n```", "```ts\n\nYou can then update `app` component to bind the data to `current` weather:\n\n```", "```ts\n\nThis approach may be appropriate in cases where you are creating well-coupled components or user controls and no outside data is being consumed. A good example might be adding forecast information to the `current-weather` component, as shown:\n\n![](Images/2860d596-cf91-4e23-b9c9-7a4a38620b59.png)Weather Forecast Wireframe\n\nEach day of the week can be implemented as a component that is repeated using `*ngFor`, and it will be perfectly reasonable for `current-weather` to retrieve and bind this information to its children component:\n\n```", "```ts\n\nIn general, if you're working with data-driven components, the parent-child or child-parent communication pattern results in an inflexible architecture, making it very difficult to reuse or rearrange your components. Given the ever-changing business requirements and design, this is an important lesson to keep in mind.\n\n# Sibling interactions with subjects\n\nThe main reason for components to interact is to send or receive updates to data either provided by the user or received from the server. In Angular, your services expose `RxJS.Observable` endpoints, which are data-streams that your components can subscribe to. `RxJS.Observer` compliments\u00a0`RxJS.Observable` as a consumer of events emitted by `Observable`. `RxJS.Subject` brings the two sets of functionalities together, in an easy to work with object. You can essentially\u00a0describe a stream that belongs to a particular set of data, such as the current weather data that is being displayed, with subjects:\n\n```", "```ts\n\n`currentWeather` is still a data stream and does not simply represent one data point. You can subscribe to changes to `currentWeather` data with subscribe, or you can publish changes to it as follows:\n\n```", "```ts\n\nThe default behavior of `Subject` is very much like generic pub/sub mechanisms, such as jQuery events. However, in an asynchronous world where components are loaded or unloaded in ways that are unpredictable, using the default `Subject` is not very useful.\n\nThere are three different types of Subjects:\n\n*   `ReplaySubject`: It will remember and cache all data points occurred within the data stream so that a subscriber can replay all events at any given time\n*   `BehaviorSubject`: It remembers only the last data point, while continuing to listen for new data points\n*   `AsyncSubject`:\u00a0This is for one-time only events that are not expected to reoccur\n\n`ReplaySubject`\u00a0can have severe memory and performance implications on your application, so it should be used with care. In the case of `current-weather`, we are only interested in displaying the latest weather data received, but through user input or other events we are open to receiving new data, so we can keep the `current-weather` component up to date. The\u00a0`BehaviorSubject` would be the appropriate mechanism to meet these needs:\n\n1.  Define `BehaviorSubject` in `weatherService` and set a default value:\n\n```", "```ts\n\n2.  Update the\u00a0`current-weather` component to subscribe to the new `BehaviorSubject`:\n\n```", "```ts\n\n3.  Update the\u00a0`city-search` component to publish the data it receives to `BehaviorSubject`:\n\n```"]