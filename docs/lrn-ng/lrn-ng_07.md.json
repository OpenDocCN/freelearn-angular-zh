["```ts\nfunction  notifyCompletion() {\n console.log('Our asynchronous operation has been completed'); }\n\nfunction  asynchronousOperation(callback) {\n setTimeout(() => { callback(); }, 5000); }\n\nasynchronousOperation(notifyCompletion);\n```", "```ts\nfunction getData() {\n return new Promise((resolve, reject) => {\n setTimeout(() => { \n resolve(42); \n }, 3000);\n })\n}\n\ngetData().then((data) => console.log('Data',data)) // 42\n```", "```ts\ngetData(function(data){\n getMoreData(data, function(moreData){\n getEvenMoreData(moreData, function(evenMoreData) {\n // done here\n });\n });\n});\n```", "```ts\ngetData()\n .then(getMoreData)\n .then(getEvenMoreData);\n\nfunction getData() { \n return new Promise(resolve) => resolve('data'); \n}\n\nfunction getMoreData(data) {\n return new Promise((resolve, reject) => resolve('more data'));\n}\n\nfunction getEvenMoreData(data) {\n return new Promise((resolve, reject) => resolve('even more data'));\n}\n```", "```ts\nfunction notifyCompletion() {\n console.log('Our asynchronous operation has been completed');\n}\n\nfunction asynchronousOperation() {\n let promise = new Promise((resolve, reject) => {\n setInterval(resolve, 2000); });\n\n return promise;\n}\n\nasynchronousOperation().then(notifyCompletion);\n```", "```ts\nlet observable$ = Rx.Observable.create(observer => {\n setInterval(() => {\n observer.next('My async operation');\n }, 2000);\n});\n\nobservable$.subscribe(response => console.log(response));\n```", "```ts\nlet key = document.getElementId('.search'); \n/* \nwe assume there exist a button in the DOM like this \n<input class=\"search\" placeholder=\"searchfor\"></input>\n*/\n\nlet stream = Rx.Observable.fromEvent(key, 'keyUp');\nstream.subscribe((data) => console.log('key up happened', data))\n```", "```ts\nlet mappedAndFiltered = list\n .map(item => item + 1)\n .filter(item > 2);\n```", "```ts\nlet stream = Rx.Observable\n .create(observer => {\n observer.next(1);\n observer.next(2);\n })\n .map(item => item + 1)\n .filter(item > 2);\n```", "```ts\nlet keyboardStream$ = Rx.Observable\n .fromEvent(document, 'keyup')\n .map(x => x.which);\n```", "```ts\nlet cursorMovesStream$ = keyboardStream\n .filter(x => {\n return  x > 36 && x < 41;\n })\n .map(x => {\n let direction;\n switch(x) {\n case 37:\n direction = 'left';\n break;\n case 38:\n direction = 'up';\n break;\n case 39:\n direction = 'right';\n break;\n default:\n direction = 'down';\n }\n return direction;\n });\n```", "```ts\ncursorMovesStream$.subscribe(e => console.log(e));\n```", "```ts\nconst request = new XMLHttpRequest();\n\nrequest.onreadystatechange = () => {\n if(this.readyState === 4 and this.state === 200) {\n // request.responseText\n } else {\n // error occurred here\n }\n}\n\nrequest.open(\"GET\", url);\nrequest.send();\n```", "```ts\nlet stream$ = Rx.Observable.create(observer => {\n let request = new XMLHttpRequest();\n request.onreadystatechange = () => {\n if(this.readyState === 4 && this.state === 200) {\n observer.next( request.responseText )\n observer.complete();\n } else {\n observer.error( request.responseText ) \n }\n }\n})\n```", "```ts\nlet  request  =  new  HttpRequest('GET', 'jedis.json');\nlet myRequestStream:Observable<any> = http.request(request);\n```", "```ts\nlet myRequestStream: Observable<any> = http.get('jedis.json');\n```", "```ts\nlet myRequestStream = http\n .get<Jedi[]>('jedis.json')\n  .subscribe(data => console.log(data));\n```", "```ts\n.get<Jedi[]>('jedis.json')\n```", "```ts\nconst authToken = window.localStorage.getItem('auth_token');\n\nlet headers = new HttpHeaders();\nheaders.append('Authorization', `Token ${authToken}`);\nlet request = new HttpRequest('products.json', { headers: headers });\n\nlet authRequest = http.request(request);\n```", "```ts\nhttp.get('/api/bio')\n.subscribe(bio => this.bio = bio)\n.catch(error: Response => Observable.of(error));\n```", "```ts\n// app/biography/biography.module.ts\nimport { HttpClientModule } from '@angular/common/http';\n\n@NgModule({\n  imports: [ HttpClientModule ]\n})\nexport class BiographyModule {}\n\n// app/biography/biography.component.ts\n\nimport { Component } from '@angular/core';\nimport { HttpClient } from '@angular/http';\n\n@Component({\n selector: 'bio',\n template: '<div>{{bio}}</div>'\n})\nexport class BiographyComponent {\n bio: string;\n\n constructor(private http: HttpClient) {\n const  options  = {}; this.http.get('/api/bio', { ...options, responseType:  'text' }) .catch(err  =>  Observable.of(err)) .subscribe(x  => this.bio= bio)\n }\n}\n```", "```ts\nimport {Http} from '@angular/http';\nimport {Injectable} from '@angular/core';\n\n@Injectable()\nexport class DataService {\n constructor(private http:HttpClient) {}\n\n get(url, options?) {}\n post(url, payload, options?) {}\n put(url, payload, options?) {}\n delete(url) {}\n}\n```", "```ts\nimport {DataService} from './data.service';\nimport {HttpModule} from '@angular/http';\n\n@NgModule({\n  imports: [HttpClientModule],\n providers: [DataService] \n})\n```", "```ts\n@NgModule({\n  imports: [DataModule],\n declarations: [FeatureComponent]\n})\nexport class FeatureModule {}\n```", "```ts\nimport { Component } from '@angular/core';\n\n@Component({})\nexport class FeatureComponent {\n constructor(private service: DataService) { }\n}\n```", "```ts\n[{\n \"name\": \"Code an HTML Table\",\n \"deadline\": \"Jun 23 2015\",\n \"pomodorosRequired\": 1\n\n}, {\n \"name\": \"Sketch a wireframe for the new homepage\",\n \"deadline\": \"Jun 24 2016\",\n \"pomodorosRequired\": 2\n\n}, {\n \"name\": \"Style table with Bootstrap styles\",\n \"deadline\": \"Jun 25 2016\",\n \"pomodorosRequired\": 1\n\n}, {\n \"name\": \"Reinforce SEO with custom sitemap.xml\",\n \"deadline\": \"Jun 26 2016\",\n \"pomodorosRequired\": 3\n}]\n```", "```ts\nimport 'rxjs/Rx';\n```", "```ts\nimport 'rxjs/add/operator/map';\nimport { bootstrap } from '@angular/platform-browser-dynamic';\nimport AppModule from './app.module';\n\nbootstrapModule(AppModule);\n```", "```ts\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs/Observable';\n\nimport { Task } from './task.model';\n```", "```ts\nexport interface Task {\n name: string;\n deadline: string;\n pomodorosRequired: number;\n queued: boolean;\n}\n```", "```ts\nimport { HttpClient } from '@angular/common/http';\nimport { Task } from './task.model';\n\nexport default class TaskService {\n constructor(private http:HttpClient) {}\n\n getTasks(): Observable<Task[]> {\n return this.http.get<Task[]>(`tasks.json`)\n }\n}\n```", "```ts\n// app/tasks/task.module.ts\n\n@NgModule({\n imports: [ /* add dependant modules here */ ],\n declarations: [ ./* add components and directives here */ ]\n providers: [TaskService],\n})\nexport class TaskModule {}\n```", "```ts\n// app/tasks/task.component.ts\n\n@Component({\n template: `\n <div *ngFor=\"let task of tasks\">\n {{ task.name }}\n </div>\n `\n})\nexport class TasksComponent {\n tasks:Task[];\n constructor(private taskService:TaskService){\n this.taskService.getTasks().subscribe( tasks => this.tasks = tasks)\n }\n}\n```", "```ts\n// app/tasks/task.service.ts\n\n@Component({\n template: `\n <div *ngFor=\"let task of tasks$ | async\">\n {{ task.name }}\n </div>\n `\n})\nexport class TaskListComponent {\n  tasks$:Observable<Task[]>; \n constructor(private taskService: TaskService ) {}\n\n ngOnInit() {\n this.tasks$ = this.taskService.getTasks(); \n }\n} \n```", "```ts\n// app/tasks/tas.alt.component.ts\n\n@Component({\n template: `\n <div *ngFor=\"let task of tasks\">\n {{ task.name }}\n </div>\n `\n})\nexport class TaskComponent {\n constructor(private taskService: TaskService ) {}\n\n  get tasks() {\n return this.taskService.tasks;\n } \n} \n```", "```ts\nnpm install socket.io\n```", "```ts\nimport * as io from 'socket.io-client'**;** export class TaskService {\n subscription;\n tasks:Task[] = [];\n constructor(private http:HttpClient) {\n this.fetchData();\n\n    this.socket = io(this.url**);  // establishing a socket connection** this.socket.on('task', (data) => { \n // receive data from socket based on the 'task' event happening\n this.tasks = [ ..this.tasks, data ];\n });\n }\n\n private fetchData() {\n this.subscription = \n this.http.get<Task[]>('/tasks')\n .subscribe( data => this.tasks = data );\n }\n\n // call this from the component when component is being destroyed\n destroy() {\n    this.socket.removeAllListeners('task');  // clean up the socket\n connection\n } \n}\n```", "```ts\n@Component({\n template: `\n <div *ngFor=\"let task of tasks\">\n {{ task.name }}\n </div>\n <input [(ngModel)]=\"newTask\" />\n <button (click)=\"addTask()\" ></button>\n ` \n})\nexport class FirstSiblingComponent {\n newTask: string;\n\n constructor(private service: TaskService) {}\n\n  get tasks() {\n return this.taskService.tasks;\n }\n\n  addTask() {\n this.service.addTask({ name : this.newTask });\n this.newTask = '';\n }\n}\n```", "```ts\nimport * as io from 'socket.io-client'**;** export class TaskService {\n subscription;\n tasks: Task[] = [];\n constructor(private http:Http) {\n this.fetchData();\n\n this.socket = io(this.url);  // establishing a socket connection\n\n this.socket.on('task', (data) => { \n // receive data from socket based on the 'task' event happening\n this.tasks = [ ..this.tasks, data ];\n });\n }\n\n addTask(task: Task) {\n this.tasks = [ ...this.tasks, task]; \n }\n\n private fetchData() {\n this.subscription = \n this.http.get('/tasks')\n .subscribe(data => this.tasks = data);\n }\n\n // call this from the component when component is being destroyed\n destroy() {\n this.socket.removeAllListeners('task');  // clean up the socket\n connection\n } \n}\n```", "```ts\nget tasks() {\n return this.taskService.tasks;\n}\n```", "```ts\nif(networkIsDown) { \n /* respond with localStorage instead */\n} else { \n /* respond with network call */\n}\n```", "```ts\nexport class TaskService {\n getTasks() {\n this.http .get<Task[]>('/data/tasks.json')  .do( data  => {  localStorage.setItem('tasks', JSON.stringify(data)) })\n      .catch(err) => {\n return this.fetchLocalStorage();\n })\n }\n\n private fetchLocalStorage(){\n let tasks = localStorage.getItem('tasks');\n const tasks = localStorage.getItem('tasks') || [];\n    return Observable.of(tasks);\n }\n}\n```", "```ts\nexport class TaskService {\n  tasks: Task[];\n getTasks() {\n this.http .get<Task[]>('/data/tasks.json')  .do( data  => { **this.tasks = mapTasks( data );** localStorage.setItem('tasks', JSON.stringify(data)) })\n .catch(err) => {\n return this.fetchLocalStorage();\n })\n }\n}\n```", "```ts\nexport class TaskService {\n  private internalStore:BehaviourSubject;\n\n constructor() {\n    this.internalStore = new BehaviourSubject([]); // setting initial\n value \n }\n\n get store() {\n    return this.internalStore.asObservable();\n }\n\n private fetchTasks(){\n this.http .get<Task[]>('/data/tasks.json')  .map(this.mapTasks) .do(data  => { **this.internalStore.next( data )** localStorage.setItem('tasks', JSON.stringify(data)) })\n .catch( err  => {\n return this.fetchLocalStorage();\n });\n }\n}\n```", "```ts\nget store() {\n return this.internalStore.asObservable();\n}\n```", "```ts\n// here we are emitting the data as it arrives\n.do(data  => { this.internalStore.next(data)  })\n```", "```ts\n@Component({})\nexport class TaskComponent {\n constructor(taskService: TaskService ) {\n taskService.store.subscribe( data => {\n console.log('Subscriber 1', data);\n })\n\n setTimeout(() => {\n taskService.store\n .subscribe( data => console.log('Subscriber 2', data)); // will get the latest emitted value\n }, 3000)\n } \n}\n```", "```ts\nexport class TaskService {\n addTask(task) {\n return this.http.post('/tasks', task);\n }\n}\n```", "```ts\n@Component({})\nexport class TaskComponent implements OnInit {\n ngOnInit() {\n init();\n }\n\n private init(){\n this.taskService.getTasks().subscribe( data => this.tasks = data )\n }\n\n addTask(task) {\n this.taskService.addTask(task).subscribe( data => {\n this.taskService.getTasks().subscribe(data => this.tasks = data)\n });\n }\n}\n```", "```ts\n@Component({})\nexport class TaskComponent implements OnInit{\n private subscription;\n\n ngOnInit() {\n this.subscription = this.taskService.store.subscribe( data => this.tasks = data );\n }\n\n addTask(task) {\n this.taskService.addTask( task ).subscribe( data => {\n // tell the store to update itself? \n });\n }\n}\n```", "```ts\nthis.taskService.addTask(task).subscribe( data => {\n // tell the store to update itself? \n})\n```", "```ts\nexport class TaskService {\n addTask(task) {\n this.http\n .post('/tasks', task)\n .subscribe( data => { this.fetchTasks(); })\n }\n}\n```", "```ts\n@Component({\n template : `\n <div *ngFor=\"let task of tasks\">\n {{ task.name }}\n </div>\n `\n})\nexport class TaskComponent implements OnInit, implements OnDestroy{\n private subscription;\n tasks: Task[];\n\n ngOnInit() {\n this.subscription = this.taskService.store.subscribe( data => this.tasks = data );\n }\n\n   ngOnDestroy() { \n this.subscription.unsubscribe();\n }\n\n addTask(task) {\n this.taskService.addTask( task );\n }\n} \n```", "```ts\n@Component({\n template: `\n <div *ngFor=\"let task of tasks | async\">\n {{ task.name }}\n </div>\n `\n})\nexport class TaskComponent implements OnInit{\n get tasks() {\n return this.taskService.store; \n }\n\n addTask(task) {\n this.taskService.addTask( task );\n }\n} \n```", "```ts\nconstructor(){\n lastFetchedDate;\n INTERVAL_IN_SECONDS = 30;\n\n setInterval(() => {\n fetchTasksDelta( lastFetchedDate );\n lastFetchedDate = DateTime.now;\n }, this.INTERVAL_IN_SECONDS * 1000)\n}\n```", "```ts\nimport { HttpInterceptor } from '@angular/common/http'; export  class  MockInterceptor  implements  **HttpInterceptor** {  constructor() { } intercept(request:  HttpRequest<any>, next:  HttpHandler):  Observable<HttpEvent<any>> { }\n}\n```", "```ts\nimport { HttpInterceptor } from '@angular/common/http'; export  class  MockInterceptor  implements  HttpInterceptor {  constructor() { } intercept(request:  HttpRequest<any>, next:  HttpHandler):  Observable<HttpEvent<any>> { return  next.handle(request**);** }\n}\n```", "```ts\nimport { HttpInterceptor } from '@angular/common/http';\n\nexport class MockInterceptor implements HttpInterceptor {\n constructor() { }\n\n intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n if (request.url.startsWith('/starwars') &&  request.method  ===  'GET') { const  url  =  request.url; const  newUrl  =  `data${url.substring('/starwars'.length)}.json`; const  req  =  new  HttpRequest('GET', newUrl); return  next.handle(req); } else { return  next.handle(request); }\n }\n}\n```", "```ts\n@NgModule({\n imports: [BrowserModule, HttpClientModule]\n providers: [{ \n provide:  HTTP_INTERCEPTORS, \n useClass:  MockInterceptor, \n multi:  true **}**] })\n```", "```ts\n@Component({\n template: `{{ data }}`\n})\nexport class DataComponent implements OnInit, implements OnDestroy {\n subscription;\n constructor(private service){ }\n\n ngOnInit() {\n this.subscription = this.service.getData()\n .subscribe( data => this.data = data )\n }\n\n ngOnDestroy() {\n this.subscription.unsubscribe(); \n }\n}\n```", "```ts\n@Component({\n template: `{{ data | async }}`\n})\nexport class DataComponent implements OnInit {\n data$;\n constructor(private service){ }\n\n ngOnInit() {\n this.data$ = this.service.getData();\n }\n}\n```", "```ts\n{{ (data | ansync)?.title }}\n{{ (data | ansync)?.description }}\n{{ (data | ansync)?.author }}\n```", "```ts\n<div *ngIf=\"data | async as d\">\n {{ d.title }}\n {{ d.description }}\n {{ d.author }}\n</div>\n```", "```ts\nlet stream$ = Observable.create( observer => {\n let i = 0;\n let interval = setInterval(() => {\n observer.next(i++);\n }, 2000)\n})\n\nlet subscription = stream$.subscribe( data => console.log( data ));\nsetTimeout((\n subscription.unsubscribe();\n) =>, 3000)\n\n```", "```ts\nlet stream$ = Observable.create( observer => {\n let i = 0;\n let interval = setInterval(() => {\n observer.next(i++);\n }, 2000);\n\n return function cleanUp() {\n clearInterval( interval );\n }\n})\n\nlet subscription = stream$.subscribe( data => console.log( data ));\nsetTimeout(() => subscription.unsubscribe(), 3000);\n```"]