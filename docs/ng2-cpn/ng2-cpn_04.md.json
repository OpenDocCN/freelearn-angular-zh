["```ts\n[app.component.ts]\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'app works!';\n}\n```", "```ts\nimport './polyfills.ts';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\nimport { enableProdMode } from '@angular/core';\nimport { environment } from './environments/environment';\nimport { AppModule } from './app/';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n```", "```ts\nimport './polyfills.ts';\nimport { platformBrowser } from '@angular/platform-browser';\nimport { enableProdMode } from '@angular/core';\nimport { environment } from './environments/environment';\nimport { AppModuleNgFactory } from './app/app.module.ng.factory';\n\nif (environment.production) {\n  enableProdMode();\n\n}\n\nplatformBrowser().bootstrapModuleFactory(AppModuleNgFactory);\n```", "```ts\n[app.module.ts]\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { HttpModule } from '@angular/http';\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n\n  imports: [\n    BrowserModule,\n    FormsModule,\n    HttpModule\n  ],\n\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```", "```ts\n[index.html]\n<html>\n  <head>\n    <!-- other code related to the page head -->\n  </head>\n  <body>\n    <app-root>Loading...</app-root>\n  </body>\n</html>\n```", "```ts\n    @Component({\n      selector: '.app-root'\n    })\n    ```", "```ts\n    <div class=\"app-root\">Loading...</div>\n    ```", "```ts\n    @Component({\n      selector: '[app-root]'\n    })\n    ```", "```ts\n    <div app-root>Loading...</div>\n    ```", "```ts\n    @Component({\n      selector: 'div[app=components]'\n    })\n    ```", "```ts\n    <div app=\"components\">Loading...</div>\n    ```", "```ts\n    @Component({\n      selector: 'div:not(.widget)'\n    })\n    ```", "```ts\n    <div class=\"app\">Loading...</div>\n    ```", "```ts\n    @Component({\n      selector: 'app-root, .app, [ng=app]'\n    })\n    ```", "```ts\n    <app-root>Loading...</app-root>\n    <div class=\"app\">Loading...</div>\n    <div ng=\"app\">Loading...</div>\n    ```", "```ts\n[app.component.ts]\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html'\n})\n```", "```ts\n[app.component.html]\n<h1>\n  {{title}}\n</h1>\n```", "```ts) character. In the following example, we demonstrate how to declare an inline template:\n\n```", "```ts\n\nKeeping the template inline is comfortable as we can see both the template and the component class in the same file.\n\n## Embedding styles in component template\n\nWe will probably want to use some CSS in our component's template. Like templates, we have two options\u2014specifying our CSS classes inline or supplying a URL for external style sheets. Currently, our component uses one external CSS file, by declaring a path in the `styleUrls` array.\n\nAs the property name suggests, we can supply more than one URL to pull the CSS from. The styles defined on those CSS files are now available for use within our template. First let's take a look at the current component declaration:\n\n```", "```ts\n\nAlternatively, we can define styles inline, just like the template, by using the **styles** property instead. **styles** is an array of strings where we can write our CSS rules. The following example demonstrates how to style the `<h1>` tag using inline styles:\n\n```", "```ts\n\nLet's explore the element in Chrome DevTool. Right-click on the `title` and choose inspect from the pop up menu. The Chrome DevTool will launch:\n\n![Embedding styles in component template](../Images/image00101.jpeg)\n\nLooking at the element through the DevTool, we expose some facts about component styling:\n\n*   The style that we defined is transformed into an inline style tag on the `head` section on top of the `html` document\n*   The style definition is changed and now includes a property next to it, which makes it specific and almost impossible to override\n\nAngular protects the component styling from overriding by generating a unique property and attaches it to the original CSS selector that we defined. This behavior tries to mimic the way that the shadow DOM works. So, before we can move forward, we need to understand what the shadow DOM is.\n\n# The shadow DOM\n\nWhen we are creating a component in Angular 2, a shadow DOM is created and our template gets loaded into it (not by default). What is a shadow DOM? Shadow DOM refers to a subtree of DOM elements that renders as part of the document, but not into the main document DOM tree.\n\nLet's see a well-known example of a shadow DOM, an HTML `select`, in action. Create a plain HTML file in your favorite text editor and create a `select` element in its body:\n\n```", "```ts\n\nNext, open it up in Chrome and right-click on the element, then choose **Inspect Element** from the pop-up menu:\n\n![The shadow DOM](../Images/image00102.jpeg)\n\nThe Chrome DevTool will pop up, and we can inspect the `select` element in the **Elements** tab:\n\n![The shadow DOM](../Images/image00103.jpeg)\n\nIf you have ever tried to customize the appearance of a native `html select` element with CSS, you know that you need to hack and develop a workaround to make it work. The `select` element has styling structure, and even a built-in behavior, but we can't see it. It's encapsulated inside the element.\n\nIf you are not familiar with the term encapsulation here is a quick definition taken from Wikipedia:\n\n**Encapsulation** is an Object Oriented Programming concept that binds together the data and functions that manipulate the data, and that keeps both safe from outside interference and misuse.\n\nSo, where does the select appearance come from? Chrome DevTool has a feature that can rival the shadow DOM of this element. To enable this, go to the Settings menu of Chrome DevTool:\n\n![The shadow DOM](../Images/image00104.jpeg)\n\nScroll down and find the **Elements** section. Check the checkbox **Show user agent shadow DOM**:\n\n![The shadow DOM](../Images/image00105.jpeg)\n\nNow, let's inspect the `select` element again:\n\n![The shadow DOM](../Images/image00106.jpeg)\n\nNow we clearly see that the `select` element hides a secret DOM tree. Under the `select` element, a new root is created (the `#shadow-root`) and a content element renders right under it. The hidden content tag has an attribute called `select`, which defines some internal behavior. This is same for the option tag. If you would like to explore one more popular HTML element that creates a shadow DOM, you can repeat those steps using `<input type='file' />`.\n\nThis powerful ability to create a native element, which encapsulates its own styling, behavior, and even data, is also possible with Angular 2.\n\n# Encapsulation modes\n\nBy default, as we have seen, our component won't encapsulate its structure and styling. This means that CSS classes from outside of the component can override and affect the embedded CSS styles that we defined, and the HTML structure of the component is accessible as well.\n\nAngular will generate a unique property for our `selector` to protect our styling, but this can be overridden with a CSS `!important` statement.\n\nTo change this, we need to define an encapsulation mode. Angular 2 provides us three options to choose from:\n\n*   **Emulated** (the default): Angular will add a special attribute to the class `selector` to avoid affecting other styles outside of the components.\n*   **Native**: This is the native encapsulation mechanism of the renderer that will be applied. In our case, it's the browser. Angular will create a shadow DOM for this component, which means that external CSS can't affect our component.\n*   **None**: No encapsulation will be applied.\n\nTo define encapsulation options, we need to import the `ViewEncapsulation` from Angular core and use one of the options to define the component encapsulation property. The following example demonstrates how to set the component encapsulation model to `None`:\n\n```", "```ts\n\nMost of the time, leaving the default emulate mode is fine. In the future chapters, we will encounter some situations where setting the mode to `None` is crucial.\n\n# Data bindings\n\nTo fully understand the component code that was generated for us by angular-cli, we need to talk about data bindings. In other words, the way that we were able to render the **title** declared on the component class to component template.\n\nFirst, let's take a look at the entire component code:\n\n```"]