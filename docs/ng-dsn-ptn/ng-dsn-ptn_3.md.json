["```ts\nimport { Component } from '@angular/core'; \n\n@Component({ \n  selector: 'app-root', \n  templateUrl: './app.component.html', \n  styleUrls: ['./app.component.css'] \n}) \nexport class AppComponent { \n  title = 'app'; \n} \n```", "```ts\nexport class MySingleton{ \n\n    //The constructor is private so we  \n    //can't do `let singleton:MySingleton = new MySingleton();` \n    private static instance:MySingleton = null; \n\n    private constructor(){ \n\n    } \n\n    public static getInstance():MySingleton{ \n        if(MySingleton.instance == null){ \n            MySingleton.instance = new MySingleton(); \n        }\n```", "```ts\n return MySingleton.instance; \n    } \n} \n let singleton:MySingleton = MySingleton.getInstance();\n```", "```ts\nlet singleton:MySingleton = new MySingleton(); \n```", "```ts\nexport\n\n class MySingleton\n {\n   private static instance : MySingleton = new MySingleton();\n private constructor()\n  {\n }\n\n } singleton: MySingleton = MySingleton.getInstance();\n```", "```ts\n\n import { Injectable } from '@angular/core'; \n\n@Injectable() \nexport class ApiService { \n\n  private static increment:number = 0; \n\n  public constructor(){ \n    ApiService.increment++; \n  } \n\n  public toString() :string { \n    return \"Current instance: \" + ApiService.increment; \n  } \n\n} \n // ./app.component.ts\n\n import { Component } from '@angular/core'; \nimport { ApiService } from './api.service'; \n\n@Component({ \n  selector: 'app-root', \n  templateUrl: './app.component.html', \n  styleUrls: ['./app.component.css'] \n}) \nexport class AppComponent { \n  title = 'app'; \n\n  public constructor(api:ApiService){ \n    console.log(api); \n  } \n} \n\n // ./other/other.component.ts\n\n import { Component, OnInit } from '@angular/core'; \nimport { ApiService } from './../api.service'; \n\n@Component({ \n  selector: 'app-other', \n  templateUrl: './other.component.html', \n  styleUrls: ['./other.component.css'] \n}) \nexport class OtherComponent implements OnInit { \n\n  public constructor(api:ApiService){ \n    console.log(api); \n  } \n\n  ngOnInit() { \n  } \n\n} \n\n //app.module.ts\n\n import { BrowserModule } from '@angular/platform-browser'; \nimport { NgModule } from '@angular/core'; \nimport { MySingleton } from './singleton'; \n\nimport { AppComponent } from './app.component'; \nimport { OtherComponent } from './other/other.component'; \n\nimport { ApiService } from './api.service'; \n\n@NgModule({ \n  declarations: [ \n    AppComponent, \n    OtherComponent \n  ], \n  imports: [ \n    BrowserModule \n  ], \n  providers: [ApiService], \n  bootstrap: [AppComponent] \n}) \nexport class AppModule { \n\n} \n```", "```ts\nCurrent instance: 1\nCurrent instance: 1\n```", "```ts\nimport { Component } from '@angular/core'; \nimport { ApiService } from './api.service'; \n\n@Component({ \n  selector: 'app-root', \n  templateUrl: './app.component.html', \n  styleUrls: ['./app.component.css'] \n}) \nexport class AppComponent { \n  title = 'app'; \n\n  public constructor(api:ApiService){ \n    console.log(api); \n  } \n} \n // ./other.component.ts\n\n @Component({ \n  selector: 'app-root', \n  templateUrl: './app.component.html', \n  styleUrls: ['./app.component.css'] \n  providers: [APIService],\n })\n export class OtherComponent implements OnInit { \n\n  public constructor(api:ApiService){ \n    console.log(api); \n  } \n\n  ngOnInit() { \n  } \n\n} \n```", "```ts\nCurrent instance: 1\nCurrent instance: 2\n```", "```ts\nimport { Component } from '@angular/core';\n\n import {MySingleton} from './singleton';\n import { SingletonService } from './singleton.service';\n\n @Component({\n selector: 'app-root',\n templateUrl: './app.component.html',\n styleUrls: ['./app.component.css']\n })\n export class AppComponent {\n title = 'app works!';\n\n constructor(private singleton:SingletonService){\n singleton.doStuff();\n }\n //OR\n constructor(){\n MySingleton.getInstance().doStuff();\n }\n }\n```", "```ts\nclass User{\n constructor(private lastName:string, private firstName:string){\n }\n hello(){\n console.log(\"Hi I am\", this.firstName, this.lastName);\n }\n }\n```", "```ts\n[{\"lastName\":\"Nayrolles\",\"firstName\":\"Mathieu\"}...]. \n```", "```ts\nlet userFromJSONAPI: User = JSON.parse('[{\"lastName\":\"Nayrolles\",\"firstName\":\"Mathieu\"}]')[0];\n```", "```ts\njson.ts:19\n userFromJSONAPI.hello();\n ^\n TypeError: userFromUJSONAPI.hello is not a function\n at Object.<anonymous> (json.ts:19:18)\n at Module._compile (module.js:541:32)\n at Object.loader (/usr/lib/node_modules/ts-node/src/ts-node.ts:225:14)\n at Module.load (module.js:458:32)\n at tryModuleLoad (module.js:417:12)\n at Function.Module._load (module.js:409:3)\n at Function.Module.runMain (module.js:575:10)\n at Object.<anonymous> (/usr/lib/node_modules/ts-node/src/bin/ts-node.ts:110:12)\n at Module._compile (module.js:541:32)\n at Object.Module._extensions..js (module.js:550:10)\n```", "```ts\nlet validUser = JSON.parse('[{\"lastName\":\"Nayrolles\",\"firstName\":\"Mathieu\"}]')\n .map((json: any):User => {\n return new User(json.lastName, json.firstName);\n })[0];\n```", "```ts\n\n export class POTOFactory{\n\n /**\n * Builds an User from json response\n * @param  {any}  jsonUser\n * @return {User} \n */\n static buildUser(jsonUser: any): User {\n\n return new User(\n jsonUser.firstName,\n jsonUser.lastName\n );\n }\n\n }\n```", "```ts\nexport interface Observer{ notify(); }\n```", "```ts\nexport class HumanObserver implements Observer{ \n constructor(private name:string){}\n\n notify(){\n\n console.log(this.name, 'Notified');\n } } \n```", "```ts\nprivate name:string; constructor(name:string){\n\n this.name = name;\n}\n```", "```ts\nexport class Subject{ private observers:Observer[] = [];\n\n/**\n* Adding an observer to the list of observers\n*/\nattachObserver(observer:Observer):void{\n\n this.observers.push(observer);\n}\n\n/**\n* Detaching an observer\n*/\ndetachObserver(observer:Observer):void{\n\n let index:number = this.observers.indexOf(observer);\n\n if(index > -1){\n\n this.observers.splice(index, 1);\n }else{\n\n throw \"Unknown observer\";\n }\n}\n\n/**\n* Notify all the observers in this.observers\n*/\nprotected notifyObservers(){\n\n for (var i = 0; i < this.observers.length; ++i) {\n\n this.observers[i].notify();\n }\n} } \n```", "```ts\nexport class IMDB extends Subject{\n\n private movies:string[] = [];\n\n public addMovie(movie:string){\n\n this.movies.push(movie);\n this.notifyObservers();\n }\n }\n```", "```ts\nlet imdb:IMDB = new IMDB();\n let mathieu:HumanObserver = new HumanObserver(\"Mathieu\");\n imbd.attachObserver(mathieu);\n imbd.addMovie(\"Jaws\");\n```", "```ts\nimdb.detachObserver(mathieu);\n imdb.addMovie(\"Die Hard\");\n```", "```ts\nexport interface Observer{\n\n notify(value?:any, subject?:Subject);\n }\n\n export class HumanObserver implements Observer{\n\n constructor(private name:string){}\n\n notify(value?:any, subject?:Subject){\n\n console.log(this.name, 'received', value, 'from', subject);\n }\n }\n```", "```ts\nexport class Subject{\n\n private observers:Observer[] = [];\n\n attachObserver(oberver:Observer):void{\n\n this.obervers.push(oberver);\n }\n\n detachObserver(observer:Observer):void{\n let index:number = this.obervers.indexOf(observer);\n if(index > -1){\n this.observers.splice(index, 1);\n\n }else{\n\n throw \"Unknown observer\";\n }\n }\n\n protected notifyObservers(value?:any){\n\n for (var i = 0; i < this.obervers.length; ++i) {\n\n this.observers[i].notify(value, this);\n }\n }\n }\n\n export class IMDB extends Subject{\n\n private movies:string[] = [];\n\n public addMovie(movie:string){\n\n this.movies.push(movie);\n this.notifyObservers(movie);\n }\n }\n```", "```ts\n Mathieu received Jaws from IMDB {\n\n observers: [ HumanObserver { name: 'Mathieu' } ],\n movies: [ 'Jaws' ] }\n```", "```ts\n {\n \"movie_id\" : 1,\n \"title\" : \"The Incredible Hulk\",\n \"phase\" : \"Phase One: Avengers Assembled\",\n \"category_name\" : \"Action\",\n \"release_year\" : 2005,\n \"running_time\" : 135,\n \"rating_name\" : \"PG-13\",\n \"disc_format_name\" : \"Blu-ray\",\n \"number_discs\" : 1,\n \"viewing_format_name\" : \"Widescreen\",\n \"aspect_ratio_name\" : \" 2.35:1\",\n \"status\" : 1,\n \"release_date\" : \"June 8, 2008\",\n \"budget\" : \"150,000,000\",\n \"gross\" : \"263,400,000\",\n \"time_stamp\" : \"2018-06-08\"\n },\n```", "```ts\nIMDBAPI.fetchOneById(1);\n IMDBAPI.fetchByFields(MovieFields.release_date, 2015);\n```", "```ts\nmkdir angular-observable\n ng init\n ng serve\n```", "```ts\nexport class Movie {\n\n public constructor(\n private _movie_id:number,\n private _title: string,\n private _phase: string,\n private _category_name: string,\n private _release_year: number,\n private _running_time: number,\n private _rating_name: string,\n private _disc_format_name: string,\n private _number_discs: number,\n private _viewing_format_name: string,\n private _aspect_ratio_name: string,\n private _status: string,\n private _release_date: string,\n private _budget: number,\n private _gross: number,\n private _time_stamp:Date){\n }\n\n public toString = () : string => {\n\n return `Movie (movie_id: ${this._movie_id},\n title: ${this._title},\n phase: ${this._phase},\n category_name: ${this._category_name},\n release_year: ${this._release_year},\n running_time: ${this._running_time},\n rating_name: ${this._rating_name},\n disc_format_name: ${this._disc_format_name},\n number_discs: ${this._number_discs},\n viewing_format_name: ${this._viewing_format_name},\n aspect_ratio_name: ${this._aspect_ratio_name},\n status: ${this._status},\n release_date: ${this._release_date},\n budget: ${this._budget},\n gross: ${this._gross},\n time_stamp: ${this._time_stamp})`;\n\n }\n //GETTER\n //SETTER\n }\n\n export enum MovieFields{\n movie_id,\n title,\n phase,\n category_name,\n release_year,\n running_time,\n rating_name,\n disc_format_name,\n number_discs,\n viewing_format_name,\n aspect_ratio_name,\n status,\n release_date,\n budget,\n gross,\n time_stamp\n }\n```", "```ts) and the `${}` syntax that allows the concatenation of strings and different variables. Then, we have an enumerator called\u00a0`MovieFields` that will allow us to restrict the searchable field.\n\nMoving on, we need to generate the `IMDBAPI` class. As the `IMDBAPI` class will be potentially used everywhere in our program, we will make it a service. The advantage is that services can be injected into any component or directive. Moreover, we can choose if we want Angular 2 to create an instance of the `IMDBAPI` per injection or always inject the same instance. If the provider for the `IMDBAPI` is created at the application level, then the same instance of the `IMDBAPI` will be served to anyone requesting it. At the component level, however, a new instance of the `IMDBAPI` will be created and served to the component each time the said component is instantiated. In our case, it makes more sense to have only one instance of the `IMDBAPI`, as it will not have any particular states that are susceptible to change from component to component. Let's generate the `IMDBAPI` service (`ng g s` `services/IMDBAPI`) and implement the two methods we defined earlier:\n\n```", "```ts\n\nHere's the IMDAPI service with the `fetchOneById` method:\n\n```", "```ts\n\n# Understanding the implementation\n\nLet's break it down chunk by chunk. First, the declaration of the service is pretty standard:\n\n```", "```ts\n\nServices are injectable. Consequently, we need to import and add the `@Injectable` annotation. We also import `Http`, `Movie`, `MovieFields`, `Observable`, and the operators of `Rxjs`. **RxJS** stands for **reactive extensions for JavaScript**. It is an API to perform observer, iterator, and functional programming. When it comes to asynchronism in Angular 2, you rely on RxJS for the most part.\n\nOne important thing to note is that we use RxJS 5.0, which is a complete rewrite, based on the same concept of RxJS 4.0.\n\n`IMDBAPIService` also has a reference to the path of our JSON file and a constructor to receive an injection of the HTTP service. On the implementation of the `fetchOneById` method, we can see four distinct operations chained to each other: `get`, `flatMap`, `filter`, and `map`. `Get` returns an observable on the body of the HTTP request. `flatMap` transforms the `get Observable` by applying a function that you specify for each item emitted by the source `Observable`, where that function returns an `Observable` that emits items. `FlatMap` then merges the emissions of these resultant`Observables`, emitting these merged results as its sequence. In our case, it means that we will apply the next two operations (filter and map) on all the items received from the HTTP get. The filter checks if the ID of the current movie is the one we are looking to Map transform the JSON representation of a movie into the typeScript representation of a movie (such as the `Movie` class).\n\nThis last operation, while counter-intuitive, is mandatory. Indeed, one could think that the JSON representation and the TypeScript representation are identical as they own the same fields. However, the TypeScript representation, as well as its properties, define functions such as `toString`, the getters, and the setters. Removing the map would return an `Object` instance containing all the fields of`Movie` without being one. Also, a typecast will not help you there. Indeed, the TypeScript transpiler will allow you to cast an `Object` into a `Movie`, but it still won't have the methods defined in the `Movie` class as the concept of static typing disappears when the TypeScript is transpiled into JavaScript. The following would\u00a0\u00a0fail\u00a0to transpile at execution time:\n\n```", "```ts\n\nNow, if we want to use our `IMDB` service, further modifications of the code that was generated by the Angular CLI is required. First, we need to modify `main.ts` so that it looks like this:\n\n```", "```ts\n\n```", "```ts\n\nThe lines in bold represent what has been added. We import our `IMDBService` and the `HTTP_PROVIDERS`. Both providers are declared at the application level, meaning that the instance that will be injected into the controller or directive will always be the same.\n\nThen, we modify the `angular-observable.component.ts` file that was generated and add the following:\n\n```", "```ts\n\nWe have added several properties to\u00a0`AngularObservableAppComponent`: `movies`, `error`, and `finished`. The first property is an array of `Movie` that will store the result of our queries, and the second and the third properties flag for `error` and `termination`. In the constructor, we have an injection of\u00a0`IMDBAPIService`, and we subscribe to the result of the `fetchOneById` method. The `subscribe` method expects three callbacks:\n\n*   **Observer:** Receives the value yield by the observed method. It is the RxJS equivalent of the notifying method we saw earlier in this chapter.\n*   **Error** (**Optional**): Triggered in the case that the observed object yields an error.\n*   **Complete** (**Optional**): Triggered on completion.\u00a0\n\nFinally, we can modify the `angular-ob``servable.component.html` file to map the`movie` property of the `AngularObservableAppComponent` array:\n\n```", "```ts\n\nWe can see that the first movie item has been correctly inserted into our `ul`/`li` HTML structure. What's really interesting about this code is the order in which things execute. Analyzing the log helps us to grasp the true power of asynchronism in Angular with RxJS. Here's what the console looks like after the execution of our code:\n\n```", "```ts\n\nAs you can see,\u00a0`AngularObservableAppComponent` was notified that a movie matching the query was found before the filter function analyzed all the items. As a reminder, the order of operations inside\u00a0`fetchOneById` by ID was: `get`, `flatMap`, `filter`, and `map`, and we have a logging statement in the `filter` and `map` method as well. So, here, the `filter` operation analyzes the first item, which happens to be the one we look for (`movie_id===1`), and forwards it to the map operations that transform it into a `Movie`. This `Movie` is sent right away to`AngularObservableAppComponent`. We can clearly see that the received object in the `AngularObservableAppComponent` component is from the `Movie` type\u00a0as the console gives us our overriding of the `toString` method. Then, the filter operation continues with the rest of the items. None of them match. Consequently, we do not have any more notifications. Let's test this further with a second method,\u00a0`IMDBAPI.fetchByField`:\n\n```", "```ts\n\nFor the `fetchByField` method, we use the same mechanisms as the `fetchById`. Unsurprisingly, the operations stay the same: `get`, `flatMap`, `filter`, and `map`. The only change is in the filter operation, where we now have to filter on a field that's received as a parameter:\n\n```", "```ts\n\nThis statement can be a bit overwhelming to the TypeScript or JavaScript newcomer. First, the `MovieFields[field]` part is explained by the fact that `enum` will be transpiled into the following JavaScript function:\n\n```", "```ts\n\nConsequently, the value of `MovieFields.release_year` is, in fact, 4, and `MovieFields` is a static array. Consequently, requesting the fourth index of the `MovieFields` array gives me the string `release_year is`. So, `movie[MovieFields[field]]` is interpreted as a `movie[\"release_year is\"]` in our current example.\n\nNow, we have five matches instead of one. Upon analysis of the console, we can see that the notifications still come as soon as a suitable object is found and not when they have all been filtered:\n\n```", "```ts\n\nNow, the other strength of this design pattern is the ability to unsubscribe yourself. To do so, you only have to acquire a reference to your subscription and call the `unsubscribe()` method, as follows:\n\n```", "```ts\n\nHere, we unsubscribe after the third notification. To add to all this, the observable object will even detect that nobody's observing it anymore and will stop whatever it was doing. Indeed, the previous code with `unsubscribe` produces:\n\n```", "```ts\n\nEverything stops after the third notification.\n\n# Promises\n\nThe promise is another useful asynchronous concept that has been provided by Angular 2\\. It promises to provide the same feature as `Observer`: process something and, asynchronously, notify the caller that an answer is available. So, why bother having two concepts that do the same thing? Well, the verbosity of `Observer` allows one thing that the `Promise`does not: unsubscribe. Consequently, if you never plan on using the unsubscribe capacity of the observer pattern, you are better off using `Promises`, which are, in my opinion, more intuitive in their writing and understanding. To emphasize the differences between observers and promises, we will take the same example as before\u2014fetching movies from a JSON API. `AngularObservableAppComponent` will make an asynchronous call to`IMDBAPIService` and, upon the answer, will update the HTML view.\n\nHere's the `fetchOneById` method using `Promise` instead of `Observable`:\n\n```", "```ts\n\nAs shown by this code, we went from `flatMap`, `filter`, `map`, to `flatMap`, `filter`, to\u00a0`Promise`,\u00a0`then`. The new operations, `toPromise` and `then`, are creating a `Promise` object that will contain the result of the `filter`operation and, on completion of the `filter` operation, the `then` operation will be executed. The `then` operation can be thought of as a map; it does the same thing. To use this code, we also have to change the way we call `IMDBAPIService` in `AngularObservableAppComponent` to the following:\n\n```", "```ts\n\nOnce again, we can see a `then` operation that will be executed when the promise from `IMDBAPIService.FetchOneById` has completed. The `then` operation accepts two callbacks: `onCompletion` and `onError`. The second callback, `onError`, is optional. Now, the `onCompletion` callback will only be executed once, when the Promise has completed, as shown in the console:\n\n```", "```ts\n\nWhile the modification of `IMDBAPIService` was minimal for the `fetchOneById` method, we will have to change `fetchByField` more significantly. Indeed, the `onComplete` callback will only be executed once, so we need to return an array of `Movie` and not only one `Movie`. Here's the implementation of the `fetchByField` method:\n\n```", "```ts\n\nTo implement this, I trade\u00a0`flatMap` for a classical map as the first operation. In the map, I directly acquire the reference to the JSON `movie` array and apply the filed filter. The result is transformed into a promise and processed in `then`. The `then` operation receives an array of JSON `movies` and transforms it into an array of `Movie`. This produces an array of `Movie` which is returned, as the promised result, to the caller. The call in\u00a0\u00a0`AngularObservableAppComponent` is also a bit different, as we now expect an array:\n\n```", "```ts\n\nAnother way to use `Promise` is through the fork/join paradigm. Indeed, it is possible to launch many processes (fork) and wait for all the promises to complete before sending the aggregated result to the caller (join). It is therefore relatively easy to supercharge the `fetchByField` method, as it can run in many fields with logic or. Here are the three very short methods we need to implement to logic or:\n\n```", "```ts\n\nHere, I provide two convenient methods, `field` and `or`, that take a `MovieField` and a value as an argument and create a new promise. They both return `this` for chaining. The `fetch` method joins all the promises together and merges their respective results. In `AngularObservableAppComponent`, we now have the following:\n\n```"]