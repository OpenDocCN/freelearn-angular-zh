["```ts\nwindow[\"ng\"].profiler\n```", "```ts\nvar timeChangeDetection = window[\"ng\"].profiler.timeChangeDetection()\n```", "```ts\nvar memory:any = window.performance[\"memory\"] ? window.performance[\"memory\"] : {\n\"jsHeapSizeLimit\":0,\n\"totalJSHeapSize\":0,\n\"usedJSHeapSize\":0,\n}\n```", "```ts\nvar connection:any = window.navigator[\"connection\"] ? window.navigator[\"connection\"] : {\n\"effectiveType\": \"n/a\",\n\"cnxDownlink\": 0,\n}\n```", "```ts\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n@Injectable()\nexport class MonitorService {\nconstructor(private http:HttpClient) { }\npublic metrics(){\nvar timeChangeDetection = window[\"ng\"].profiler.timeChangeDetection()\nvar memory:any = window.performance[\"memory\"] ? window.performance[\"memory\"] : {\n\"jsHeapSizeLimit\":0,\n\"totalJSHeapSize\":0,\n\"usedJSHeapSize\":0,\n}\nvar connection:any = window.navigator[\"connection\"] ? window.navigator[\"connection\"] : {\n\"effectiveType\": \"n/a\",\n\"cnxDownlink\": 0,\n}\nvar perf = {\n\"msPerTick\": timeChangeDetection.msPerTick,\n\"numTicks\": timeChangeDetection.numTicks,\n\"core\": window.navigator.hardwareConcurrency,\n\"appVersion\": window.navigator.appVersion,\n\"jsHeapSizeLimit\": memory.jsHeapSizeLimit,\n\"totalJSHeapSize\": memory.totalJSHeapSize,\n\"usedJSHeapSize\": memory.usedJSHeapSize,\n\"cnxEffectiveType\": connection.effectiveType,\n\"cnxDownlink\": connection.downlink,\n}\nthis.http.post(\"https://api.yourwebsite/metrics/\", perf)\nreturn perf;\n}\n}\n```", "```ts\npublic metric(label:string, value:any){\nthis.http.post(\"https://api.yourwebsite/metric/\", {\nlabel:label,\nvalue:value,\n})\n}\n```", "```ts\nwindow.onerror = function myErrorHandler(errorMsg, url, lineNumber) {\nalert(\"Error occured: \" + errorMsg);\n}\n```", "```ts\nclass MyErrorHandler implements ErrorHandler {\nhandleError(error) {\n// do something with the exception\n}\n}\n```", "```ts\nimport { Injectable, ErrorHandler } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n@Injectable()\nexport class MonitorService implements ErrorHandler{\nconstructor(private http:HttpClient) { }\nhandleError(error) {\nthis.http.post(\"https://api.yourwebsite/errors/\", error)\n}\n...\n}\n```", "```ts\nproviders : [{ provide : ErrorHandler, useClass : MonitorService }]\n```", "```ts\nfunction myFunc(){\nConsole.log(\"hello\");\n}\nfunction myBeforeAspect(){\nConsole.log(\"before...\")\n}\nfunction myAfterAspect(){\nConsole.log(\"after\");\n}\nvar oldFunc = myFunc;\nmyFunc = function(){\nmyBeforeAspect();\noldFunc();\nmyAfterAspect();\n}\n```", "```ts\nconstructor(){\nthis.click = function(){\nthis.before();\nthis.click();\nthis.after();\n}\n}\nafter(){\nconsole.log(\"after\")\n}\nbefore(){\nconsole.log(\"before\");\n}\nclick(){\nconsole.log(\"hello\")\n}\n```", "```ts\n<button (click)=\"click()\">click</button>\n```", "```ts\nclass LoggerAspect {\n@afterMethod({\nclassNamePattern: /^someClass/,\nmethodNamePattern: /^(some|other)/\n})\ninvokeAfterMethod(meta: Metadata) {\nconsole.log(`Inside of the logger. Called ${meta.className}.${meta.method.name} with args: ${meta.method.args.join(', ')}.`);\n@beforeMethod({\nclassNamePattern: /^someClass/,\nmethodNamePattern: /^(get|set)/\n})\ninvokeBeforeMethod(meta: Metadata) {\nconsole.log(`Inside of the logger. Called ${meta.className}.${meta.method.name} with args: ${meta.method.args.join(', ')}.`);\n}\n}\n```", "```ts\nstatic httpStatic:HttpClient\nconstructor(private http:HttpClient) {\nMonitorService.httpStatic = http;\n}\nstatic sendLog(log:string){\nMonitorService.httpStatic.post(\"https://api.yourwebsite/logs/\", log)\n}\n```", "```ts\nimport { Injectable, ErrorHandler } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n@Injectable()\nexport class MonitorService implements ErrorHandler{\nstatic httpStatic:HttpClient\nconstructor(private http:HttpClient) {\nMonitorService.httpStatic = http;\n}\npublic static log(log:string){\nMonitorService.httpStatic.post(\"https://api.yourwebsite/logs/\", log)\n}\nhandleError(error) {\nthis.http.post(\"https://api.yourwebsite/metrics/\", error)\n}\npublic metric(label:string, value:any){\nthis.http.post(\"https://api.yourwebsite/metric/\", {\nlabel:label,\nvalue:value,\n})\n}\npublic metrics(){\nvar timeChangeDetection = window[\"ng\"].profiler.timeChangeDetection()\nvar memory:any = window.performance[\"memory\"] ? window.performance[\"memory\"] : {\n\"jsHeapSizeLimit\":0,\n\"totalJSHeapSize\":0,\n\"usedJSHeapSize\":0,\n}\nvar connection:any = window.navigator[\"connection\"] ? window.navigator[\"connection\"] : {\n\"effectiveType\": \"n/a\",\n\"cnxDownlink\": 0,\n}\nthis.metric(\"msPerTick\", timeChangeDetection.msPerTick);\nthis.metric(\"numTicks\", timeChangeDetection.numTicks);\nthis.metric(\"core\", window.navigator.hardwareConcurrency);\nthis.metric(\"appVersion\", window.navigator.appVersion);\nthis.metric(\"jsHeapSizeLimit\", memory.jsHeapSizeLimit);\nthis.metric(\"totalJSHeapSize\", memory.totalJSHeapSize);\nthis.metric(\"usedJSHeapSize\", memory.usedJSHeapSize);\nthis.metric(\"cnxEffectiveType\", connection.effectiveType);\nthis.metric(\"cnxDownlink\", connection.downlink);\n}\n}\n```", "```ts\nclass LoggerAspect {\n@afterMethod({\nclassNamePattern: /^SomeClass/,\nmethodNamePattern: /^(some|other)/\n})\ninvokeBeforeMethod(meta: Metadata) {\nMonitorService.log(`Called ${meta.className}.${meta.method.name} with args: ${meta.method.args.join(', ')}.`);\n}\n@beforeMethod({\nclassNamePattern: /^SomeClass/,\nmethodNamePattern: /^(get|set)/\n})\ninvokeBeforeMethod(meta: Metadata) {\nMonitorService.log(`Inside of the logger. Called ${meta.className}.${meta.method.name} with args: ${meta.method.args.join(', ')}.`);\n}\n}\n```", "```ts\n@Wove({ bar: 42, foo : \"bar\" })\nclass SomeClass { }\n```", "```ts\n@Wove({ startTime: 0 })\nclass SomeClass { }\nclass ExecutionTimeAspect {\n@afterMethod({\nclassNamePattern: /^SomeClass/,\nmethodNamePattern: /^(some|other)/\n})\ninvokeBeforeMethod(meta: Metadata) {\nmeta.startTime = Date.now();\n}\n@beforeMethod({\nclassNamePattern: /^SomeClass/,\nmethodNamePattern: /^(get|set)/\n})\ninvokeBeforeMethod(meta: Metadata) {\nMonitorService.metric(`${meta.className}.${meta.method.name`,\nDate.now() - meta.startTime;\n}\n}\n```"]