["```ts\n    ng new timeout\n    cd timeout\n    ng g service API\n```", "```ts\nimport { Injectable } from '@angular/core'; \n\n@Injectable() \nexport class ApiService { \n\n  constructor() { } \n\n} \n```", "```ts\nimport { BrowserModule } from '@angular/platform-browser'; \nimport { NgModule } from '@angular/core'; \nimport { HttpClientModule } from '@angular/common/http'; \n\nimport { AppComponent } from './app.component'; \nimport { ApiService } from './api.service'; \n\n@NgModule({ \n  declarations: [ \n    AppComponent \n  ], \n  imports: [ \n    BrowserModule, \n    HttpClientModule \n  ], \n  providers: [ApiService], \n  bootstrap: [AppComponent] \n}) \nexport class AppModule { } \n```", "```ts\nimport { Injectable } from '@angular/core'; \nimport { HttpClient } from '@angular/common/http'; \n\n@Injectable() \nexport class ApiService { \n\n  constructor(private http:HttpClient) { } \n\n} \n```", "```ts\nimport { Injectable } from '@angular/core'; \nimport { HttpClient } from '@angular/common/http'; \n\n@Injectable() \nexport class ApiService { \n\n  constructor(private http: HttpClient) { } \n\n  public getURL(url: string): void { \n    this.http.get(url) \n    .subscribe(data => { \n      console.log(data); \n    }); \n  }  \n\n} \n```", "```ts\nimport { Component } from '@angular/core'; \nimport { ApiService } from './api.service'; \n\n@Component({ \n  selector: 'app-root', \n  templateUrl: './app.component.html', \n  styleUrls: ['./app.component.css'] \n}) \nexport class AppComponent { \n  title = 'app'; \n\n  constructor(private api: ApiService){ \n    api.getURL(\"https://github.com/MathieuNls/Angular-Design-Patterns-and-Best-Practices\") \n  } \n}\n```", "```ts\nimport { Injectable } from '@angular/core'; \nimport { HttpClient } from '@angular/common/http'; \n\n@Injectable() \nexport class ApiService { \n\n  constructor(private http: HttpClient) { } \n\n  public getURL(url: string): void { \n\n    let timeout; \n\n    let sub = this.http.get(url) \n      .subscribe((res) => { \n        console.log(res); \n        clearTimeout(timeout) \n      }); \n\n    timeout = setTimeout( \n      () => { sub.unsubscribe() }, 1000 \n    ); \n  } \n\n} \n```", "```ts\n//ApiStatus class \nclass ApiStatus { \n\n  public lastFail: number \n  public calls: Call[] \n\n  constructor(public url: string) { } \n\n  //Compute the fail percentage \n  public failPercentage(timeWindow: number): number { \n\n    var i = this.calls.length - 1; \n    var success = 0 \n    var fail = 0; \n\n    while (this.calls[i].time > Date.now() - timeWindow && i >= 0) { \n      if (this.calls[i].status) { \n        success++; \n      } else { \n        fail++; \n      } \n   i--; \n    } \n\n    return fail / (fail + success) \n  } \n\n} \n```", "```ts\n//An Api Call \nclass Call { \n  constructor(public time: number, public status: boolean) { } \n} \n```", "```ts\nimport { Injectable } from '@angular/core'; \nimport { HttpClient } from '@angular/common/http'; \n\n@Injectable() \nexport class ApiwithBreakerService { \n\n  constructor(private http: HttpClient) { } \n```", "```ts\n private apis: Map<string, ApiStatus>; \n  private failPercentage: number = 0.2; \n  private timeWindow : number = 60*60*24; \n  private timeToRetry : number = 60;\n```", "```ts\n //Http get an url \n  public getURL(url: string): void { \n\n    var rootUrl = this.extractRootDomain(url); \n\n    if(this.isClosed(rootUrl) || this.readyToRetry(rootUrl)){ \n      let timeout; \n\n      let sub = this.http.get(url) \n        .subscribe((res) => { \n          console.log(res); \n          clearTimeout(timeout); \n          this.addCall(rootUrl, true); \n        }); \n\n      timeout = setTimeout( \n        () => {  \n          sub.unsubscribe(); \n          this.addCall(rootUrl, false); \n        }, 1000 \n      ); \n    } \n  } \n```", "```ts\nif(this.isClosed(rootUrl) || this.readyToRetry(rootUrl)) \n```", "```ts\n //Add a call \n  private addCall(url: string, status: boolean) { \n\n    let res = this.apis.get(url); \n\n    if (res == null) { \n      res = new ApiStatus(url); \n      this.apis.set(url, res); \n    } \n\n    res.calls.push(new Call(Date.now(), status)); \n\n    if(!status){ \n      res.lastFail = Date.now(); \n    } \n  } \n```", "```ts\n //Are we ready to retry \n  private readyToRetry(url:string): boolean { \n\n    return this.apis.get(url).lastFail < (Date.now() - this.timeToRetry) \n  } \n\n  //Is it closed ? private isClosed(url :string) : boolean { \n\n    return this.apis.get(url) == null ||  \n      !(this.apis.get(url).failPercentage(this.timeWindow) > this.failPercentage); \n  } \n```", "```ts\nimport { Injectable } from '@angular/core'; \nimport { HttpClient } from '@angular/common/http'; \n\n//ApiStatus class \nclass ApiStatus { \n\n  public lastFail: number \n  public calls: Call[] \n\n  constructor(public url: string) { } \n\n  //Compute the fail percentage \n  public failPercentage(timeWindow: number): number { \n\n    var i = this.calls.length - 1; \n    var success = 0 \n    var fail = 0; \n\n    while (this.calls[i].time > Date.now() - timeWindow && i >= 0) { \n      if (this.calls[i].status) { \n        success++; \n      } else { \n        fail++; \n      } \n      i--; \n    } \n```", "```ts\n return fail / (fail + success) \n  } \n\n} \n\n//An Api Call \nclass Call { \n  constructor(public time: number, public status: boolean) { } \n} \n\n@Injectable() \nexport class ApiwithBreakerService { \n\n  constructor(private http: HttpClient) { } \n\n  private apis: Map<string, ApiStatus>; \n  private failPercentage: number = 0.2; \n  private timeWindow : number = 60*60*24; \n  private timeToRetry : number = 60; \n\n  //Http get an url \n  public getURL(url: string): void { \n\n    var rootUrl = this.extractRootDomain(url); \n\n    if(this.isClosed(rootUrl) || this.readyToRetry(rootUrl)){ \n      let timeout; \n\n      let sub = this.http.get(url) \n        .subscribe((res) => { \n          console.log(res); \n          clearTimeout(timeout); \n          this.addCall(rootUrl, true); \n        }); \n\n      timeout = setTimeout( \n        () => {  \n          sub.unsubscribe(); \n          this.addCall(rootUrl, false); \n        }, 1000 \n      ); \n    } \n  } \n\n  //Add a call \n  private addCall(url: string, status: boolean) { \n\n    let res = this.apis.get(url); \n\n    if (res == null) { \n      res = new ApiStatus(url); \n      this.apis.set(url, res); \n    } \n\n    res.calls.push(new Call(Date.now(), status)); \n\n    if(!status){ \n      res.lastFail = Date.now(); \n    } \n  } \n\n  //Are we ready to retry \n  private readyToRetry(url:string): boolean { \n\n    return this.apis.get(url).lastFail < (Date.now() - this.timeToRetry) \n  } \n\n  //Is it closed ? private isClosed(url :string) : boolean { \n\n    return this.apis.get(url) == null ||  \n      !(this.apis.get(url).failPercentage(this.timeWindow) > this.failPercentage); \n  } \n\n  private extractHostname(url: string) : string { \n    var hostname; \n    //find & remove protocol (http, ftp, etc.) and get hostname \n\n    if (url.indexOf(\"://\") > -1) { \n      hostname = url.split('/')[2]; \n    } \n    else { \n      hostname = url.split('/')[0]; \n    } \n\n    //find & remove port number \n    hostname = hostname.split(':')[0]; \n    //find & remove \"?\" hostname = hostname.split('?')[0]; \n\n    return hostname; \n  } \n\n  private extractRootDomain(url: string) : string{ \n    var domain = this.extractHostname(url), \n      splitArr = domain.split('.'), \n      arrLen = splitArr.length; \n\n    //extracting the root domain here \n    //if there is a subdomain  \n    if (arrLen > 2) { \n      domain = splitArr[arrLen - 2] + '.' + splitArr[arrLen - 1]; \n      //check to see if it's using a Country Code Top Level Domain (ccTLD) (i.e. \".me.uk\") \n      if (splitArr[arrLen - 1].length == 2 && splitArr[arrLen - 1].length == 2) { \n        //this is using a ccTLD \n        domain = splitArr[arrLen - 3] + '.' + domain; \n      } \n    } \n    return domain; \n  } \n} \n```", "```ts\nclass User{\n constructor(private lastName:string, private firstName:string){\n }\n hello(){\n console.log(\"Hi I am\", this.firstName, this.lastName);\n }\n }\n```", "```ts\n[{\"lastName\":\"Nayrolles\",\"firstName\":\"Mathieu\"}...]. \n```", "```ts\nlet userFromJSONAPI: User = JSON.parse('[{\"lastName\":\"Nayrolles\",\"firstName\":\"Mathieu\"}]')[0]; \n```", "```ts\njson.ts:19\n userFromJSONAPI.hello();\n ^\n TypeError: userFromUJSONAPI.hello is not a function\n at Object.<anonymous> (json.ts:19:18)\n at Module._compile (module.js:541:32)\n at Object.loader (/usr/lib/node_modules/ts-node/src/ts-node.ts:225:14)\n at Module.load (module.js:458:32)\n at tryModuleLoad (module.js:417:12)\n at Function.Module._load (module.js:409:3)\n at Function.Module.runMain (module.js:575:10)\n at Object.<anonymous> (/usr/lib/node_modules/ts-node/src/bin/ts-node.ts:110:12)\n at Module._compile (module.js:541:32)\n at Object.Module._extensions..js (module.js:550:10)\n```", "```ts\nlet validUser = JSON.parse('[{\"lastName\":\"Nayrolles\",\"firstName\":\"Mathieu\"}]')\n .map((json: any):User => {\n return new User(json.lastName, json.firstName);\n })[0];\n```", "```ts\n\n export class POTOFactory{\n\n /**\n * Builds an User from json response\n * @param  {any}  jsonUser\n * @return {User} \n */\n static buildUser(jsonUser: any): User {\n\n return new User(\n jsonUser.firstName,\n jsonUser.lastName\n );\n }\n\n }\n```", "```ts\n\n <div *ngFor=\"let movie of model.movies\">\n <p>{{movie.title}}</p>\n <p>{{movie.year}}</p>\n </div>\n```", "```ts\n<form>\n <input id=\"title\" name=\"title\" type=\"text\" [(ngModel)]=\"movie.title\" />\n <input id=\"year\" name=\"year\" type=\"text\" [(ngModel)]=\"movie.year\" />\n </form>\n\n <a href=\"/back\">Cancel</a>\n```", "```ts\nexport class Movie implements Prototype {\n\n private title:string;\n private year:number;\n //...\n\n public constructor()\n public constructor(title:string = undefined, year:number = undefined)\n {\n if(title == undefined || year == undefined){\n //do the expensive creation\n }else{\n this.title = title;\n this.year = year;\n }\n }\n\n clone() : Movie {\n return new Movie(this.title, this.year);\n }\n\n restore(movie:Movie){\n this.title = movie.title;\n this.year = movie.year;\n }\n }\n```", "```ts\n\n private memento:Movie;\n\n constructor(private movie:Movie){\n\n this.memento = movie.clone();\n }\n\n public cancel(){\n this.movie.restore(this.memento);\n }\n```"]