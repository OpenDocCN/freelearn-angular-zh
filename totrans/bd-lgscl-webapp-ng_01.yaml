- en: Building Our First App - 7 Minute Workout
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be building a new app in Angular, and in the process, become more familiar
    with the framework. This app will also help us explore some new capabilities of
    Angular.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that we will cover in this chapter include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '**7 Minute Workout problem description**: We detail the functionality of the
    app that we build in this chapter.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code organization**: For our first real app, we will try to explain how to
    organize code, specifically Angular code.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Designing the model**: One of the building blocks of our app is its model.
    We design the app model based on the app''s requirements.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding the data binding infrastructure**: While building the *7 Minute
    Workout* view, we will look at the data binding capabilities of the framework,
    which include *property*, *attribute*, *class*, *style*, and *event* bindings.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exploring the Angular platform directives**: Some of the directives that
    we will cover are `ngFor`, `ngIf`, `ngClass`, `ngStyle`, and `ngSwitch`.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-component communication with input properties**: As we build nested
    components, we learn how input properties can be used to pass data from the parent
    to its child components.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-component communication with events**: Angular components can subscribe
    to and raise events. We get introduced to event binding support in Angular.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular pipes**: Angular pipes provide a mechanism to format view content.
    We explore some standard Angular pipes and build our own pipe to support conversions
    from seconds to hh:mm:ss.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started! The first thing we will do is to define our *7 Minute Workout*
    app.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: What is 7 Minute Workout?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want everyone reading this book to be physically fit. Therefore, this book
    should serve a dual purpose; it should not only stimulate your grey matter but
    also urge you to look after your physical fitness. What better way to do it than
    to build an app that targets physical fitness!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '*7 Minute Workout* is an exercise/workout app that requires us to perform a
    set of 12 exercises in quick succession within the seven-minute time span. *7
    Minute Workout* has become quite popular due to its bite-sized length and great
    benefits. We cannot confirm or refute the claims, but doing any form of strenuous
    physical activity is better than doing nothing at all. If you are interested to
    know more about the workout, then check out [http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/](http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The technicalities of the app include performing a set of 12 exercises, dedicating
    30 seconds for each of the exercises. This is followed by a brief rest period
    before starting the next exercise. For the app that we are building, we will be
    taking rest periods of 10 seconds each. So, the total duration comes out at a
    little more than seven minutes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the chapter, we will have the *7 Minute Workout* app ready, which
    will look something like the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8378988e-4540-482e-ac33-e91d1e49b659.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: The 7 Minute Workout app
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the code base
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this app can be downloaded from the GitHub site ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample))
    dedicated to this book. Since we are building the app incrementally, we have created
    **multiple checkpoints** that map to **GitHub branches** such as `checkpoint2.1`,
    `checkpoint2.2`, and so on. During the narration, we will highlight the branch
    for reference. These branches will contain the work done on the app up until that
    point in time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The *7 Minute Workout* code is available in the repository folder named `trainer`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the build
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that we are building on a modern platform for which browsers still
    lack support. Therefore, directly referencing script files in HTML is out of the
    question (while common, it's a dated approach that we should avoid anyway). Browsers
    do not understand **TypeScript**; this implies that there has to be a process
    that converts code written in TypeScript into standard **JavaScript (ES5)**. Hence,
    having a build set up for any Angular app becomes imperative. And thanks to the
    growing popularity of Angular, we are never short of options.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: If you are a frontend developer working on the web stack, you cannot avoid **Node.js**.
    This is the most widely used platform for web/JavaScript development. So, no prizes
    for guessing that most of the Angular build solutions out there are supported
    by Node. Packages such as **Grunt**, **Gulp**, **JSPM**, and **webpack** are the
    most common building blocks for any build system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Since we too are building on the Node.js platform, install Node.js before starting.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: For this book and this sample app, we endorse **Angular CLI** ([http://bit.ly/ng6be-angular-cli](http://bit.ly/ng6be-angular-cli)).
    A command line tool, it has a build system and a scaffolding tool that hugely
    simplifies Angular's development workflow. It is popular, easy to set up, easy
    to manage, and supports almost everything that a modern build system should have.
    More about it later.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'As with any mature framework, Angular CLI is not the only option out there
    on the web. Some of the notable starter sites plus build setups created by the
    community are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '| **Start site** | **Location** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: '| `angular2-webpack-starter` | [http://bit.ly/ng2webpack](http://bit.ly/ng2webpack)
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| `angular-seed` | [https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed)
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: 'Let''s start with installing Angular CLI. On the command line, type the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once installed, Angular CLI adds a new command `ng` to our execution environment.
    To create a new Angular project from the command line, run the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This generates a folder structure with a bunch of files, a boilerplate Angular
    application, and a preconfigured build system. To run the application from the
    command line, execute the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And you can see a basic Angular application in action!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'For our *7 Minute Workout* app, instead of starting from scratch, we are going
    to start from a version that is based on the project structure generated by `ng
    new` with minor modification. Start with the following steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Curious about what the default project includes? Go ahead and run `ng new PROJECT-NAME`.
    Look at the generated content structure and the Angular CLI documentation to get
    an idea of what's part of a default setup.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the base version of this app from [http://bit.ly/ngbe-base](http://bit.ly/ngbe-base)
    and unzip it to a location on your machine. If you are familiar with how Git works,
    you can just clone the repository and check out the`base` branch:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code serves as the starting point for our app.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `trainer` folder from the command line and execute the command
    `npm install` from the command line to install the **package dependencies** for
    our application.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Packages** in the Node.js world are third-party libraries (such as Angular
    for our app) that are either used by the app or support the app''s building process.
    **npm** is a command-line tool for pulling these packages from a remote repository.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Once npm pulls the app dependencies from the npm store, we are ready to build
    and run the application. From the command line, enter the following command:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This compiles and runs the app. If the build process goes fine, the default
    browser window/tab will open with a rudimentary app page (`http://localhost:4200/`).
    We are all set to begin developing our app in Angular!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: But before we do that, it would be interesting to know a bit more about Angular
    CLI and the customization that we have done on the default project template that
    Angular CLI generates.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Angular CLI
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Angular CLI** was created with the aim of standardizing and simplifying the development
    and deployment workflow for Angular apps. As the documentation suggests:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '"The Angular CLI makes it easy to create an application that already works,
    right out of the box. It already follows our best practices!"'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'It incorporates:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: A build system based on **webpack**
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **scaffolding tool** to generate all standard Angular artifacts including
    modules, directives, components, and pipes
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adherence to **Angular style guide** ([http://bit.ly/ngbe-styleguide](http://bit.ly/ngbe-styleguide)),
    making sure we use community-driven standards for projects of every shape and
    size
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have never heard the term style guide, or may not understand its significance.
    A style guide in any technology is a set of guidelines that help us organize and
    write code that is easy to develop, maintain, and extend. To understand and appreciate
    Angular's own style guide, some familiarity with the framework itself is desirable,
    and we have started that journey.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: A targeted **linter;** Angular CLI integrates with **codelyzer** ([http://bit.ly/ngbe-codelyzer](http://bit.ly/ngbe-codelyzer)),
    a **static code analysis tool** that validates our Angular code against a set
    of rules to make sure that the code we write adheres to standards laid down in
    the Angular style guide
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preconfigured **unit** and **end-to-end** (**e2e**) test framework
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And much more!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Imagine if we had to do all this manually! The steep learning curve would quickly
    overwhelm us. Thankfully, we don't have to deal with it, Angular CLI does it for
    us.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: The Angular CLI build setup is based on webpack, but it does not expose the
    underlying webpack configuration; this is intentional. The Angular team wanted
    to shield developers from the complexities and internal workings of webpack. The
    ultimate aim of Angular CLI is to eliminate any entry level barriers and make
    setting up and running Angular code simple.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't mean Angular CLI is not configurable. There is a *config file* (`angular.json`)
    that we can use to alter the build setup. We will not cover that here. Check the
    configuration file for 7 Minute Workout and read the documentation here: [http://bit.ly/ng6be-angular-cli-config](http://bit.ly/ng6be-angular-cli-config).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'The tweaks that we have done to the default generated project template are:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Referenced Bootstrap CSS in the `style.css` file.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgraded some npm library versions.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changed the prefix configuration for generated code to use `abe` (short for
    Angular By Example) from `app`. With this change, all our components and directive
    selectors will be prefixed by `abe` instead of `app`. Check `app.component.ts`;
    the `selector` is `abe-root` instead of `app-root`.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While on the topic of Angular CLI and builds, there is something that we should
    understand before proceeding.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '*What happens to the TypeScript code we write?*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Code transpiling
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Browsers, as we all know, only work with JavaScript, they don't understand TypeScript.
    We hence need a mechanism to convert our TypeScript code into plain JavaScript
    (**ES5** is our safest bet). The **TypeScript compiler** does this job. The compiler
    takes the TypeScript code and converts it into JavaScript. This process is commonly
    referred to as **transpiling**, and since the TypeScript compiler does it, it's
    called a **transpiler**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript as a language has evolved over the years with every new version adding
    new features/capabilities to the language. The latest avatar, ES2015, succeeds
    ES5 and is a major update to the language. While released in June 2015, some of
    the older browsers still lack support for the ES2015 flavor, of JavaScript making
    its adoption a challenge.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: When transpiling code from TypeScript to JavaScript, we can specify the flavor
    of JavaScript to use. As mentioned earlier, ES5 is our safest bet, but if we plan
    to work with only the latest and greatest browsers, go for ES2015\. For 7 Minute
    Workout, our code to transpile to is ES5 format. We set this TypeScript compiler
    configuration in `tsconfig.json` (see the `target` property).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, transpilation can happen at both build/compile time and at runtime:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '**Build-time transpilation**: Transpilation as part of the build process takes
    the script files (in our case, TypeScript `.ts` files) and compiles them into
    plain JavaScript. Angular CLI does build-time transpilation.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime transpilation**: This happens in the browser at runtime. We directly
    reference the TypeScript files (`.ts` in our case), and the TypeScript compiler,
    which is loaded in the browser beforehand, compiles these script files on the
    fly. This is a workable setup only for small examples/code snippets, as there
    is an additional performance overhead involved in loading the transpiler and transpiling
    the code on the fly.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process of transpiling is not limited to TypeScript. Every language targeted
    towards the web, such as **CoffeeScript**, **ES2015**, (yes JavaScript itself!)
    or any other language that is not inherently understood by a browser needs transpilation.
    There are transpilers for most languages, and the prominent ones (other than TypeScript)
    are **tracuer** and **babel.**
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The Angular CLI build system takes care of setting up the TypeScript compiler
    and sets up file watchers that recompile the code every time we make changes to
    our TypeScript file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to TypeScript, remember that TypeScript does not depend on Angular;
    in fact, Angular has been built on TypeScript. I highly recommend that you look
    at the official documentation on TypeScript ([https://www.typescriptlang.org/](https://www.typescriptlang.org/))
    and learn the language outside the realms of Angular.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Let's get back to the app we are building and start exploring the code setup.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Organizing code
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The advantage of Angular CLI is that is dictates a code organization structure
    that works for applications of all sizes. Here is how the current code organization
    looks:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1552b1b-0bd6-427a-b0f8-0fe6145d65ec.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: '`trainer` is the application root folder.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The files inside `trainer` are configuration files and some standard files that
    are part of every standard node application.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `e2e` folder will contain end to end tests for the app.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src` is the primary folder where all the development happens. All the application
    artifacts go into `src`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `assets` folder inside `src` hosts static content (such as images, CSS,
    audio files, and others).
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `app` folder has the app's source code.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `environments` folder is useful to set configurations for different deployment
    environments (such as *dev, qa, production*).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To organize Angular code inside the `app` folder, we take a leaf from the Angular
    style guide ([http://bit.ly/ng6be-style-guide](http://bit.ly/ng6be-style-guide))
    released by the Angular team.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Feature folders
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The style guide recommends the use of **feature folders** to organize code.
    With feature folders, files linked to a single feature are placed together. If
    a feature grows, we break it down further into sub features and tuck the code
    into sub folders. Consider the `app` folder to be our first feature folder! As
    the application grows, `app` will add sub features for better code organization.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Let's get straight into building the application. Our first focus area, the
    app's model!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The 7 Minute Workout model
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Designing the model for this app requires us to first detail the functional
    aspects of the *7 Minute Workout* app, and then derive a model that satisfies
    those requirements. Based on the problem statement defined earlier, some of the
    obvious requirements are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Being able to start the workout.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Providing a visual clue about the current exercise and its progress. This includes
    the following:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a visual depiction of the current exercise
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing step-by-step instructions on how to do a specific exercise
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The time left for the current exercise
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Notifying the user when the workout ends.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some other valuable features that we will add to this app are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The ability to pause the current workout.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing information about the next exercise to follow.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Providing audio clues so that the user can perform the workout without constantly
    looking at the screen. This includes:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A timer click sound
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Details about the next exercise
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Signaling that the exercise is about to start
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing related videos for the exercise in progress and the ability to play
    them.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, the central themes for this app are **workout** and **exercise**.
    Here, a workout is a set of exercises performed in a specific order for a particular
    duration. So, let's go ahead and define the model for our workout and exercise.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the requirements just mentioned, we will need the following details
    about an exercise:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The name. This should be unique.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The title. This is shown to the user.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The description of the exercise.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instructions on how to perform the exercise.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images for the exercise.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the audio clip for the exercise.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Related videos.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With TypeScript, we can define the classes for our model.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Exercise` class looks as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: TypeScript tips
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Declaring constructor parameters with `public` or `private` is a shorthand for
    creating and initializing class members at one go. The `?` suffix after `nameSound`,
    `procedure`, and `videos` implies that these are optional parameters.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'For the workout, we need to track the following properties:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The name. This should be unique.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The title. This is shown to the user.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exercises that are part of the workout.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The duration for each exercise.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest duration between two exercises.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The model class to track workout progress (`WorkoutPlan`) looks as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `totalWorkoutDuration` function returns the total duration of the workout
    in seconds.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutPlan` has a reference to another class in the preceding definition,
    `ExercisePlan`. It tracks the exercise and the duration of the exercise in a workout,
    which is quite apparent once we look at the definition of `ExercisePlan`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let me save you some typing and tell you where to get the model classes, but
    before that, we need to decide where to add them. We are ready for our first feature.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: First feature module
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary feature of *7 Minute Workout* is to execute a predefined set of
    exercises. Hence we are going to create a feature module now and later add the
    feature implementation to this module. We call this module `workout-runner`. Let's
    initialize the feature with Angular CLI's scaffolding capabilities.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command line, navigate to the `trainer/src/app` folder and run the
    following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Follow the console logs to know what files are generated. The command essentially:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Creates a new Angular `WorkoutRunnerModule` module inside a new `workout-runner`
    folder
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imports the newly created module into the main application module app (`app.module.ts`)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now have a new **feature module**.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Give every feature its own module.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Make special note of the conventions Angular CLI follows when scaffolding Angular
    artifacts. From the preceding example, the module name provided with the command
    line was `workout-runner`. While the generated folder and filenames use the same
    name, the class name for the generated module is `WorkoutRunnerModule` (pascal
    case with the `Module` suffix).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Open the newly generated module definition (`workout-runner.module.ts`) and
    look at the generated content. `WorkoutRunnerModule` imports `CommonModule`, a
    module with common Angular directives such as `ngIf` and `ngFor`, allowing us
    to use these common directives across any component/directive defined in `WorkoutRunnerModule`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Modules are Angular's way of organizing code. We will touch upon Angular modules
    shortly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `model.ts` file from [http://bit.ly/ng6be-2-1-model-ts](http://bit.ly/ng6be-2-1-model-ts) into
    the `workout-runner` folder. Shortly, we will see how these model classes are
    utilized.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Since we have started with a preconfigured Angular app, we just need to understand
    how the app starts.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: App bootstrapping
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The app bootstrapping process for *7 Minute Workout* can be carried out from
    the `src` folder. There is a `main.ts` file that bootstraps the application by
    calling the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The heavy lifting is done by the Angular CLI, which compiles the application,
    includes the script and CSS reference into `index.html`, and runs the application.
    We don't need to configure anything. These configurations are part of the default
    Angular CLI configuration (`.angular-cli.json`).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: We have created a new module and added some model classes to the `module` folder.
    Before we go any further and start implementing the feature, let's talk a bit
    about **Angular modules**.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新模块，并将一些模型类添加到`module`文件夹中。在进一步实现该功能并开始之前，让我们稍微谈一下**Angular 模块**。
- en: Exploring Angular modules
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Angular 模块
- en: As the *7 Minute Workout* app grows and we add new components/directives/pipes/other
    artifacts to it, a need arises to organize these items. Each of these items needs
    to be part of an Angular module.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 *7 分钟锻炼* 应用程序的增长，我们向其中添加新的组件/指令/管道/其他构件，需要组织这些项目。其中的每一项都需要成为 Angular 模块的一部分。
- en: A naïve approach would be to declare everything in our app's root module (`AppModule`),
    as we did with `WorkoutRunnerComponent`, but this defeats the whole purpose of
    Angular modules.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个天真的方法是在我们应用的根模块（`AppModule`）中声明所有内容，就像我们对`WorkoutRunnerComponent`所做的那样，但这背离了
    Angular 模块的整体目的。
- en: To understand why a single-module approach is never a good idea, let's explore
    Angular modules.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解为什么单一模块方法永远不是一个好主意，请探索 Angular 模块。
- en: Comprehending Angular modules
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Angular 模块
- en: In Angular, **modules** are a way to organize code into chunks that belong together
    and work as a cohesive unit. Modules are Angular's way of grouping and organizing
    code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，**模块**是一种将代码组织成属于一起并作为一个统一单元工作的方式。模块是 Angular 分组和组织代码的方式。
- en: 'An Angular module primarily defines:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 模块主要定义：
- en: The components/directives/pipes it owns
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它拥有的组件/指令/管道
- en: The components/directives/pipes it makes public for other modules to consume
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它向其他模块公开的组件/指令/管道
- en: Other modules that it depends on
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其依赖的其他模块
- en: Services that the module wants to make available application-wide
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块希望应用程序范围内提供的服务
- en: 'Any decent-sized Angular app will have modules interlinked with each other:
    some modules consuming artifacts from other, some providing artifacts to others,
    and some modules doing both.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 任何规模较大的 Angular 应用都将模块相互连接在一起：一些模块从其他模块消费构件，一些模块将构件提供给其他模块，一些模块都进行了两者。
- en: 'As a standard practice, module segregation is feature-based. One divides the
    app into features or subfeatures (for large features) and modules are created
    for each of the features. Even the framework adheres to this guideline as all
    of the framework constructs are divided across modules:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 作为标准做法，模块的分离是基于特性的。将应用程序划分成特性或子特性（对于大型特性），并为每个特性创建模块。即使框架也遵循此准则，因为所有框架构件都被分为各个模块：
- en: There is `CommonModule` that aggregates the standard framework constructs used
    in every browser-based Angular app
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有`CommonModule`，汇集了在每个基于浏览器的 Angular 应用中使用的标准框架构件
- en: There is `RouterModule` if we want to use the Angular routing framework
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果想要使用 Angular 路由框架，则有`RouterModule`。
- en: There is `HtppModule` if our app needs to communicate with the server over HTTP
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的应用需要通过 HTTP 与服务器通信，有`HtppModule`。
- en: Angular modules are created by applying the `@NgModule` decorator to a TypeScript
    class. The decorator definition exposes enough metadata, allowing Angular to load
    everything the module refers to.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 模块是通过将 `@NgModule` 装饰器应用于 TypeScript 类来创建的。装饰器定义公开了足够的元数据，允许 Angular
    加载模块引用的一切。
- en: 'The decorator has multiple attributes that allow us to define:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器具有多个属性，允许我们定义：
- en: External dependencies (using `imports`).
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部依赖项（使用`imports`）。
- en: Module artifacts (using `declarations`).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块构件（使用`declarations`）。
- en: Module exports (using `exports`).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块输出（使用`exports`）。
- en: The services defined inside the module that need to be registered globally (using
    `providers`).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块内定义的需要全局注册的服务（使用`providers`）。
- en: The main application view, called the **root component**, which hosts all other
    app views. Only the root module should set this using the `bootstrap` property.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主应用视图，称为**根组件**，承载所有其他应用视图。只有根模块才应该使用`bootstrap`属性进行设置。
- en: 'This diagram highlights the internals of a module and how they link to each
    other:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表突出显示了模块内部及其相互链接的内容：
- en: '![](img/9596f561-ea75-4d83-b999-7d9853ab892e.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9596f561-ea75-4d83-b999-7d9853ab892e.jpg)'
- en: Modules defined in the context of Angular (using the `@NgModule` decorator)
    are different from modules we import using the `import` statement in our TypeScript
    file. Modules imported through the `import` statement are **JavaScript modules**,
    which can be in different formats adhering to *CommonJS*, *AMD*, or *ES2015* specifications,
    whereas Angular modules are constructs used by Angular to segregate and organize
    its artifacts. Unless the context of the discussion is specifically a JavaScript
    module, any reference to module implies an Angular module. We can learn more about
    this here: [http://bit.ly/ng2be6-module-vs-ngmodule](http://bit.ly/ng2be6-module-vs-ngmodule).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'We hope one thing is clear from all this discussion: creating a single application-wide
    module is not the right use of Angular modules unless you are building something
    rudimentary.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: It's time to get into the thick of the action; let's build our first component.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Our first component - WorkoutRunnerComponent
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`WorkoutRunnerComponent`, is the central piece of our *7 Minute Workout* app
    and it will contain the logic to execute the workout.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'What we are going to do in the `WorkoutRunnerComponent` implementation is as
    follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Start the workout
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show the workout in progress and show the progress indicator
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the time elapses for an exercise, show the next exercise
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process until all the exercises are over
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are ready to create (or scaffold) our component.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command line, navigate to the `src/app` folder and execute the following
    `ng` command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The generator generates a bunch of files (three) in the `workout-runner` folder
    and updates the module declaration in `WorkoutRunnerModule` to include the newly
    created `WorkoutRunnerComponent`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The `-is` flag is used to stop generation of a separate CSS file for the component.
    Since we are using global styles, we do not need component-specific styles.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Remember to run this command from the `src/app` folder and not from the `src/app/workout-runner`
    folder. If we run the preceding command from `src/app/workout-runner`, Angular
    CLI will create a new subfolder with the `workout-runner` component definition.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding `ng generate` command for component generates these three files:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '`<component-name>.component.html`: This is the component''s view HTML.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<component-name>.component.spec.ts`: Test specification file used in unit
    testing.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<component-name>.component.ts`: Main component file containing component implementation.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, we will encourage you to have a look at the generated code to understand
    what gets generated. The Angular CLI component generator saves us some keystrokes
    and once generated, the boilerplate code can evolve as desired.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: While we see only four decorator metadata properties (such as `templateUrl`),
    the component decorator supports some other useful properties too. Look at the
    Angular documentation for component to learn more about these properties and their
    application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: An observant reader might have noticed that the generated `selector` property
    value has a prefix `abe`; this is intentional. Since we are extending the HTML
    **domain-specific language** (**DSL**) to incorporate a new element, the prefix
    `abe` helps us demarcate HTML extensions that we have developed. So instead of
    using `<workout-runner></workout-runner>` in HTML we use `<abe-workout-runner></abe-workout-runner>`.
    The prefix value has been configured in `angular.json`, see the `prefix` property.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Always add a prefix to your component selector.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: We now have the `WorkoutRunnerComponent` boilerplate; let's start adding the
    implementation, starting with adding the model reference.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'In `workout-runner.component.ts`, import all the workout models:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we need to set up the workout data. Let''s do that by adding some code
    in the generated `ngOnInit` function and related class properties to the `WorkoutRunnerComponent`
    class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`ngOnInit` is a special function that Angular calls when a component is initialized.
    We will talk about `ngOnInit` shortly.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The `buildWorkout` on `WorkoutRunnerComponent` sets up the complete workout,
    as we will define shortly. We also initialize a `restExercise` variable to track
    even the rest periods as exercise (note that `restExercise` is an object of type
    `ExercisePlan`).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'The `buildWorkout` function is a lengthy function, so it''s better to copy
    the implementation from the workout runner''s implementation available in Git
    branch checkpoint2.1 ([http://bit.ly/ng6be-2-1-workout-runner-component-ts](http://bit.ly/ng6be-2-1-workout-runner-component-ts)).
    The `buildWorkout` code looks as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code builds the `WorkoutPlan` object and pushes the exercise data into
    the `exercises` array (an array of `ExercisePlan` objects), returning the newly
    built workout.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'The initialization is complete; now, it''s time to actually implement the *start*
    workout. Add a `start` function to the `WorkoutRunnerComponent` implementation,
    as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then declare the new variables used in the function at the top, with other
    variable declarations:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `workoutTimeRemaining` variable tracks the total time remaining for the
    workout, and `currentExerciseIndex` tracks the currently executing exercise index.
    The call to `startExercise` actually starts an exercise. This is how the code
    for `startExercise` looks:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We start by initializing `currentExercise` and `exerciseRunningDuration`. The
    `currentExercise` variable tracks the exercise in progress and `exerciseRunningDuration`
    tracks its duration. These two variables also need to be declared at the top:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We use the `setInterval` JavaScript function with a delay of one second (1,000
    milliseconds) to make progress. Inside the `setInterval` callback, `exerciseRunningDuration`
    is incremented with each passing second. The nested `clearInterval` call stops
    the timer once the exercise duration lapses.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript arrow functions
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The callback parameter passed to `setInterval` (`()=>{...}`) is a lambda function
    (or an arrow function in ES 2015). Lambda functions are short-form representations
    of anonymous functions, with added benefits. You can learn more about them at
    [http://bit.ly/ng2be-ts-arrow-functions](http://bit.ly/ng2be-ts-arrow-functions).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`setInterval`的回调参数（`()=>{...}`）是一个lambda函数（或者是ES2015中的箭头函数）。Lambda函数是匿名函数的简写表示，带有额外的好处。您可以在
    [http://bit.ly/ng2be-ts-arrow-functions](http://bit.ly/ng2be-ts-arrow-functions)
    了解更多关于它们的知识。
- en: 'The first cut of the component is almost complete, except it currently has
    a static view (UI) and hence we cannot verify the implementation. We can quickly
    rectify this situation by adding a rudimentary view definition. Open `workout-runner.component.ts`,
    comment out the `templateUrl` property, and add an inline template property (`template`)
    and set it to the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的第一次切割几乎完成了，但是它目前有一个静态视图（UI），因此我们无法验证实现。我们可以通过添加一个初步的视图定义迅速纠正这种情况。打开`workout-runner.component.ts`，注释掉`templateUrl`属性，添加一个内联模板属性（`template`）并将其设置为以下内容：
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Strings enclosed in backticks (`` ``) are a new addition to ES2015\. Also called
    template literals, such string literals can be multiline and allow expressions
    to be embedded inside (not to be confused with Angular expressions). Look at the
    MDN article at [http://bit.ly/template-literals](http://bit.ly/template-literals)
    for more details.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 用反引号（`` ``）括起来的字符串是ES2015的一个新加入的特性。也被称为模板字面量，这样的字符串字面量可以是多行的，并且允许在其中嵌入表达式（不要与Angular表达式混淆）。在MDN的文章
    [http://bit.ly/template-literals](http://bit.ly/template-literals) 中查看更多细节。
- en: 'Inline versus external view templateThe preceding `template` property is an
    example of **inline component template**. This allows the component developer
    to specify the component template inline instead of using a separate HTML file.
    The inline template approach generally works for components with a trivial view.
    Inline templates have a disadvantage: formatting HTML becomes difficult and IDE
    support is very limited as the content is treated as a string literal. When we
    externalize HTML, we can develop a template as a normal HTML document. We recommend
    you use an **external template file** (specified using `templateUrl`) for elaborate
    views. Angular CLI by default generates an external template reference, but we
    can affect this behavior by passing the `--inline-template` flag to the `ng` component
    generation command, such as `--inline-template true`.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 内联与外部视图模板上面的`template`属性是**内联组件模板**的一个例子。这允许组件开发人员内联指定组件模板，而不是使用单独的HTML文件。内联模板方法通常适用于视图较为简单的组件。内联模板有一个缺点：HTML格式化变得困难，而且IDE支持非常有限，因为内容被视为字符串字面量。当我们将HTML外部化时，我们可以开发一个模板作为一个普通的HTML文档。我们建议您为复杂的视图使用**外部模板文件**（通过`templateUrl`指定）。Angular
    CLI默认生成外部模板引用，但我们可以通过向`ng`组件生成命令传递`--inline-template`标志来影响此行为，例如 `--inline-template
    true`。
- en: 'The preceding template HTML will render the raw `ExercisePlan` object and the
    exercise time remaining. It has an interesting expression inside the first interpolation:
    `currentExercise | json`. The `currentExercise` property is defined in `WorkoutRunnerComponent`,
    but what about the `|` symbol and what follows it (`json`)? In the Angular world,
    it is called a **pipe**. The sole purpose of a pipe is to transform/format template
    data.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模板HTML将呈现原始的`ExercisePlan`对象以及剩余的练习时间。在第一个插值内有一个有趣的表达式：`currentExercise |
    json`。`currentExercise`属性在`WorkoutRunnerComponent`中定义，但是`|`符号及其后的内容（`json`）是什么？在Angular世界中，这被称为一个**管道**。管道的唯一目的是转换/格式化模板数据。
- en: The `json` pipe here does JSON data formatting. You will learn more about pipes
    later in this chapter, but to get a general sense of what the `json` pipe does,
    we can remove the `json` pipe plus the `|` symbol and render the template; we
    are going to do this next.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的`json`管道是对JSON数据进行格式化。您将在本章后面学到更多关于管道的知识，但为了大致了解`json`管道的作用，我们可以移除`json`管道和
    `|` 符号，然后呈现模板；我们将在下一步中执行此操作。
- en: 'To render the new `WorkoutRunnerComponent` implementation, it has to be added
    to the root component''s view. Modify `src/components/app/app.component.html`
    and replace the `h3` tag with the following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要呈现新的`WorkoutRunnerComponent`实现，它必须被添加到根组件的视图中。修改`src/components/app/app.component.html`，使用以下代码替换`h3`标签：
- en: '[PRE19]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While the implementation may look complete, there is a crucial piece missing.
    Nowhere in the code do we actually start the workout. The workout should start
    as soon as we load the page.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实现看起来可能已经完成，但是还缺少一个关键的部分。代码中实际上并没有启动练习。练习应该在页面加载时立即开始。
- en: Component lifecycle hooks are going to rescue us!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Component lifecycle hooks
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The life of an Angular component is eventful. Components get created, change
    state during their lifetime, and finally, they are destroyed. Angular provides
    some **lifecycle hooks**/**functions** that the framework invokes (on the component)
    when such an event occurs. Consider these examples:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: When a component is initialized, Angular invokes `ngOnInit`
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a component's data-bound properties change, Angular invokes `ngOnChanges`
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a component is destroyed, Angular invokes `ngOnDestroy`
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As developers, we can tap into these key moments and perform some custom logic
    inside the respective component.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The hook we are going to utilize here is `ngOnInit`. The `ngOnInit` function
    gets fired the first time the component's data-bound properties are initialized,
    but before the view initialization starts.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: While `ngOnInit` and the class constructor seem to look similar, they have a
    different purpose. *A constructor* is a language feature and it is used to initialize
    class members. `ngOnInit`, on the other hand, is used to do some initialization
    stuff once the component is ready. Avoid use of a constructor for anything other
    than member initialization.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `ngOnInit` function to the `WorkoutRunnerComponent` class with a
    call to start the workout:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Angular CLI as part of component scaffolding already generates the signature
    for `ngOnInit`. The `ngOnInit` function is declared on the `OnInit` interface,
    which is part of the core Angular framework. We can confirm this by looking at
    the import section of `WorkoutRunnerComponent`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are a number of other lifecycle hooks, including `ngOnDestroy`, `ngOnChanges`,
    and `ngAfterViewInit`, that components support, but we are not going to dwell
    on any of them here. Look at the developer guide ([https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks))
    on lifecycle hooks to learn more about other such hooks.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the interface (`OnInit` in the preceding example) is optional.
    These lifecycle hooks work as long as the function name matches. We still recommend
    you use interfaces to clearly communicate the intent.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to run our app! Open the command line, navigate to the `trainer` folder,
    and type this line:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code compiles, but no UI is rendered. What is failing us? Let's look at
    the browser console for errors.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the browser''s dev tools (common keyboard shortcut `F12`) and look at
    the console tab for errors. There is a template parsing error. Angular is not
    able to locate the `abe-workout-runner` component. Let''s do some sanity checks
    to verify our setup:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutRunnerComponent` implementation complete - *check*'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component declared in `WorkoutRunnerModule`- *check*
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WorkoutRunnerModule` imported into `AppModule` - *check*'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Still, the `AppComponent` template cannot locate the `WorkoutRunnerComponent`.
    Is it because `WorkoutRunnerComponent` and `AppComponent` are in different modules?
    Indeed, that is the problem! While `WorkoutRunnerModule` has been imported into `AppModule`, `WorkoutRunnerModule`
    still does not export the new `WorkoutRunnerComponent` that will allow `AppComponent`
    to use it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Remember, adding a component/directive/pipe to the `declaration` section of
    a module makes them available inside the module. It's only after we export the
    component/directive/pipe that it becomes available to be used across modules.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s export `WorkoutRunnerComponent` by updating the export array of the `WorkoutRunnerModule`
    declaration to the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This time, we should see the following output:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e765f48-c0a6-43ce-ab18-b6f4a5d3a612.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: Always export artifacts defined inside an Angular module if you want them to
    be used across other modules.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The model data updates with every passing second! Now you'll understand why
    interpolations (`{{ }}`) are a great debugging tool.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: This will also be a good time to try rendering `currentExercise` without the
    `json` pipe and see what gets rendered.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: We are not done yet! Wait long enough on the page and we realize that the timer
    stops after 30 seconds. The app does not load the next exercise data. Time to
    fix it!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the code inside the `setInterval` function:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `if` condition `if (this.exerciseRunningDuration >= this.currentExercise.duration)`
    is used to transition to the next exercise once the time duration of the current
    exercise lapses. We use `getNextExercise` to get the next exercise and call `startExercise`
    again to repeat the process. If no exercise is returned by the `getNextExercise`
    call, the workout is considered complete.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: During exercise transitioning, we increment `currentExerciseIndex` only if the
    next exercise is not a rest exercise. Remember that the original workout plan
    does not have a rest exercise. For the sake of consistency, we have created a
    rest exercise and are now swapping between rest and the standard exercises that
    are part of the workout plan. Therefore, `currentExerciseIndex` does not change
    when the next exercise is rest.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly add the `getNextExercise` function too. Add the function to
    the `WorkoutRunnerComponent` class:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `getNextExercise` function returns the next exercise that needs to be performed.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Note that the returned object for `getNextExercise` is an `ExercisePlan` object
    that internally contains the exercise details and the duration for which the exercise
    runs.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The implementation is quite self-explanatory. If the current exercise is rest,
    take the next exercise from the `workoutPlan.exercises` array (based on `currentExerciseIndex`);
    otherwise, the next exercise is rest, given that we are not on the last exercise
    (the `else if` condition check).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are ready to test our implementation. The exercises should flip
    after every 10 or 30 seconds. Great!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: The current build setup automatically compiles any changes made to the script
    files when the files are saved; it also refreshes the browser after these changes.
    But just in case the UI does not update or things do not work as expected, refresh
    the browser window. If you are having a problem with running the code, look at
    the Git branch `checkpoint2.1` for a working version of what we have done thus
    far. Or if you are not using Git, download the snapshot of Checkpoint 2.1 (a ZIP
    file) from [http://bit.ly/ng6be-checkpoint2-1](http://bit.ly/ng6be-checkpoint2-1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: We have done enough work on the component for now, let's build the view.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Building the 7 Minute Workout view
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the hard work has already been done while defining the model and implementing
    the component. Now, we just need to skin the HTML using the super-awesome data
    binding capabilities of Angular. It's going to be simple, sweet, and elegant!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'For the *7 Minute Workout* view, we need to show the exercise name, the exercise
    image, a progress indicator, and the time remaining. Replace the local content
    of the `workout-runner.component.html` file with the content of the file from
    the Git branch `checkpoint2.2`, (or download it from [http://bit.ly/ng6be-2-2-workout-runner-component-html](http://bit.ly/ng6be-2-2-workout-runner-component-html)).
    The view HTML looks as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`WorkoutRunnerComponent` currently uses an inline template; instead, we need
    to revert back to using an external template. Update the `workout-runner.component.ts`
    file and get rid of the `template` property, then uncomment `templateUrl`, which
    we commented out earlier.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we understand the Angular pieces in the view, let''s just run the app
    again. Save the changes in `workout-runner.component.html` and if everything went
    fine, we will see the workout app in its full glory:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9734dbc5-314b-4653-b332-aea8bcd586e5.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: The basic app is now up and running. The exercise image and title show up, the
    progress indicator shows the progress, and exercise transitioning occurs when
    the exercise time lapses. This surely feels great!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.2`
    for a working version of what we have done thus far. You can also download the
    snapshot of `checkpoint2.2` (a ZIP file) from this GitHub location: [http://bit.ly/ng6be-checkpoint-2-2](http://bit.ly/ng6be-checkpoint-2-2)
    . Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the view HTML, other than some Bootstrap styles, there are some
    interesting Angular pieces that need our attention. Before we dwell on these view
    constructs in detail, let''s break down these elements and provide a quick summary:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '`<h1 ...>{{currentExercise.exercise.title}}</h1>`: Uses **interpolation**'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<img ... [src]="''/assets/images/'' + currentExercise.exercise.image" .../>`:
    Uses **property binding** to bind the `src` property of the image to the component
    model property `currentExercise.exercise.image`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<div ... [attr.aria-valuenow]="exerciseRunningDuration" ... >`: Uses **attribute
    binding** to bind the aria attribute on *div* to `exerciseRunningDuration`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`< div ... [ngStyle]="{''width'':(exerciseRunningDuration/currentExercise.duration)
    * 100 + ''%''}">`: Uses a **directive** `ngStyle` to bind the `style` property
    on the progress-bar `div` to an expression that evaluates the exercise progress'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phew! There is a lot of binding involved. Let's dig deeper into the binding
    infrastructure.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: The Angular binding infrastructure
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modern JavaScript frameworks today come with strong model-view binding
    support, and Angular is no different. The primary aim of any binding infrastructure
    is to reduce the boilerplate code that a developer needs to write to keep the
    model and view in sync. A robust binding infrastructure is always declarative
    and terse.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular binding infrastructure allows us to transform template (raw) HTML
    into a live view that is bound to model data. Based on the binding constructs
    used, data can flow and be synced in both directions: from model to view and view
    to model.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: The link between the component's model and its view is established using the
    `template` or `templateUrl` property of the `@Component` decorator. With the exception
    of the `script` tag, almost any piece of HTML can act as a template for the Angular
    binding infrastructure.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: To make this binding magic work, Angular needs to take the view template, compile
    it, link it to the model data, and keep it in sync with model updates without
    the need for any custom boilerplate synchronization code.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the data flow direction, these bindings can be of three types:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '**One-way binding from model to view**: In model-to-view binding, changes to
    the model are kept in sync with the view. Interpolations, property, attribute,
    class, and style bindings fall in this category.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One-way binding from view to model**: In this category, view changes flow
    towards the model. Event bindings fall in this category.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two-way/bidirectional binding**: Two-way binding, as the name suggests, keeps
    the view and model in sync. There is a special binding construct used for two-way
    binding, `ngModel`, and some standard HTML data entry elements such as `input`
    and `select` support two-way binding.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s understand how to utilize the binding capabilities of Angular to support
    view templatization. Angular provides these binding constructs:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Interpolations
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property binding
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attribute binding
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class binding
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Style binding
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event binding
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a good time to learn about all these binding constructs. **Interpolation**
    is the first one.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Interpolations
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Interpolations** are quite simple. The expression (commonly known as a **template
    expression**) inside the interpolation symbols (`{{ }}`) is evaluated in the context
    of the model (or the component class members), and the outcome of the evaluation
    (string) is embedded in HTML. A handy framework construct to display a component''s
    data/properties. We render the exercise title and the exercise time remaining
    using interpolation:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Remember that interpolations synchronize model changes with the view. Interpolation
    is one way of binding from a model to a view.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: View bindings in Angular are always evaluated in the context of the component's
    scope.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Interpolations, in fact, are a special case of property binding, which allows
    us to bind any HTML element/component properties to a model. We will shortly discuss
    how an interpolation can be written using property binding syntax. Consider interpolation
    as syntactical sugar over property binding.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Property binding
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Property bindings allow us to bind native HTML/component properties to the component's
    model and keep them in sync (from model->view). Let's look at property binding
    from a different context.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this view excerpt from the 7 Minute Workout''s component view (`workout-runner.component.html`):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It seems that we are setting the `src` attribute of `img` to an expression that
    gets evaluated at runtime. But are we really binding to an attribute? Or is this
    a property? Are properties and attributes different?
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: In Angular realms, while the preceding syntax looks like it is setting an HTML
    element's attribute, it is, in fact, doing **property binding**. Moreover, since
    many of us are not aware of the difference between an HTML element's properties
    and its attributes, this statement is very confusing. Therefore, before we look
    at how property bindings work, let's try to grasp the difference between an element's
    property and its attribute.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Property versus attribute
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take any DOM element API and you will find attributes, properties, functions,
    and events. While events and functions are self-explanatory, it is difficult to
    understand the difference between properties and attributes. In daily use, we
    use these words interchangeably, which does not help much either. Take, for example,
    this line of code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When the browser creates a DOM element (`HTMLInputElement` to be precise) for
    this input textbox, it uses the `value` attribute on `input` to set the initial
    state of the  `value` property of `input` to `Awesome Angular`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: After this initialization, any changes to the `value` property of `input` do
    not reflect on the `value` attribute; the attribute always has `Awesome Angular`
    (unless set explicitly again). This can be confirmed by querying the `input` state.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we change the `input` data to `Angular rocks!` and query the `input`
    element state:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `value` property always returns the current input content, which is `Angular
    rocks!`. Whereas this DOM API function:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Returns the `value` attribute, and is always the `Awesome Angular` that was
    set initially.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: The primary role of an element attribute is to initialize the state of the element
    when the corresponding DOM object is created.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of other nuances that add to this confusion. These include
    the following:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Attribute and property synchronization is not consistent across properties.
    As we saw in the preceding example, changes to the `value` property on `input`
    do not affect the `value` attribute, but this is not true for all property-value
    pairs. The `src` property of an image element is a prime example of this; changes
    to property or attribute values are always kept in sync.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's surprising to learn that the mapping between attributes and properties
    is also not one-to-one. There are a number of properties that do not have any
    backing attribute (such as `innerHTML`), and there are also attributes that do
    not have a corresponding property defined on the DOM (such as `colspan`).
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Attribute and property mapping adds to this confusion too, as they do not follow
    a consistent pattern. An excellent example of this is available in the Angular
    developer''s guide, which we are going to reproduce here verbatim:'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `disabled` attribute is another peculiar example. A button's `disabled`
    property is `false` by default so the button is enabled. When we add the disabled
    attribute, its presence alone initializes the button's `disabled` property to
    `true` so the button is disabled. Adding and removing the disabled attribute disables
    and enables the button. The value of the attribute is irrelevant, which is why
    we cannot enable a button by writing `<button disabled="false">Still Disabled</button>`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this discussion is to make sure that we understand the difference
    between the properties and attributes of a DOM element. This new mental model
    will help us as we continue to explore the framework's property and attribute
    binding capabilities. Let's get back to our discussion on property binding.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Property binding continued...
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we understand the difference between a property and an attribute,
    let''s look at the binding example again:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `[propertName]` square bracket syntax is used to bind the `img.src` property
    to an Angular expression.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax for property binding looks as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the case of property binding, the `target` is a property on the DOM element
    or component. With property binding, we can literally bind to any property on
    the element's DOM. The `src` property on the `img` element is what we use; this
    binding works for any HTML element and every property on it.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Expression target can also be an event, as we will see shortly when we explore
    event binding.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Binding source and targetIt is important to understand the difference between
    source and target in an Angular binding. The property appearing inside `[]` is
    a target, sometimes called **binding target**. The target is the consumer of the
    data and always refers to a property on the component/element. The **source**
    expression constitutes the data source that provides data to the target.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, the expression is evaluated in the context of the component's/element's
    property (the `WorkoutRunnerComponent.currentExercise.exercise.image` property
    in the preceding case).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Always remember to add square brackets `[]` around the target. If we don't,
    Angular treats the expression as a string constant and the target is simply assigned
    the string value.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Property binding, event binding, and attribute binding do not use the interpolation
    symbol. The following is invalid: `[src]="{{''/static/images/'' + currentExercise.exercise.image}}".`'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: If you have worked on AngularJS, property binding together with event binding
    allows Angular to get rid of a number of directives, such as `ng-disable`, `ng-src`,
    `ng-key*`, `ng-mouse*`, and a few others.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'From a data binding perspective, Angular treats components in the same way
    as it treats native elements. Hence, property binding works on component properties
    too! Components can define **input** and **output properties** that can be bound
    to the view, such as this:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This hypothetical snippet binds the `exerciseRestDuration` property on the `WorkoutRunnerComponent`
    class to the `restDuration` property defined on the container component (parent),
    allowing us to pass the rest duration as a parameter to the `WorkoutRunnerComponent`.
    As we enhance our app and develop new components, you will learn how to define
    custom properties and events on a component.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'We can enable property binding using the `bind-` syntax, which is a canonical
    form of property binding. This implies that `[src]="''/assets/images/'' + currentExercise.exercise.image"` is
    equivalent to the following: `bind-src="img/'' + currentExercise.exercise.image"`.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Property binding, like interpolation, is unidirectional, from the component/element
    source to the view. Changes to the model data are kept in sync with the view.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: The template view that we just created has only one property binding (on `[src]`).
    The other bindings with square brackets aren't property bindings. We will cover
    them shortly.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation syntactic sugar over property binding
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We concluded the section on interpolations by describing interpolation as syntactical
    sugar over property binding. The intent was to highlight how both can be used
    interchangeably. The interpolation syntax is terser than property binding and
    hence is very useful. This is how Angular interprets an interpolation:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Angular translates the interpolation in the first statement into the `textContent`
    property binding (second statement).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'Interpolation can be used in more places than you can imagine. The following
    example contrasts the same binding using interpolation and property binding:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: While property binding (and interpolations) makes it easy for us to bind any
    expression to the target property, we should be careful with the expression we
    use. Angular's change detection system will evaluate your expression binding multiple
    times during the life cycle of the application, as long as our component is alive.
    Therefore, while binding an expression to a property target, keep these two guidelines
    in mind.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Quick expression evaluation
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A property binding expression should evaluate quickly. Slow expression evaluation
    can kill your app''s performance. This happens when a function performing CPU
    intensive work is part of an expression. Consider this binding:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Angular will evaluate the preceding `doLotsOfWork()` expression every time it
    performs a change detection run. These change detection runs happen more often
    than we imagine and are based on some internal heuristics, so it becomes imperative
    that the expressions we use evaluate quickly.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Side effect-free binding expressions
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a function is used in a binding expression, it should be side effect-free.
    Consider yet another binding:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And the underlying function, `getContent`:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `getContent` call changes the state of the component by updating the `timesContentRequested`
    property every time it is called. If this property is used in views such as:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Angular throws errors such as:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The Angular framework works in two modes, dev and production. If we enable production
    mode in the application, the preceding error does not show up. Look at the framework
    documentation at [http://bit.ly/enableProdMode](http://bit.ly/enableProdMode)
    for more details.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that your expression used inside property binding should
    be side effect-free.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at something interesting, `[ngStyle]`, which looks like a property
    binding, but it's not. The target specified in `[]` is not a component/element
    property (`div` does not have an `ngStyle` property), it's a directive.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Two new concepts need to be introduced, **target selection** and **directives**.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Angular directives
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a framework, Angular tries to enhance the HTML **DSL** (short for **Domain-Specific
    Language**):'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Components are referenced in HTML using custom tags such as `<abe-workout-runner></abe-workout-runner>`
    (not part of standard HTML constructs). This highlights the first extension point.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of `[]` and `()` for property and event binding defines the second.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And then there are **directives**, the third extension point which are further
    classified into **attribute** and **structural directives**, and **components**
    (components are directive too!).
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While components come with their own view, attribute directives are there to
    enhance the appearance and/or behavior of existing elements/components.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Structural directives do not have their own view too; they change the DOM layout
    of the elements on which they are applied. We will dedicate a complete section
    later in the chapter to understanding these structural directives.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ngStyle` directive used in the `workout-runner` view is, in fact, an attribute
    directive:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `ngStyle` directive does not have its own view; instead, it allows us to
    set multiple styles (`width` in this case) on an HTML element using binding expressions.
    We will be covering a number of framework attribute directives later in this book.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Directive nomenclature
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Directives is an umbrella term used for component directives (also known as
    components), attribute directives, and structural directives. Throughout the book,
    when we use the term directive, we will be referring to either an attribute directive
    or a structural directive depending on the context. Component directives are always
    referred to as components.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: With a basic understanding of the directive types that Angular has, we can comprehend
    the process of target selection for binding.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Target selection for binding
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The target specified in `[]` is not limited to a component/element property.
    While the property name is a common target, the Angular templating engine actually
    does heuristics to decide the target type. Angular first searches the registered
    known directives (attribute or structural) that have matching selectors before
    looking for a property that matches the target expression. Consider this view
    fragment:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The search for a target starts with a framework looking at all internal and
    custom directives with a matching selector (`ngStyle`). Since Angular already
    has an `NgStyle` directive, it becomes the target (the directive class name is
    `NgStyle`, whereas the selector is `ngStyle`). If Angular did not have a built-in
    `NgStyle` directive, the binding engine would have looked for a property called
    `ngStyle` on the underlying component.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: If nothing matches the target expression, an unknown directive error is thrown*.*
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on target selection. The next section is about
    attribute binding.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Attribute binding
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only reason attribute binding exists in Angular is that there are HTML attributes
    that do not have a backing DOM property. The `colspan` and `aria` attributes are
    some good examples of attributes without backing properties. The progress bar
    div in our view uses attribute binding.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: If attribute directives are still playing your head, I cannot blame you, it
    can become a bit confusing. Fundamentally, they are different. Attribute directives
    (such as `[ngStyle]`) change the appearance or behavior of DOM elements and as
    the name suggests are directives. There is no attribute or property named `ngStyle`
    on any HTML element. Attribute binding, on the other hand, is all about binding
    to HTML attributes that do not have backing for a DOM property.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'The *7 Minute Workout* uses attribute binding at two places, `[attr.aria-valuenow]`
    and `[attr.aria-valuemax]`. We may ask a question: can we use standard interpolation
    syntax to set an attribute? No, that does not work! Let''s try it: open `workout-runner.component.html`
    and replace the two aria attributes `attr.aria-valuenow` and `attr.aria-valuemax`
    enclosed in `[]` with this highlighted code:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Save the view and if the app is not running, run it. This error will pop up
    in the browser console:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Angular is trying to search for a property called `ariaValuenow` in the `div`
    that does not exist! Remember, interpolations are actually property bindings.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'We hope that this gets the point across: to bind to an HTML attribute, use
    attribute binding.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Angular binds to properties by default and not to attributes.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'To support attribute binding, Angular uses a prefix notation, `attr`, within
    `[]`. An attribute binding looks as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Revert to the original aria setup to make attribute binding work:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Remember that unless an explicit `attr.` prefix is attached, attribute binding
    does not work.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: While we have not used style and class-based binding in our workout view, these
    are some binding capabilities that can come in handy. Hence, they are worth exploring.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Style and class binding
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use **class binding** to set and remove a specific class based on the component
    state, as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This adds `class-name` when `expression` is `true` and removes it when it is
    `false`. A simple example can look as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Use style bindings to set inline styles based on the component state:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'While we have used the `ngStyle` directive for the workout view, we could have
    easily used style binding as well, as we are dealing with a single style. With
    style binding, the same `ngStyle` expression would become the following:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`width` is a style, and since it takes units too, we extend our target expression
    to include the `%` symbol.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that `style.` and `class.` are convenient bindings for setting a single
    class or style. For more flexibility, there are corresponding attribute directives:
    `ngClass` and `ngStyle`.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in the chapter, we formally introduced directives and their classifications.
    One of the directives types, attribute directives (again, don't confuse them with
    attribute binding, which we introduced in the preceding section) are the focus
    of our attention in the next section.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Attribute directives
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attribute directives are HTML extensions that change the look, feel or behavior
    of a component/element. As described in the section on Angular directives, these
    directives do not define their own view.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Other than `ngStyle` and `ngClass` directives, there are a few more attribute
    directives that are part of the core framework. `ngValue`, `ngModel`, `ngSelectOptions`,
    `ngControl`, and `ngFormControl` are some of the attribute directives that Angular
    provides.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Since *7 Minute Workout* uses the `ngStyle` directive, it would be wise to dwell
    more on this directive and its close associate `ngClass`.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: While the next section is dedicated to learning how to use the `ngClass` and
    `ngStyle` attribute directives, it is not until [Chapter 4](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml),
    *Angular Directives in Depth*, that we learn how to create our own attribute directives.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Styling HTML with ngClass and ngStyle
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular has two excellent directives that allow us to dynamically set styles
    on any element and toggle CSS classes. For the bootstrap progress bar, we use
    the `ngStyle` directive to dynamically set the element''s style, `width`, as the
    exercise progresses:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`ngStyle` allows us to bind one or more styles to a component''s properties
    at once. It takes an object as a parameter. Each property name on the object is
    the style name, and the value is the Angular expression bound to that property,
    such as the following example:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The styles can not only bind to component properties (`componentWidth` and `componentHeight`),
    but also be set to a constant value (`'larger'`). The expression parser also allows
    the use of the ternary operator (`?:`); check out `isRequired`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'If styles become too unwieldy in HTML, we also have the option of writing in
    our component a function that returns the object hash, and setting that as an
    expression:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Moreover, `getStyles` on the component looks as follows:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`ngClass` works on the same lines too, except that it is used to toggle one
    or multiple classes. For example, check out the following code:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `required` class is applied when `inputRequired` is `true` and is removed
    when it evaluates to `false`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Directives (custom or platform) like any other Angular artifact, always belong
    to a module. To use them across modules, the module needs to be imported. Wondering
    where `ngStyle` is defined? `ngStyle` is part of the core framework module, `CommonModule,`,
    and has been imported in the workout runner module definition (`workout-runner.module.ts`).
    `CommonModule` defines a number of handy directives that are used across Angular.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Well! That covers everything we had to learn about our newly developed view.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: And as described earlier, if you are having a problem with running the code,
    look at the Git branch `checkpoint2.2`. If not using Git, download the snapshot
    of `checkpoint2.2` (a ZIP file) from [http://bit.ly/ng2be-checkpoint2-2](http://bit.ly/ng2be-checkpoint2-2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Time to add some enhancements and learn a bit more about the framework!
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Learning more about an exercise
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For people who are doing this workout for the first time, it will be good to
    detail the steps involved in each exercise. We can also add references to some
    YouTube videos for each exercise to help the user understand the exercise better.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add the exercise description and instructions in the left panel
    and call it the **description panel**. We will also add references to YouTube
    videos in the right panel, which is the video player panel. To make things more
    modular and learn some new concepts, we are going to create independent components
    for each description panel and video panel.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: The model data for this is already available. The `description` and `procedure`
    properties in the `Exercise` class (see `model.ts`) provide the necessary details
    about the exercise. The `videos` array contains some related YouTube video IDs,
    which will be used to fetch these videos.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Adding descriptions and video panels
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Angular app is nothing but a hierarchy of components, similar to a tree
    structure. As of now, *7 Minute Workout* has two components, the root component,
    `AppComponent`, and its child, `WorkoutRunnerComponent`, in line with the HTML
    component layout, which now looks as follows:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Run the app and do a view source to verify this hierarchy. As we all more components
    to implement new features in the application this component tree grows and branches
    out.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add two subcomponents to `WorkoutRunnerComponent`, one each
    to support the exercise description and exercise videos. While we could have added
    some HTML directly to the `WorkoutRunnerComponent` view, what we are hoping here
    is to learn a bit more about cross-component communication. Let's start with adding
    the description panel on the left and understand how a component can accept inputs.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Component with inputs
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Navigate to the `workour-runner` folder and generate a boilerplate exercise
    description component:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To the generated `exercise-description.component.ts` file, add the highlighted
    code:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `@Input` decorator signifies that the component property is available for
    data binding. Before we dig into the `@Input` decorator, let's complete the view
    and integrate it with `WorkoutRunnerComponent`.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the view definition for exercise description, `exercise-description.component.html`,
    from the Git branch `checkpoint2.3`, in the `workout-runner/exercise-description` folder.
    Look at the highlighted HTML for the exercise description:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding interpolation references the input properties of `ExerciseDescriptionComponent`:
    `description` and `steps`.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: The component definition is complete. Now, we just need to reference `ExerciseDescriptionComponent`
    in `WorkoutRunnerComponent` and provide values for `description` and `steps` for
    the `ExerciseDescriptionComponent` view to render correctly.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout-runner.component.html` and update the HTML fragments as highlighted
    in the following code. Add a new div called `description-panel` before the `exercise-pane`
    div and adjust some styles on the `exercise-pane` div, as follows:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If the app is running, the description panel should show up on the left with
    the relevant exercise details.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutRunnerComponent` was able to use `ExerciseDescriptionComponent` because
    it has been declared on `WorkoutRunnerModule` (see the `workout-runner.module.ts` declaration
    property). The Angular CLI component generator does this work for us.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Look back at the `abe-exercise-description` declaration in the preceding view.
    We are referring to the `description` and `steps` properties in the same manner
    as we did with the HTML element properties earlier in the chapter (`<img [src]='expression'
    ...`). Simple, intuitive, and very elegant!
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: The Angular data binding infrastructure makes sure that whenever the `currentExercise.exercise.description`
    and `currentExercise.exercise.procedure` properties on `WorkoutRunnerComponent`
    change, the bound properties on `ExerciseDescriptionComponent`, `description`,
    and `steps` are also updated.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Input` decoration can take a property alias as a parameter, which means
    the following: consider a property declaration such as: `@Input("myAwesomeProperty")
    myProperty:string`. It can be referenced in the view as follows: `<my-component
    [myAwesomeProperty]="expression"....`'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'The power of the Angular binding infrastructure allows us to use any component
    property as a bindable property by attaching the `@Input` decorator (and `@Output`
    too) to it. We are not limited to basic data types such as `string`, `number`,
    and `boolean`; there can be complex objects too, which we will see next as we
    add the video player:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: The `@Input` decorator can be applied to complex objects too.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a new component in the `workout-runner` directory for the video player:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Update the generated boilerplate code by copying implementation from `video-player.component.ts`
    and `video-player.component.html` available in the Git branch `checkpoint2.3`
    in the `trainer/src/components/workout-runner/video-player` folder (GitHub location:
    [http://bit.ly/ng6be-2-3-video-player](http://bit.ly/ng6be-2-3-video-player)).'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the implementation for the video player. Open `video-player.component.ts`
    and check out the `VideoPlayerComponent` class:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `videos` input property here takes an array of strings (YouTube video codes).
    While we take the `videos` array as input, we do not use this array directly in
    video player view; instead, we transform the input array into a new array of `safeVideoUrls`
    and bind it. This can be confirmed by looking at the view implementation:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The view also uses a new Angular directive called `ngFor` to bind to the `safeVideoUrls`
    array. The `ngFor` directive belongs to a class of directives called **structural
    directives**. The directive's job is to take an HTML fragment and regenerate it
    based on the number of elements in the bound collection.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: If you are confused about how the `ngFor` directive works with `safeVideoUrls`,
    and why we need to generate `safeVideoUrls` instead of using the `videos` input
    array, wait for a while as we are shortly going to address these queries. But,
    let's first complete the integration of `VideoPlayerComponent` with `WorkoutRunnerComponent`
    to see the final outcome.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `WorkoutRunnerComponent` view by adding the component declaration
    after the `exercise-pane` div:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `VideoPlayerComponent`'s `videos` property binds to the exercise's videos
    collection.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: Start/refresh the app and the video thumbnails should show up on the right.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.3`
    for a working version of what we have done thus far. You can also download the
    snapshot of `checkpoint2.3` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-2-3](http://bit.ly/ng6be-checkpoint-2-3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to go back and look at the parts of the `VideoPlayerComponent`
    implementation. We specifically need to understand:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: How the `ngFor` directive works
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why there is a need to transform the input `videos` array into `safeVideoUrls`
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The significance of the Angular component life cycle event `OnChanges` (used
    in the video player)
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To start with, it''s time to formally introduce `ngFor` and the class of directives
    it belongs to: structural directives.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Structural directives
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third categorization of directives, structural directives, work on the components/elements
    to manipulate their layout.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular documentation describes structural directives in a succinct manner:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '"Instead of defining and controlling a view like a Component Directive, or
    modifying the appearance and behavior of an element like an Attribute Directive,
    the Structural Directive manipulates the layout by adding and removing entire
    element sub-trees."'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: Since we have already touched upon component directives (such as `workout-runner`
    and `exercise-description`) and attribute directives (such as `ngClass` and `ngStyle`),
    we can very well contrast their behaviors with structural directives.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: The `ngFor` directive belongs to this class. We can easily identify such directives
    by the `*` prefix. Other than `ngFor`, Angular comes with some other structural
    directives such as `ngIf` and `ngSwitch`.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: The ever-so-useful NgForOf
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every templating language has constructs that allow the templating engine to
    generate HTML (by repetition). Angular has `NgForOf`. The `NgForOf` directive
    is a super useful directive used to duplicate a piece of an HTML fragment n number
    of times. Let''s again look at how we have used `NgForOf` in the video player:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The directive selector for `NgForOf` is `{selector: ''[ngFor][ngForOf]''}`,
    so we can use either `ngFor` or `ngForOf` in the view template. We also at times
    refer to this directive as `ngFor`.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code repeats the `div` fragment for each exercise video (using
    the `safeVideoUrls` array). The `let video of safeVideoUrls` string expression
    is interpreted as follows: take each video in the `safeVideoUrls` array and assign
    it to a template input variable, `video`.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: This input variable can now be referenced inside the `ngFor` template HTML,
    as we do when we set the `src` property binding.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the string assigned to the `ngFor` directive is not a typical
    Angular expression. Instead, it's a **microsyntax**—a micro language, which the
    Angular engine can parse.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about microsyntax in Angular's developer guide: [http://bit.ly/ng6be-micro-syntax](http://bit.ly/ng6be-micro-syntax).
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: This microsyntax exposes a number of iteration context properties that we can
    assign to template input variables and use them inside the `ngFor` HTML block.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: 'One such example is `index`. `index` increases from 0 to the length of the
    array for each iteration, something similar to a `for` loop, in any programming
    language. The following example shows how to capture it:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Other than `index`, there are some more iteration context variables; these
    include `first`, `last`, `even`, and `odd`. This context data allows us to do
    some nifty stuff. Consider this example:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It applies a `special` class to the first video `div`.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NgForOf` directive can be applied to HTML elements as well as our custom
    components. This is a valid use of `NgForOf`:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Always remember to add an asterisk (`*`) before `ngFor` (and other structural
    directives). `*` has a significance.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Asterisk (*) in structural directives
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `*` prefix is a terser format to represent a structural directive. Take,
    for example, the usage of `ngFor` by the video player. The `ngFor` template:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Actually expands to the following:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `ng-template` tag is an Angular element that has a declaration for `ngFor`,
    a template input variable (`video`), and a property (`ngForOf`) that points to
    the `safeVideoUrls` array. Both the preceding declarations are a valid usage of
    `ngFor`.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: Not sure about you, but I prefer the terser first format for `ngFor`!
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: NgForOf performance
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since `NgForOf` generates HTML based on collection elements, it is notorious
    for causing performance issues. But we cannot blame the directive. It does what
    it is supposed to do: iterate and generate elements! If the underlying collection
    is huge, UI rendering can take a performance hit, especially if the collection
    changes too often. The cost of continuously destroying and creating elements in
    response to a changing collection can quickly become prohibitive.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: One of the performance tweaks for `NgForOf` allows us to alter the behavior
    of `ngForOf` when it comes to creating and destroying DOM elements (when the underlying
    collection elements are added or removed).
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a scenario where we frequently get an array of objects from the server
    and bind it to the view using `NgForOf`. The default behavior of `NgForOf` is
    to regenerate the DOM every time we refresh the list (since Angular does a standard
    object equality check). However, as developers, we may very well know not much
    has changed. Some new objects may have been added, some removed, and maybe some
    modified. But Angular just regenerates the complete DOM.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: 'To alleviate this situation, Angular allows us to specify a custom **tracking
    function**, which lets Angular know when two objects being compared are equal.
    Have a look at the following function:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: A function such as this can be used in the `NgForOf` template to tell Angular
    to compare the *user* object based on its `id` property instead of doing a reference
    equality check.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we then use the preceding function in the `NgForOf` template:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`NgForOf` will now avoid recreating DOM for users with IDs already rendered.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Remember, Angular may still update the existing DOM elements if the bound properties
    of a user have changed.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: That's enough on the `ngFor` directive; let's move ahead.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: We still need to understand the role of the `safeVideoUrls` and the `OnChange`
    life cycle events in the `VideoPlayerComponent` implementation. Let's tackle the
    former first and understand the need for `safeVideoUrls`.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: Angular security
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to understand why we need to bind to `safeVideoUrls` instead
    of the `videos` input property is by trying the `videos` array out. Replace the
    existing `ngFor` fragment HTML with the following:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'And look at the browser''s console log (a page refresh may be required). There
    are a bunch of errors thrown by the framework, such as:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '`Error: unsafe value used in a resource URL context (see http://g.co/ng/security#xss)`'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: No prize for guessing what is happening! Angular is trying to safeguard our
    application against a **Cross-Site Scripting** (**XSS**) attack.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Such an attack enables the attacker to inject malicious code into our web pages.
    Once injected, the malicious code can read data from the current site context.
    This allows it to steal confidential data and also impersonate the logged-in user,
    hence gaining access to privileged resources.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: Angular has been designed to block these attacks by sanitizing any external
    code/script that is injected into an Angular view. Remember, content can be injected
    into a view through a number of mechanisms, including property/attribute/style
    bindings or interpolation.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example of binding HTML markup through a component model to the `innerHTML`
    property of an HTML element (property binding):'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: While the HTML content is emitted, any unsafe content (such as a *script*) if
    present is stripped.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: But what about Iframes? In our preceding example, Angular is blocking property
    binding to Iframe's `src` property too. This is a warning against third-party
    content being embedded in our own site using Iframe. Angular prevents this too.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'All in all, the framework defines four security contexts around content sanitization.
    These include:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '**HTML content sanitization**, when HTML content is bound using the `innerHTML`
    property'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Style sanitization**, when binding CSS into the `style` property'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**URL sanitization**, when URLs are used with tags such as `anchor` and `img`'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Resource sanitization**, when using `Iframes` or `script` tags; in this case,
    content cannot be sanitized and hence it is blocked by default'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Angular is trying its best to keep us out of danger. But at times, we know that
    the content is safe to render and hence want to circumvent the default sanitization
    behavior.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: Trusting safe content
  id: totrans-560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To let Angular know that the content being bound is safe, we use `DomSanitizer`
    and call the appropriate method based on the security contexts just described.
    The available functions are as follows:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustHtml`'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustScript`'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustStyle`'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustUrl`'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustResourceUrl`'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our video player implementation, we use `bypassSecurityTrustResourceUrl`;
    it converts the video URL into a trusted `SafeResourceUrl` object:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `map` method transforms the videos array into a collection of `SafeResourceUrl`
    objects and assigns it to `safeVideoUrls`.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: Each of the methods listed previously takes a string parameter. This is the
    content we want Angular to know is safe. The return object, which could be any
    of `SafeStyle`, `SafeHtml`, `SafeScript`, `SafeUrl`, or `SafeResourceUrl`, can
    then be bound to the view.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: A comprehensive treatment of this topic is available in the framework security
    guide available at [http://bit.ly/ng6be-security](http://bit.ly/ng6be-security).
    A highly recommended read!
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: The last question to answer is why do this in the `OnChanges` Angular life cycle
    event?
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: OnChange life cycle event
  id: totrans-573
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `OnChanges` life cycle event is triggered whenever the component's input(s)
    change. In the case of `VideoPlayerComponent`, it is the `videos` array input
    property that changes whenever a new exercise is loaded. We use this life cycle
    event to recreate the `safeVideoUrls` array and re-bind it to the view. Simple!
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: Video panel implementation is now complete. Let's add a few more minor enhancements
    and explore it a bit more in Angular.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: Formatting exercise steps with innerHTML binding
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the sore points in the current app is the formatting of the exercise
    steps. It's a bit difficult to read these steps.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps should either have a line break (`<br>`) or be formatted as an HTML
    `list` for easy readability. This seems to be a straightforward task, and we can
    just go ahead and change the data that is bound to the step interpolation, or
    write a pipe that can add some HTML formatting using the line delimiting convention
    (`.`). For a quick verification, let''s update the first exercise steps in `workout-runner.component.ts`
    by adding a break (`<br>`) after each line:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As the workout restarts, look at the first exercise steps. The output does
    not match our expectations, as shown here:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2dce051-39a3-4779-93c1-3b5695ab0e55.png)'
  id: totrans-581
  prefs: []
  type: TYPE_IMG
- en: The break tags were literally rendered in the browser. Angular did not render
    the interpolation as HTML; instead, it escaped the HTML characters, and we know
    why, security!
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: How to fix it? Easy! Replace the interpolation with the property binding to
    bind step data to the element's `innerHTML` property (in `exercise-description.html`),
    and you are done!
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Refresh the workout page to confirm.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: Preventing Cross-Site Scripting Security (XSS) issues
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: By using `innerHTML`, we instruct Angular to not escape HTML, but Angular still
    sanitizes the input HTML as described in the security section earlier. It removes
    things such as `<script>` tags and other JavaScript to safeguard against XSS attacks.
    If you want to dynamically inject styles/scripts into HTML, use the `DomSanitizer`
    to bypass this sanitization check.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Time for another enhancement! It's time to learn about Angular pipes.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the remaining workout duration using pipes
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It will be nice if we can tell the user the time left to complete the workout
    and not just the duration of the exercise in progress. We can add a countdown
    timer somewhere in the exercise pane to show the overall time remaining.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: The approach that we are going to take here is to define a component property
    called `workoutTimeRemaining`. This property will be initialized with the total
    time at the start of the workout and will reduce with every passing second until
    it reaches zero. Since `workoutTimeRemaining` is a numeric value, but we want
    to display a timer in the `hh:mm:ss` format, we need to make a conversion between
    the seconds data and the time format. **Angular pipes** are a great option for
    implementing such a feature.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: Angular pipes
  id: totrans-592
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary aim of a pipe is to format the data displayed in the view. **Pipes**
    allow us to package this content transformation logic (formatting) as a reusable
    element. The framework itself comes with multiple predefined pipes, such as `date`,
    `currency`, `lowercase`, `uppercase`, `slice`, and others.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we use a pipe with a view:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'An expression is followed by the pipe symbol (`|`), which is followed by the
    pipe name and then an optional parameter (`inputParam1`) separated by a colon
    (`:`). If the pipe takes multiple inputs, they can be placed one after another
    separated by a colon, such as the inbuilt `slice` pipe, which can slice an array
    or string:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The parameter passed to the pipe can be a constant or a component property,
    which implies we can use template expressions with pipe parameter. See the following
    example:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Here are some examples of the use of the `date` pipe, as described in the Angular
    `date` documentation. Assume that `dateObj` is initialized to *June 15,* 2015
    *21:43:11* and locale is *en-US*:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Some of the most commonly used pipes are the following:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '**date**: As we just saw, the date filter is used to format the date in a specific
    manner. This filter supports quite a number of formats and is locale-aware too.
    To know about the other formats supported by the date pipe, check out the framework
    documentation at [http://bit.ly/ng2-date](http://bit.ly/ng2-date).'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**uppercase** and **lowercase**: These two pipes, as the name suggests, change
    the case of the string input.'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**decimal** and **percent**: `decimal` and `percent` pipes are there to format
    decimal and percentage values based on the current browser locale.'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**currency**: This is used to format numeric values as a currency based on
    the current browser locale:'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '**json**: This is a handy pipe for debugging that can transform any input into
    a string using `JSON.stringify`. We made good use of it at the start of this chapter
    to render the `WorkoutPlan` object (see the Checkpoint 2.1 code).'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**slice:** This pipe allows us to split a list or a string value to create
    a smaller trimmed down list/string. We saw an example in the preceding code.'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are not going to cover the preceding pipes in detail. From a development
    perspective, as long as we know what pipes are there and what they are useful
    for, we can always refer to the platform documentation for exact usage instructions.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: Pipe chaining
  id: totrans-611
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A really powerful feature of pipes is that they can be chained, where the output
    from one pipe can serve as the input to another pipe. Consider this example:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The first pipe slices the first 20 characters of `fullName` and the second pipe
    transforms them to uppercase.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen what pipes are and how to use them, why not implement
    one for the *7 Minute Workout* app: a **seconds to time** pipe?'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a custom pipe - SecondsToTimePipe
  id: totrans-616
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SecondsToTimePipe`, as the name suggests, should convert a numeric value into
    the `hh:mm:ss` format.'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder `shared` in the `workout-runner` folder and from the shared
    folder invoke this CLI command to generate the pipe boilerplate:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `shared` folder has been created to add common components/directives/pipes
    that can be used in the `workout-runner` module. It is a convention we follow
    to organize shared code at different levels. In the future, we can create a shared
    folder at the app module level, which has artifacts shared globally. In fact,
    if the second to time pipe needs to be used across other application modules,
    it can also be moved into the app module.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the following `transform` function implementation into `seconds-to-time.pipe.ts`(the
    definition can also be downloaded from the Git branch `checkpoint.2.4` on the
    GitHub site at [http://bit.ly/nng6be-2-4-seconds-to-time-pipe-ts](http://bit.ly/nng6be-2-4-seconds-to-time-pipe-ts)):'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In an Angular pipe, the implementation logic goes into the `transform` function.
    Defined as part of the `PipeTransform` interface, the preceding `transform` function
    transforms the input seconds value into an *hh:mm:ss* string. The first parameter
    to the `transform` function is the pipe input. The subsequent parameters, if provided,
    are the arguments to the pipe, passed using a colon separator (`pipe:argument1:arugment2..`)
    from the view.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: For `SecondsToTimePipe`, while Angular CLI generates a boilerplate argument
    (`args?:any`), we do not make use of any pipe argument as the implementation does
    not require it.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: The pipe implementation is quite straightforward, as we convert seconds into
    hours, minutes, and seconds. Then, we concatenate the result into a string value
    and return the value. The addition of 0 on the left for each of the `hours`, `minutes`,
    and `seconds` variables is done to format the value with a leading 0 in case the
    calculated value for hours, minutes, or seconds is less than 10.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: 'The pipe that we just created is just a standard TypeScript class. It''s the
    Pipe decorator (`@Pipe`) that instructs Angular to treat this class as a pipe:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The pipe definition is complete, but to use the pipe in `WorkoutRunnerComponent`
    the pipe has to be declared on `WorkoutRunnerModule.` Angular CLI has already
    done this for us as part of the boilerplate generation (see the `declaration`
    section in `workout-runner.module.ts`).
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just need to add the pipe in the view. Update `workout-runner.component.html`
    by adding the highlighted fragment:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Surprisingly, the implementation is still not complete! There is one more step
    left. We have a pipe definition, and we have referenced it in the view, but `workoutTimeRemaining`
    needs to update with each passing second for `SecondsToTimePipe` to be effective.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already initialized `WorkoutRunnerComponent`''s `workoutTimeRemaining`
    property in the `start` function with the total workout time:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now the question is: how to update the `workoutTimeRemaining` variable with
    each passing second? Remember that we already have a `setInterval` set up that
    updates `exerciseRunningDuration`. While we can write another `setInterval` implementation
    for `workoutTimeRemaining`, it will be better if a single `setInterval` setup
    can take care of both the requirements.'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a function called `startExerciseTimeTracking` to `WorkoutRunnerComponent`;
    it looks as follows:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: As you can see, the primary purpose of the function is to track the exercise
    progress and flip the exercise once it is complete. However, it also tracks `workoutTimeRemaining`
    (it decrements this counter). The first `if` condition setup just makes sure that
    we clear the timer once all the exercises are done. The inner `if` conditions
    are used to keep `currentExerciseIndex` in sync with the running exercise.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: This function uses a numeric instance variable called `exerciseTrackingInterval`.
    Add it to the class declaration section. We are going to use this variable later
    to implement an exercise pausing behavior.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the complete `setInterval` setup from `startExercise` and replace it
    with a call to `this.startExerciseTimeTracking();`. We are all set to test our
    implementation. If required, refresh the browser and verify the implementation:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcfb02e4-245e-42b8-86a1-2dc661c1b3b8.png)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
- en: The next section is about another inbuilt Angular directive, `ngIf`, and another
    small enhancement.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: Adding the next exercise indicator using ngIf
  id: totrans-642
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It will be nice for the user to be told what the next exercise is during the
    short rest period between exercises. This will help them prepare for the next
    exercise. So let's add it.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: To implement this feature, we can simply output the title of the next exercise
    from the `workoutPlan.exercises` array. We show the title next to the `Time Remaining`
    countdown section.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the workout div (`class="exercise-pane"`) to include the highlighted
    content, and remove existing `Time Remaining` `h1`:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We wrap the existing `Time Remaining h1` and add another `h3` tag to show the
    next exercise inside a new `div` with some style updates. Also, there is a new
    directive, `ngIf`, in the second `h3`. The `*` prefix implies that it belongs
    to the same set of directives that `ngFor` belongs: **structural directives**.
    Let''s talk a bit about `ngIf`.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ngIf` directive is used to add or remove a specific section of the DOM
    based on whether the expression provided to it returns `true` or `false`. The
    DOM element is added when the expression evaluates to `true` and is destroyed
    otherwise. Isolate the `ngIf` declaration from the preceding view:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The directive expression checks whether we are currently in the rest phase and
    accordingly shows or hides the linked `h3`.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: Also in the same `h3`, we have an interpolation that shows the name of the exercise
    from the `workoutPlan.exercises` array.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: 'A word of caution here: `ngIf` adds and destroys the DOM element, and hence
    it is not similar to the visibility constructs that we employed to show and hide
    elements. While the end result of `style`, `display:none` is the same as that
    of `ngIf`, the mechanism is entirely different:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Versus this line:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'With `ngIf`, whenever the expression changes from `false` to `true`, a complete
    re-initialization of the content occurs. Recursively, new elements/components
    are created and data binding is set up, starting from the parent down to the children.
    The reverse happens when the expression changes from `true` to `false`: all of
    this is destroyed. Therefore, using `ngIf` can sometimes become an expensive operation
    if it wraps a large chunk of content and the expression attached to it changes
    very often. But otherwise, wrapping a view in `ngIf` is more performant than using
    CSS/style-based show or hide, as neither the DOM is created nor the data binding
    expressions are set up when the `ngIf` expression evaluates to `false`.'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: 'New version of Angular support branching constructs too. This allows us to
    implement the **if then else** flow in the view HTML. The following sample has
    been lifted directly from the platform documentation of `ngIf`:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `else` binding points to a `ng-template` with template variable `#elseBlock`.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another directive that belongs in this league: `ngSwitch`. When defined
    on the parent HTML, it can swap the child HTML elements based on the `ngSwitch`
    expression. Consider this example:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We bind the `userType` expression to `ngSwitch`. Based on the value of `userType`
    (`admin`, `powerUser`, or any other `userType`), one of the inner div elements
    will be rendered. The `ngSwitchDefault` directive is a wildcard match/fallback
    match, and it gets rendered when `userType` is neither `admin` nor `powerUser`.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not realized it yet, note that there are three directives working
    together here to achieve switch-case-like behavior:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '`ngSwitch`'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngSwitchCase`'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngSwitchDefault`'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Coming back to our next exercise implementation, we are ready to verify the
    implementation, start the app, and wait for the rest period. There should be a
    mention of the next exercise during the rest phase, as shown here:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/576ca7a4-2fc2-4d11-81d0-a37470c878a6.png)'
  id: totrans-668
  prefs: []
  type: TYPE_IMG
- en: The app is shaping up well. If you have used the app and done some physical
    workouts along with it, you will be missing the exercise pause functionality badly.
    The workout just does not stop until it reaches the end. We need to fix this behavior.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: Pausing an exercise
  id: totrans-670
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To pause an exercise, we need to stop the timer. We also need to add a button
    somewhere in the view that allows us to pause and resume the workout. We plan
    to do this by drawing a button overlay over the exercise area in the center of
    the page. When clicked on, it will toggle the exercise state between paused and
    running. We will also add keyboard support to pause and resume the workout using
    the key binding `p` or `P`. Let's update the component.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `WorkoutRunnerComponent` class, add these three functions, and add
    a declaration for the `workoutPaused` variable:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The implementation for pausing is simple. The first thing we do is cancel the
    existing `setInterval` setup by calling `clearInterval(this.exerciseTrackingInterval);`.
    While resuming, we again call `startExerciseTimeTracking`, which again starts
    tracking the time from where we left off.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just need to invoke the `pauseResumeToggle` function for the view. Add
    the following content to `workout-runner.html`:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `click` event handler on the div toggles the workout running state, and
    the `ngClass` directive is used to toggle the class between `ion-md-pause` and
    `ion-md-play`- standard Angular stuff. What is missing now is the ability to pause
    and resume on a *P* key press.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach could be to apply a `keyup` event handler on the div:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'But there are some shortcomings to this approach:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: The `div` element does not have a concept of focus, so we also need to add the
    `tabIndex` attribute on the div to make it work
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even then, it works only when we have clicked on the div at least once
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a better way to implement this; attach the event handler to the global
    `window` event `keyup`. This is how the event binding should be applied on the
    `div`:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Make note of the special `window:` prefix before the `keyup` event. We can
    use this syntax to attach events to any global object, such as the `document`.
    A handy and very powerful feature of Angular binding infrastructure! The `onKeyPressed`
    event handler needs to be added to `WorkoutRunnerComponent`. Add this function
    to the class:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The `$event` object is the standard **DOM event object** that Angular makes
    available for manipulation. Since this is a keyboard event, the specialized class
    is `KeyboardEvent`. The `which` property is matched to ASCII values of `p` or
    `P`. Refresh the page and you should see the play/pause icon when your mouse hovers
    over the exercise image, as follows:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e98c6d82-9004-466e-8788-93534ad69cdf.png)'
  id: totrans-688
  prefs: []
  type: TYPE_IMG
- en: While we are on the topic of **event binding**, it would be a good opportunity
    to explore Angular's event binding infrastructure
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: The Angular event binding infrastructure
  id: totrans-690
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular event binding allows a component to communicate with its parent through
    events.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: If we look back at the app implementation, what we have encountered thus far
    are the property/attribute bindings. Such bindings allow a component/element to
    take inputs from the outside world. The data flows into the component.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: Event bindings are the reverse of property bindings. They allow a component/element
    to inform the outside world about any state change.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in the pause/resume implementation, event binding employs round brackets
    (`()`) to specify the target event:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This attaches a `click` event handler to the `div` that invokes the expression
    `pauseResumeToggle()` when the `div` is clicked.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: 'Like properties, there is a canonical form for events too. Instead of using
    round brackets, the `on-` prefix can be used: `on-click="pauseResumeToggle()"`'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular supports all types of events. Events related to keyboard inputs, mouse
    movements, button clicks, and touches. The framework even allows us to define
    our own event for the components we create, such as:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: It is expected that events have side effects; in other words, an event handler
    may change the state of the component, which in turn may trigger a chain reaction
    in which multiple components react to the state change and change their own state.
    This is unlike a property binding expression, which should be side-effect-free.
    Even in our implementation, clicking on the `div` element toggles the exercise
    run state.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: Event bubbling
  id: totrans-701
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Angular attaches event handlers to standard HTML element events, the event
    propagation works in the same way as standard DOM event propagation works. This
    is also called **event bubbling**. Events on child elements are propagated upwards,
    and hence event binding is also possible on a parent element, as follows:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Clicking on either of the divs results in the invocation of the `doWork` function
    on the parent `div`. Moreover, `$event.target` contains the reference to the `div`
    that dispatched the event.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: Custom events created on Angular components do not support event bubbling.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: 'Event bubbling stops if the expression assigned to the target evaluates to
    a `falsey` value (such as `void`, `false`). Therefore, to continue propagation,
    the expression should evaluate to `true`:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Here too, the `$event` object deserves some special attention.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: Event binding an $event object
  id: totrans-709
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular makes an `$event` object available whenever the target event is triggered.
    This `$event` contains the details of the event that occurred.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to note here is that the shape of the `$event` object is
    decided based on the event type. For HTML elements, it is a DOM event object ([https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events)),
    which may vary based on the actual event.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: But if it is a custom component event, what is passed in the `$event` object
    is decided by the component implementation.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: We have now covered most of the data binding capabilities of Angular, with the
    exception of two-way binding. A quick introduction to the two-way binding constructs
    is warranted before we conclude the chapter.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: Two-way binding with ngModel
  id: totrans-714
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Two-way binding** helps us keep the model and view in sync. Changes to the
    model update the view and changes to the view update the model. The obvious area
    where two-way binding is applicable is form input. Let''s look at a simple example:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The `ngModel` directive here sets a two-way binding between the `input`'s `value`
    property and the `workout.name` property on the underlying component. Anything
    that the user enters in the preceding  `input` is synced with `workout.name`,
    and any changes to `workout.name` are reflected back on the preceding `input`.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, we can achieve the same result without using the `ngModel` directive
    too, by combining both property and event binding syntax. Consider the next example;
    it works in the same way as `input` before:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: There is a property binding set up on the `value` property and an event binding
    set up on the `input` event that make the bidirectional sync work.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: We will get into more details on two-way binding in [Chapter 2](4b0ad450-2a56-4c24-b431-116d7225a57e.xhtml),* Personal
    Trainer*, where we build our own custom workouts.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created a diagram that summarizes the data flow patterns for all the
    bindings that we have discussed thus far. Here is a handy diagram to help you
    memorize each of the binding constructs and how data flows:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15166818-fb41-410a-8e11-a6843f5217a1.png)'
  id: totrans-723
  prefs: []
  type: TYPE_IMG
- en: We now have a fully functional *7 Minute Workout*, with some bells and whistles
    too, and hopefully you had fun creating the app. It's time to conclude the chapter
    and summarize the lessons.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.4`
    for a working version of what we have done thus far. You can also download a snapshot
    of `checkpoint2.4` (a ZIP file) from this GitHub location: [http://bit.ly/ng6be-checkpoint-2-4](http://bit.ly/ng6be-checkpoint-2-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: Cross-component communication using Angular events
  id: totrans-726
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time now to look at eventing in more depth. Let's add audio support to *7-Minute
    Workout*.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: Tracking exercise progress with audio
  id: totrans-728
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the *7-Minute Workout* app, adding sound support is vital. One cannot exercise
    while constantly staring at the screen. Audio clues help the user perform the
    workout effectively as they can just follow the audio instructions.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we are going to support exercise tracking using audio clues:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: A ticking clock soundtrack progress during the exercise
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A half-way indicator sounds, indicating that the exercise is halfway through
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exercise-completion audio clip plays when the exercise is about to end
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An audio clip plays during the rest phase and informs users about the next exercise
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be an audio clip for each of these scenarios.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: Modern browsers have good support for audio. The HTML5 `<audio>` tag provides
    a mechanism to embed audio clips into HTML content. We too will use the `<audio>` tag
    to play back our clips.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: Since the plan is to use the HTML `<audio>` element, we need to create a wrapper
    directive that allows us to control audio elements from Angular. Remember that
    directives are HTML extensions without a view.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: The `checkpoint3.4` Git and the `trainer/static/audio` folder contain all the
    audio files used for playback; copy them first. If you are not using Git, a snapshot
    of the chapter code is available at [http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4).
    Download and unzip the contents and copy the audio files.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: Building Angular directives to wrap HTML audio
  id: totrans-739
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have worked a lot with JavaScript and jQuery, you may have realized we have
    purposefully shied away from directly accessing the DOM for any of our component
    implementations. There has not been a need to do it. The Angular data-binding
    infrastructure, including property, attribute, and event binding, has helped us
    manipulate HTML without touching the DOM.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: For the audio element too, the access pattern should be Angularish. In Angular,
    the only place where direct DOM manipulation is acceptable and practiced is inside
    directives. Let's create a directive that wraps access to audio elements.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to `trainer/src/app/shared` and run this command to generate a template
    directive:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Since it is the first time we are creating a directive, we encourage you to
    look at the generated code.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the directive is added to the shared module, it needs to be exported
    too. Add the `MyAudioDirective` reference in the `exports` array too (`shared.module.ts`).
    Then update the directive definition with the following code:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The `MyAudioDirective` class is decorated with `@Directive`. The `@Directive` decorator
    is similar to the `@Component` decorator except we cannot have an attached view.
    Therefore, no `template` or `templateUrl` is allowed!
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `selector` property allows the framework to identify where to
    apply the directive. We have replaced the generated `[abeMyAudioDirective]` attribute
    selector with just `audio`. Using `audio` as the selector makes our directive
    load for every `<audio>` tag used in HTML. The new selector works as an element
    selector.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: In a standard scenario, directive selectors are attribute-based (such as `[abeMyAudioDirective]` for
    the generated code), which helps us identify where the directive has been applied.
    We deviate from this norm and use an element selector for the `MyAudioDirective` directive.
    We want this directive to be loaded for every audio element, and it becomes cumbersome
    to go to each audio declaration and add a directive-specific attribute. Hence
    an element selector.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: The use of `exportAs` becomes clear when we use this directive in view templates.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: The `ElementRef` object injected in the constructor is the Angular element (`audio` in
    this case) for which the directive is loaded. Angular creates the `ElementRef` instance
    for every component and directive when it compiles and executes the HTML template.
    When requested in the constructor, the DI framework locates the corresponding `ElementRef` and
    injects it. We use `ElementRef` to get hold of the underlying audio element in
    the code (the instance of `HTMLAudioElement`). The `audioPlayer` property holds
    this reference.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: 'The directive now needs to expose an API to manipulate the audio player. Add
    these functions to the `MyAudioDirective` directive:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The `MyAudioDirective` API has two functions (`start` and `stop`) and three
    getters (`currentTime`, `duration`, and a Boolean property called `playbackComplete`).
    The implementations for these functions and properties just wrap the audio element
    functions.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: Learn about these audio functions from the MDN documentation here: [http://bit.ly/html-media-element](http://bit.ly/html-media-element).
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: To understand how we use the audio directive, let's create a new component that
    manages audio playback.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: Creating WorkoutAudioComponent for audio support
  id: totrans-757
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we go back and look at the audio cues that are required, there are four distinct
    audio cues, and hence we are going to create a component with five embedded `<audio>` tags
    (two audio tags work together for next-up audio).
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: From the command line go to the `trainer/src/app/workout-runner` folder and
    add a new `WorkoutAudioComponent` component using Angular CLI.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout-audio.component.html` and replace the existing view template
    with this HTML snippet:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'There are five `<audio>` tags, one for each of the following:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: '**Ticking audio**: The first audio tag produces the ticking sound and is started as
    soon as the workout starts.'
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Next up audio and exercise audio**: There next two audio tags work together.
    The first tag produces the "Next up" sound. And the actual exercise audio is handled
    by the third tag (in the preceding code snippet).'
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Halfway audio**: The fourth audio tag plays halfway through the exercise.'
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**About to complete audio**: The final audio tag plays a piece to denote the
    completion of an exercise.'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you notice the usage of the `#` symbol in each of the `audio` tags? There
    are some variable assignments prefixed with `#`. In the Angular world, these variables are
    known as **template reference variables** or at times **template variables**.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: 'As the platform guide defines:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: A template reference variable is often a reference to a DOM element or directive
    within a template.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: Don't confuse them with the template input variables that we have used with
    the `ngFor` directive earlier, `*ngFor="let` video `of videos"`. The **template
    input variable's** (`video` in this case) scope is within the HTML fragment it
    is declared, whereas the template reference variable can be accessed across the
    entire template.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the last section where `MyAudioDirective` was defined. The `exportAs` metadata
    is set to `MyAudio`. We repeat that same `MyAudio` string while assigning the `template
    reference variable` for each audio tag:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The role of `exportAs` is to define the name that can be used in the view to
    assign this directive to a variable. Remember, a single element/component can
    have multiple directives applied to it. `exportAs` allows us to select which directive
    should be assigned to a template-reference variable based on what is on the right
    side of equals.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: Typically, template variables, once declared, give access to the view element/component
    they are attached to, to other parts of the view, something we will discuss shortly.
    But in our case, we will use template variables to refer to the multiple `MyAudioDirective` from
    the parent component's code. Let's understand how to use them.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the generated `workout-audio.compnent.ts` with the following outline:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The interesting bit in this outline is the `@ViewChild` decorator against the
    five properties. The `@ViewChild` decorator allows us to inject a child component/directive/element
    reference into its parent. The parameter passed to the decorator is the template
    variable name, which helps DI match the element/directive to inject. When Angular
    instantiates the main `WorkoutAudioComponent`, it injects the corresponding audio
    directives based on the `@ViewChild` decorator and the template reference variable
    name passed. Let's complete the basic class implementation before we look at `@ViewChild` in
    detail.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: Without `exportAs` set on the `MyAudioDirective` directive, the `@ViewChild` injection
    injects the related `ElementRef` instance instead of the `MyAudioDirective` instance.
    We can confirm this by removing the `exportAs` attribute from `myAudioDirective` and
    then looking at the injected dependencies in `WorkoutAudioComponent`.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining task is to just play the correct audio component at the right
    time. Add these functions to `WorkoutAudioComponent`:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Having trouble writing these functions? They are available in the `checkpoint3.3` Git
    branch.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two new model classes used in the preceding code. Add their declarations
    to `model.ts`, as follows (again available in `checkpoint3.3`):'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: These are model classes to track progress events. The `WorkoutAudioComponent` implementation
    consumes this data. Remember to import the reference for `ExerciseProgressEvent` and `ExerciseProgressEvent` in `workout-audio.component.ts`.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, the audio component consumes the events by defining two event
    handlers: `onExerciseProgress` and `onExerciseChanged.` How the events are generated
    becomes clear as we move along.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: The `start` and `resume` functions stop and resume audio whenever a workout
    starts, pauses, or completes. The extra complexity in the resume function it to
    tackle cases when the workout was paused during next up, about to complete, or
    half-way audio playback. We just want to continue from where we left off.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: The `onExerciseProgress` function should be called to report the workout progress.
    It's used to play the halfway audio and about-to-complete audio based on the state
    of the workout. The parameter passed to it is an object that contains exercise
    progress data.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: The `onExerciseChanged` function should be called when the exercise changes.
    The input parameter contains the current and next exercise in line and helps `WorkoutAudioComponent` to
    decide when to play the next up exercise audio.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: 'We touched upon two new concepts in this section: template reference variables
    and injecting child elements/directives into the parent. It''s worth exploring
    these two concepts in more detail before we continue with the implementation.
    We''ll start with learning more about template reference variables.'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: Understanding template reference variables
  id: totrans-790
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Template reference variables** are created on the view template and are mostly
    consumed from the view. As you have already learned, these variables can be identified
    by the `#` prefix used to declare them.'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the greatest benefits of template variables is that they facilitate
    cross-component communication at the view template level. Once declared, such
    variables can be referenced by sibling elements/components and their children.
    Check out the following snippet:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This snippet declares a template variable, `emailId`, and then references it
    in the interpolation and the button `click` expression.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: The Angular templating engine assigns the DOM object for `input` (an instance
    of `HTMLInputElement`) to the `emailId` variable. Since the variable is available
    across siblings, we use it in a button's `click` expression.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: 'Template variables work with components too. We can easily do this:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: In this case, `runner` has a reference to the `WorkoutRunnerComponent` object,
    and the button is used to start the workout.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: The `ref-` prefix is the canonical alternative to `#`. The `#runner` variable
    can also be declared as `ref-runner`.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: Template variable assignment
  id: totrans-800
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may not have noticed but there is something interesting about the template variable
    assignments described in the last few sections. To recap, the three examples that
    we have used are:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'What got assigned to the variable depends on where the variable was declared.
    This is governed by rules in Angular:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: If a directive is present on the element, such as `MyAudioDirective` in the
    first example shown previously, the directive sets the value. The `MyAudioDirective` directive
    sets the `ticks` variable to an instance of `MyAudioDirective`.
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no directive present, either the underlying HTML DOM element is
    assigned or a component object is assigned (as shown in the `input` and `workout-runner` examples).
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be employing this technique to implement the workout audio component
    integration with the workout runner component. This introduction gives us the
    head start that we need.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: The other new concept that we promised to cover is child element/directive injection
    using the `ViewChild` and `ViewChildren` decorators.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: Using the @ViewChild decorator
  id: totrans-808
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@ViewChild` decorator instructs the Angular DI framework to search for
    some specific child component/directive/element in the component tree and inject
    it into the parent. This allows the parent component to interact with child components/element
    using the reference to the child, a new communication pattern!
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, the audio element directive (the `MyAudioDirective` class)
    is injected into the `WorkoutAudioComponent` code.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: 'To establish the context, let''s recheck a view fragment from `WorkoutAudioComponent`:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Angular injects the directive (`MyAudioDirective`) into the `WorkoutAudioComponent` property: `ticks`.
    The search is done based on the selector passed to the `@ViewChild` decorator.
    Let''s see the audio example again:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The selector parameter on `ViewChild` can be a string value, in which case Angular
    searches for a matching template variable, as before.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: 'Or it can be a *type.* This is valid and should inject an instance of `MyAudioDirective`:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: However, it does not work in our case. Why? Because there are multiple `MyAudioDirective` directives
    declared in the `WorkoutAudioComponent` view, one for each of the `<audio>` tags.
    In such a scenario, the first match is injected. Not very useful. Passing the
    type selector would have worked if there was only one `<audio>` tag in the view!
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: Properties decorated with `@ViewChild` are sure to be set before the `ngAfterViewInit` event
    hook on the component is called. This implies such properties are `null` if accessed
    inside the constructor.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: Angular also has a decorator to locate and inject multiple child components/directives: `@ViewChildren`.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: The @ViewChildren decorator
  id: totrans-821
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`@ViewChildren` works similarly to `@ViewChild`, except it can be used to inject
    multiple child types into the parent. Again taking the previous audio component
    above as an example, using `@ViewChildren`, we can get all the `MyAudioDirective` directive
    instances in `WorkoutAudioComponent`, as shown here:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Look carefully; `allAudios` is not a standard JavaScript array, but a custom
    class, `QueryList<Type>`. The `QueryList` class is an immutable collection that
    contains the reference to the components/directives that Angular was able to locate
    based on the filter criteria passed to the `@ViewChildren` decorator. The best
    thing about this list is that Angular will keep this list in sync with the state
    of the view. When directives/components get added/removed from the view dynamically,
    this list is updated too. Components/directives generated using `ng-for` are a
    prime example of this dynamic behavior. Consider the preceding `@ViewChildren` usage
    and this view template:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The number of `MyAudioDirective` directives created by Angular depends upon
    the number of `clips`. When `@ViewChildren` is used, Angular injects the correct
    number of `MyAudioDirective` instances into the `allAudio` property and keeps
    it in sync when items are added or removed from the `clips` array.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: While the usage of `@ViewChildren` allows us to get hold of all `MyAudioDirective` directives,
    it cannot be used to control the playback. You see, we need to get hold of individual `MyAudioDirective` instances
    as the audio playback timing varies. Hence the distinct `@ViewChild` implementation.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: Once we get hold of the `MyAudioDirective` directive attached to each audio
    element, it is just a matter of playing the audio tracks at the right time.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: Integrating WorkoutAudioComponent
  id: totrans-829
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have componentized the audio playback functionality into `WorkoutAudioComponent`,
    it is and always will be tightly coupled to the `WorkoutRunnerComponent` implementation. `WorkoutAudioComponent` derives
    its operational intelligence from `WorkoutRunnerComponent`. Hence the two components
    need to interact. `WorkoutRunnerComponent` needs to provide the `WorkoutAudioComponent` state
    change data, including when the workout started, exercise progress, workout stopped,
    paused, and resumed.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: One way to achieve this integration would be to use the currently exposed `WorkoutAudioComponent` API
    (stop, resume, and other functions) from `WorkoutRunnerComponent`.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: Something can be done by injecting `WorkoutAudioComponent` into `WorkoutRunnerComponent`,
    as we did earlier when we injected `MyAudioDirective` into `WorkoutAudioComponent`.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the `WorkoutAudioComponent` in the `WorkoutRunnerComponent''s` view,
    such as:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Doing so gives us a reference to the `WorkoutAudioComponent` inside the `WorkoutRunnerComponent` implementation:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The `WorkoutAudioComponent` functions can then be invoked from `WorkoutRunnerComponent` from
    different places in the code. For example, this is how `pause` would change:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'And to play the next-up audio, we would need to change parts of the `startExerciseTimeTracking` function:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This is a perfectly viable option where `WorkoutAudioComponent` becomes a dumb
    component controlled by `WorkoutRunnerComponent`. The only problem with this solution
    is that it adds some noise to the `WorkoutRunnerComponent` implementation. `WorkoutRunnerComponent` now
    needs to manage audio playback too.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative, however.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutRunnerComponent` can expose events that are triggered during different
    times of workout execution, such as workout started, exercise started, and workout
    paused. The advantage of having `WorkoutRunnerComponent` expose events is that
    it allows us to integrate other components/directives with `WorkoutRunnerComponent` using
    the same events. Be it the `WorkoutAudioComponent` or components we create in
    future.'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: Exposing WorkoutRunnerComponent events
  id: totrans-844
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now we have only explored how to consume events. Angular allows us to raise
    events too. Angular components and directives can expose custom events using the `EventEmitter` class
    and the `@Output` decorator.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these event declarations to `WorkoutRunnerComponent` at the end of the
    variable declaration section:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The names of the events are self-explanatory, and within our `WorkoutRunnerComponent` implementation,
    we need to raise them at the appropriate times.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: Remember to add the `ExerciseProgressEvent` and `ExerciseChangeEvent` imports
    to the `model` already declared on top. And add the `Output` and `EventEmitter` imports
    to `@angular/core`.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to understand the role of the `@Output` decorator and the `EventEmitter` class.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: The @Output decorator
  id: totrans-851
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a decent amount of Angular eventing capabilities in this chapter. Specifically,
    we learned how we can consume any event on a component, directive, or DOM element
    using the `bracketed ()` syntax. How about raising our own events?
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: In Angular, we can create and raise our own events, events that signify something
    noteworthy has happened in our component/directive. Using the `@Output` decorator
    and the `EventEmitter` class, we can define and raise custom events.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: It's also a good time to refresh what we learned about events.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember this: it is through events that components can communicate with the
    outside world. When we declare:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: It signifies that `WorkoutRunnerComponent` exposes an event, `exercisePaused` (raised
    when the workout is paused).
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: 'To subscribe to this event, we can do the following:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'This looks absolutely similar to how we did the DOM event subscription in the
    workout runner template. See this sample stipped from the workout-runner''s view:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The `@Output` decorator instructs Angular to make this event available for template
    binding. Events created without the `@Output` decorator cannot be referenced in
    HTML.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Output` decorator can also take a parameter, signifying the name of the
    event. If not provided, the decorator uses the property name: `@Output("workoutPaused")
    exercisePaused: EventEmitter<number> ...`. This declares a `workoutPaused` event
    instead of `exercisePaused`.'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: Like any decorator, the `@Output` decorator is there just to provide metadata
    for the Angular framework to work with. The real heavy lifting is done by the `EventEmitter` class.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: Eventing with EventEmitter
  id: totrans-865
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular embraces **reactive programming** (also dubbed **Rx**-style programming)
    to support asynchronous operations with events. If you are hearing this term for
    the first time or don't have much idea about what reactive programming is, you're
    not alone.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is all about programming against **asynchronous data streams**.
    Such a stream is nothing but a sequence of ongoing events ordered based on the
    time they occur. We can imagine a stream as a pipe generating data (in some manner)
    and pushing it to one or more subscribers. Since these events are captured asynchronously
    by subscribers, they are called asynchronous data streams.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: The data can be anything, ranging from browser/DOM element events to user input
    to loading remote data using AJAX. With *Rx* style, we consume this data uniformly.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: In the Rx world, there are Observers and Observables, a concept derived from
    the very popular **Observer design pattern**. **Observables** are streams that
    emit data. **Observers**, on the other hand, subscribe to these events.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: The `EventEmitter` class in Angular is primarily responsible for providing eventing
    support. It acts both as an *observer* and *observable*. We can fire events on
    it and it can also listen to events.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two functions available on `EventEmitter` that are of interest to
    us:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: '`emit`: As the name suggests, use this function to raise events. It takes a
    single argument that is the event data. `emit` *is the observable side*.'
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe`: Use this function to subscribe to the events raised by `EventEmitter`. `subscribe` is
    the observer side.'
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's do some event publishing and subscriptions to understand how the preceding
    functions work.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: Raising events from WorkoutRunnerComponent
  id: totrans-875
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look at the `EventEmitter` declaration. These have been declared with the `type` parameter.
    The `type` parameter on `EventEmitter` signifies the type of data emitted.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: Let's add the event implementation to `workout-runner.component.ts`, starting
    from the top of the file and moving down.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this statement to the end of the `start` function:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: We use the `emit` function of  `EventEmitter`  to raise a `workoutStarted` event
    with the current workout plan as an argument.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: 'To `pause`, add this line to raise the `exercisePaused` event:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'To `resume`, add the following line:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Each time, we pass the current exercise index as an argument to `emit` when
    raising the `exercisePaused` and `exerciseResumed` events.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `startExerciseTimeTracking` function, add the highlighted code after
    the call to `startExercise`:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The argument passed contains the exercise that is going to start (`next`) and
    the next exercise in line (`this.getNextExercise()`).
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: 'To the same function, add the highlighted code:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The event is raised when the workout is completed.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same function, we raise an event that communicates the workout progress.
    Add this statement:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: That completes our eventing implementation.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: As you may have guessed, `WorkoutAudioComponent` now needs to consume these
    events. The challenge here is how to organize these components so that they can
    communicate with each other with the minimum dependency on each other.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: Component communication patterns
  id: totrans-896
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the implementation stands now, we have:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: A basic `WorkoutAudioComponent` implementation
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augmented `WorkoutRunnerComponent` by exposing workout life cycle events
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two components just need to talk to each other now.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: 'If the parent needs to communicate with its children, it can do this by:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: '**Property binding**: The parent component can set up a property binding on
    the child component to push data to the child component. For example, this property
    binding can stop the audio player when the workout is paused:'
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Property binding, in this case, works fine. When the workout is paused, the
    audio is stopped too. But not all scenarios can be handled using property bindings.
    Playing the next exercise audio or halfway audio requires a bit more control.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: '**Calling functions on child components**: The parent component can also call
    functions on the child component if it can get hold of the child component. We
    have already seen how to achieve this using the `@ViewChild` and `@ViewChildren` decorators
    in the `WorkoutAudioComponent` implementation. This approach and its shortcomings
    have also been discussed briefly in the *Integrating WorkoutAudioComponent* section.'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is one more not-so-good option. Instead of the parent referencing the
    child component, the child references the parent component. This allows the child
    component to call the parent component's public functions or subscribe to parent
    component events.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: We are going to try this approach and then scrap the implementation for a better
    one! A lot of learning can be derived from the not-so-optimal solution we plan
    to implement.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: Injecting a parent component into a child component
  id: totrans-908
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the `WorkoutAudioComponent` to the `WorkoutRunnerComponent` view just before the
    last closing `div`:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Next, inject `WorkoutRunnerComponent` into `WorkoutAudioComponent`. Open `workout-audio.component.ts` and
    add the following declaration and update the constructor:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'And remember to add these imports:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Let's try to understand what we have done before running the app. There is some
    amount of trickery involved in the construction injection. If we directly try
    to inject `WorkoutRunnerComponent` into `WorkoutAudioComponent`, it fails with
    Angular complaining of not being able to find all the dependencies. Read the code
    and think carefully; there is a subtle dependency cycle issue lurking. `WorkoutRunnerComponent` is
    already dependent on `WorkoutAudioComponent`, as we have referenced `WorkoutAudioComponent` in
    the `WorkoutRunnerComponent` view. Now by injecting `WorkoutRunnerComponent` in `WorkoutAudioComponent`,
    we have created a dependency cycle.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: Cyclic dependencies are challenging for any DI framework. When creating a component
    with a cyclic dependency, the framework has to somehow resolve the cycle. In the
    preceding example, we resolve the circular dependency issue by using an `@Inject` decorator
    and passing in the token created using the `forwardRef()` global framework function.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: Once the injection is done correctly, inside the constructor, we attach a handler
    to the `WorkoutRunnerComponent` events, using the `subscribe` function of `EventEmitter`.
    The arrow function passed to `subscribe` is called whenever the event occurs with
    a specific event argument. We collect all the subscriptions into a `subscription` array.
    This array comes in handy when we unsubscribe, which we need to, to avoid memory
    leaks.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit about `EventEmitter`: the `EventEmmiter` subscription (`subscribe` function)
    takes three arguments:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The first argument is a callback, which is invoked whenever an event is emitted
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument is an error callback function, invoked when the observable
    (the part that is generating events) errors out
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final argument takes a callback function that is called when the observable
    is done publishing events
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have done enough to make audio integration work. Run the app and start the
    workout. Except for the ticking audio, all the `\` audio clips play at the right
    time. You may have to wait some time to hear the other audio clips. What is the
    problem?
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, we never started the ticking audio clip at the start of the
    workout. We can fix it by either setting the `autoplay` attribute on the `ticks` audio
    element or using the component life cycle events to trigger the ticking sound.
    Let's take the second approach.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: Using component life cycle events
  id: totrans-925
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The injected `MyAudioDirective` in `WorkoutAudioComponent`, shown as follows,
    is not available till the view is initialized:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: We can verify it by accessing the `ticks` variable inside the constructor; it
    will be null. Angular has still not done its magic and we need to wait for the
    children of `WorkoutAudioComponent` to be initialized.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: The component's life cycle hooks can help us here. The `AfterViewInit` event
    hook is called once the component's view has been initialized and hence is a safe
    place from which to access the component's child directives/elements. Let's do
    it quickly.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `WorkoutAudioComponent` by adding the interface implementation, and
    the necessary imports, as highlighted:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Go ahead and test the app. The app has come to life with full-fledged audio
    feedback. Nice!
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: While everything looks fine and dandy on the surface, there is a memory leak
    in the application now. If, in the middle of the workout, we navigate away from
    the workout page (to the start or finish page) and again return to the workout
    page, multiple audio clips play at random times.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: It seems that `WorkoutRunnerComponent` is not getting destroyed on route navigation,
    and due to this, none of the child components are destroyed, including `WorkoutAudioComponent`.
    The net result? A new `WorkoutRunnerComponent` is being created every time we
    navigate to the workout page but is never removed from the memory on navigating
    away.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: The primary reason for this memory leak is the event handlers we have added
    in `WorkoutAudioComponent`. We need to unsubscribe from these events when the
    audio component unloads, or else the `WorkoutRunnerComponent` reference will never
    be dereferenced.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: 'Another component lifecycle event comes to our rescue here: `OnDestroy` Add
    this implementation to the `WorkoutAudioComponent` class:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Also, remember to add references to the `OnDestroy` event interface as we did
    for `AfterViewInit`.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: Hope the `subscription` array that we created during event subscription makes
    sense now. One-shot unsubscribe!
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: This audio integration is now complete. While this approach is not an awfully
    bad way of integrating the two components, we can do better. Child components
    referring to the parent component seems to be undesirable.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding, delete the code that we have added to `workout-audio.component.ts` from
    the *Injecting a parent component into a child component* section onward.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: Sibling component interaction using events and template variables
  id: totrans-942
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if `WorkoutRunnerComponent` and `WorkoutAudioComponent` were organized
    as sibling components?
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: 'If `WorkoutAudioComponent` and `WorkoutRunnerComponent` become siblings, we
    can make good use of Angular''s *eventing* and *template reference variables*.
    Confused? Well, to start with, this is how the components should be laid out:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Does it ring any bells? Starting from this template, can you guess how the final
    HTML template would look? Think about it before you proceed further.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: 'Still struggling? As soon as we make them sibling components, the power of
    the Angular templating engine comes to the fore. The following template code is
    enough to integrate `WorkoutRunnerComponent` and `WorkoutAudioComponent`:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The `WorkoutAudioComponent` template variable, `wa`, is being manipulated by
    referencing the variable in the event handler expressions on `WorkoutRunnerComponent`.
    Quite elegant! We still need to solve the biggest puzzle in this approach: Where
    does the preceding code go? Remember, `WorkoutRunnerComponent` is loaded as part
    of route loading. Nowhere in the code have we had a statement like this:'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: We need to reorganize the component tree and bring in a container component
    that can host `WorkoutRunnerComponent` and `WorkoutAudioComponent`. The router
    then loads this container component instead of `WorkoutRunnerComponent`. Let's
    do it.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a new component code from command line by navigating to `trainer/src/app/workout-runner` and
    executing:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Copy the HTML code with the events described to the template file. The workout
    container component is ready.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need to rewire the routing setup. Open `app-routing.module.ts`. Change
    the route for the workout runner and add the necessary import:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: And we have a working audio integration that is clear, concise, and pleasing
    to the eye!
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: It's time now to wrap up the chapter, but not before addressing the video player
    dialog glitch introduced in the earlier sections. The workout does not stop/pause
    when the video player dialog is open.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to detail the fix here, and urge the readers to give it a try
    without consulting the `checkpoint3.4` code.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: Here is an obvious hint. Use the eventing infrastructure!
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: 'And another one: raise events from `VideoPlayerComponent`, one for each playback
    started and ended.'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: 'And one last hint: the `open` function on the dialog service (`Modal`) returns
    a promise, which is resolved when the dialog is closed.'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the `checkpoint3.4` Git
    branch for a working version of what we have done thus far. Or if you are not
    using Git, download the snapshot of `checkpoint3.4` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-964
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter with the aim of creating a complex Angular app. The
    *7 Minute Workout* app fitted the bill, and you learned a lot about the Angular
    framework while building this app.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: To build the app, we started off by defining the model of the app. Once the
    model was in place, we started the actual implementation by building an **Angular
    component**. Angular components are nothing but classes that are decorated with
    a framework-specific decorator, `@Component`.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about **Angular modules** and how Angular uses them to organize
    code artifacts.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: Once we had a fully functional component, we created a supporting view for the
    app. We also explored the data binding capabilities of the framework, including
    **property**, **attribute**, **class**, **style,** and **event binding**. Plus,
    we highlighted how **interpolations** are a special case of property binding.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: Components are a special class of directives that have an attached view. We
    touched upon what directives are and the special classes of directives, including
    **attribute** and **structural directives**.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to perform cross-component communication using **input properties**.
    The two child components that we put together (`ExerciseDescriptionComponent`
    and `VideoPlayerComponent`) derived their inputs from the parent `WorkoutRunnerComponent`
    using input properties.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: We then covered another core construct in Angular, **pipes**. We saw how to
    use pipes such as the date pipe and how to create one of our own.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the chapter, we touched upon a number of Angular directives, including
    the following:'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: '`ngClass/ngStyle`: For applying multiple styles and classes using Angular binding
    capabilities'
  id: totrans-973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngFor`: For generating dynamic HTML content using a looping construct'
  id: totrans-974
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngIf`: For conditionally creating/destroying DOM elements'
  id: totrans-975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngSwitch`: For creating/destroying DOM elements using the switch-case construct'
  id: totrans-976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now have a basic *7 Minute Workout* app. For a better user experience, we
    have added a number of small enhancements to it too, but we are still missing
    some good-to-have features that would make our app more usable. From the framework
    perspective, we have purposefully ignored some core/advanced concepts such as
    **change detection**, **dependency injection**, **component** **routing**, and
    data flow patterns.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we touched upon an important topic: cross-component communication,
    primarily using Angular eventing. We detailed how to create custom events using
    the `@Output` decorator and `EventEmitter`.'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: The `@ViewChild` and `@ViewChildren` decorators that we touched upon in this
    chapter helped us understand how a parent can get hold of a child component for
    use. Angular DI also allows injecting a parent component into a child.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: We concluded this chapter by building a `WorkoutAudioComponent` and highlighted
    how sibling-component communication can happen using Angular events and template
    variables.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: What's next? We are going to build a new app, *Personal Trainer*. This app will
    allow us to build our own custom workouts. Once we can create our own workout,
    we are going to morph the *7-Minute Workout* app into a generic *Workout Runner* app
    that can run workouts that we build using *Personal Trainer*.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: For the next chapter, we'll showcase Angular's form capabilities while we build
    a UI that allows us to create, update, and view our own custom workouts/exercises.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
