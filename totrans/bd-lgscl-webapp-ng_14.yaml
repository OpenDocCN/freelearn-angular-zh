- en: Design Authentication and Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing a high-quality authentication and authorization system without frustrating
    the end user is a difficult problem to solve. Authentication is the act of verifying
    the identity of a user, and authorization specifies the privileges a user has
    to access a resource. Both processes, auth for short, must seamlessly work in
    tandem to address the needs of users with varying roles, needs, and job functions.
    In today's web, users have a high baseline level of expectations from any auth
    system they encounter through the browser, so this is a really important part
    of your application to get absolutely right the first time.
  prefs: []
  type: TYPE_NORMAL
- en: The user should always be aware of what they can and can't do in your app. If
    there are errors, failures, or mistakes, the user should be clearly informed as
    to why such an error occured. As your application grows, it is easy to miss all
    the ways an error condition could be triggered. Your implementation should be
    easy to extend or maintain, otherwise this basic backbone of your application
    will require a lot of maintenance. In this chapter, we will walk-through the various
    challenges of creating a great auth UX and implement a solid baseline experience.
  prefs: []
  type: TYPE_NORMAL
- en: We will be continuing the router-first approach to designing SPAs by implementing
    the authentication and authorization experience of LemonMart. In [Chapter 12](b49e4716-d083-4c8c-a083-bcf6cf182a6f.xhtml),
    *Create a Router-First Line-of-Business App*, we defined user roles, finished
    our build-out of all major routing and completed a rough walking-skeleton navigation
    experience of LemonMart, so we are well prepared to implement role-based routing
    and the nuances of pulling such an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 13](215237a5-318b-4de2-82a8-4e40e438b228.xhtml), *Continuous Integration
    and API Design*, we discussed the idea of designing around major data components,
    so you are already familiar with how a user entity looks like, which will come
    in handy in implementing a token-based login experience, including caching role
    information within the entity.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into auth, we will discuss the importance of completing high-level
    mock -ups for your application before starting to implement various conditional
    navigation elements, which may change significantly during the design phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Importance of high-level UX design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Token-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Side Navigation bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusable UI Service for alerts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON Web Tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular HTTP interceptors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Router guards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping up mock-ups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mock-ups are important in determining what kind of components and user controls
    we will need throughout the app. Any user control or component that will be used
    across components will need to defined at the root level and others scoped with
    their own modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already identified the submodules and designed landing pages for them
    to complete the walking skeleton. Now that we have defined the major data components,
    we can complete mock-ups for the rest of the app. When designing screens at a
    high-level, keep several things in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Can a user complete common tasks required for their role with as little navigation
    as possible?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can users readily access all information and functionality of the app through
    visible elements on the screen?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can a user search for the data they need easily?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a user finds a record of interest, can they drill-down into detail records
    or view related records with ease?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is that pop-up alert really necessary? You know users won't read it, right?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that there's no one right way to design any user experience, which
    is why when designing screens, always keep modularity and reusability in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you generate various design artifacts, such as mock-ups or design decisions,
    take care to post them on a wiki reachable by all team members:'
  prefs: []
  type: TYPE_NORMAL
- en: On GitHub, switch over to the Wiki tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may check out my sample wiki at [Github.com/duluca/lemon-mart/wiki](https://github.com/duluca/lemon-mart/wiki),
    as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a128f277-a197-4e69-bd80-58cd58280273.png)'
  prefs: []
  type: TYPE_IMG
- en: GitHub.com LemonMart Wiki
  prefs: []
  type: TYPE_NORMAL
- en: When creating a wiki page, ensure that you cross-link between any other documentation
    available, such as Readme
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that GitHub shows subpages on the wiki under Pages
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, an additional summary is helpful, such as the Design Artifacts section,
    since some people may miss the navigational element on the right
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you complete mock-ups, post them on wiki
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see a summary view of the wiki here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a78acfc-a5a0-45df-852e-7adb8497c599.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary view of Lemon Mart mock-ups
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, place the mock-ups in the walking skeleton app so that testers can
    better envision the functionality that is yet to be developed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the mock-ups completed, we can now continue the implementation of LemonMart
    with the Authentication and Authorization workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Design authentication and authorization workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A well-designed authentication workflow is stateless so that there's no concept
    of an expiring session. Users are free to interact with your stateless REST APIs
    from as many devices and tabs as they wish, simultaneously or overtime. **JSON
    Web Token** (**JWT**) implements distributed claims-based authentication that
    can be digitally signed or integration protected and/or encrypted using a **Message
    Authentication Code** (**MAC**). This means once a user's identity is authenticated
    through, let's say a password-challenge, they receive an encoded claim ticket
    or a token, which can then be used to make future requests to the system without
    having to reauthenticate the identity of a user. The server can independently
    verify the validity of this claim and process the requests without requiring any
    prior knowledge of having interacted with this user. Thus, we don't have to store
    session information regarding a user, making our solution stateless and easy to
    scale. Each token will expire after a predefined period and due to their distributed
    nature, they can't be remotely or individually revoked; however, we can bolster
    real-time security by interjecting custom account and user role status checks
    to ensure that the authenticated user is authorized to access server-side resources.
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Tokens implement IETF industry standard RFC7519, found at [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519).
  prefs: []
  type: TYPE_NORMAL
- en: A good authorization workflow enables conditional navigation based on a user's
    role so that users are automatically taken to the optimal landing screen; they
    are not shown routes or elements that are not suitable for their roles and if
    by mistake they try to access an authorized path, they're prevented from doing
    so. You must remember that any client-side role-based navigation is merely a convenience
    and is not meant for security. This means that every call made to the server should
    contain the necessary header information, with the secure token, so that the user
    can be reauthenticated by the server, their role independently verified and only
    then they are allowed to retrieve secured data. Client-side authentication can't
    be trusted, which is why password reset screens must be built with a server-side
    rendering technology so that both the user and the server can verify that the
    intended user is interacting with the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sections, we will design a fully featured auth workflow around
    the User data entity, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3edd23f6-b740-4bcf-be64-946397307fa5.png)'
  prefs: []
  type: TYPE_IMG
- en: User entity
  prefs: []
  type: TYPE_NORMAL
- en: Add auth service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by creating an auth service with a real and a fake login provider:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an authentication and authorization service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the service is provided in `app.module`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating a separate folder for the service will organize various related components
    to authentication and authorization, such as the `enum` definition for Role. Additionally,
    we will be able to add an `authService` fake to the same folder, essential for
    writing unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define user roles as an `enum`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Implement a basic authentication service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s build a local authentication service that will enable us to demonstrate
    a robust login form, caching, and conditional navigation concepts based on authentication
    status and a user''s role:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing a JWT decoding library, and for faking authentication,
    a JWT encoding library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Define your imports for `auth.service.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement an `IAuthStatus` interface to store decoded user information, a helper
    interface, and the secure by-default `defaultAuthStatus`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`IAuthUser` is an interface that represents the shape of a typical JWT that
    you may receive from your authentication service. It contains minimal information
    about the user and its role, so it can be attached to the `header` of server calls
    and optionally cached in `localStorage` to remember the user''s login state. In
    the preceding implementation, we''re assuming the default role of a `Manager`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `AuthService` class with a `BehaviorSubject` to anchor the current
    `authStatus` of the user and configure an `authProvider` that can process an `email`
    and a `password` and return an `IServerAuthResponse` in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `fakeAuthProvider` is configured to be the `authProvider` for this
    service. A real auth provider may look like the following code, where users''
    email and password are sent to a POST endpoint, which verifies their information,
    creating and returning a JWT for our app to consume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It is pretty straightforward, since the hard work is done on the server side.
    This call can also be made to a third party.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the API version, `v1`, in the URL path is defined at the service and
    not as part of the `baseUrl`. This is because each API can change versions independently
    from each other. Login may remain `v1` for a long time, while other APIs may be
    upgraded to `v2`, `v3`, and such.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement a `fakeAuthProvider` that simulates the authentication process, including
    creating a fake JWT on the fly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `fakeAuthProvider` implements what would otherwise be a server-side method
    right in the service, so you can conveniently experiment the code while fine-tuning
    your auth workflow. It creates and signs a JWT, with the temporary `fake-jwt-sign` library
    so that we can also demonstrate how to handle a properly-formed JWT.
  prefs: []
  type: TYPE_NORMAL
- en: Do not ship your Angular app with the `fake-jwt-sign` dependency, since it is
    meant to be server-side code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, implement a `transformError` function to handle mixed `HttpErrorResponse`
    and string errors in an observable stream under `common/common.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `login` function that will be called from `LoginComponent`, shown
    in the next section
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add ``import { transformError } from '../common/common'``
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also implement a corresponding `logout` function, which may be called by the
    Logout button in the top toolbar, a failed login attempt, or if an unauthorized
    access attempt is detected by a router auth guard as the user is navigating the
    app, which is a topic covered later in the chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `login` method encapsulates the correct order of operations by calling the `logout` method,
    the `authProvider` with the `email` and `password` information, and throwing errors
    when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The `login` method adheres to the Open/Closed principle, from SOLID design,
    by being open to extension by our ability to externally supply different auth
    providers to it, but it remains closed to modification, since the variance in
    functionality is encapsulated with the auth provider.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will implement the `LoginComponent` so that users can
    enter their username and password information and attempt a login.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the login component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `login` component leverages the `authService` that we just created and implements
    validation errors using reactive forms. The login component should be designed
    in a way to be rendered independently of any other component, because during a
    routing event, if we discover that the user is not properly authenticated or authorized,
    we will navigate them to this component. We can capture this origination URL as
    a `redirectUrl` so that once a user logs in successfully, we can navigate them
    back to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with implementing the routes to the `login` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now implement the component itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As the result of a successful login attempt, we leverage the router to navigate
    an authenticated user to their profile. In the case of an error sent from the
    server via the service, we assign that error to `loginError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an implementation for a login form to capture and validate a user''s
    `email` and `password`, and if there are any server errors, display them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The Login button is disabled until email and password meets client site validation
    rules. Additionally, `<mat-form-field>` will only display one `mat-error` at a
    time, unless you create more space for more errors, so be sure place your error
    conditions in the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: Once you're done implementing the `login` component, you can now update the
    home screen to conditionally display or hide the new component we created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `home.component` to display login when a user opens up the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to import the requisite dependent modules for the code above in
    to your Angular application. It is intentionally left as an exercise for the reader
    to locate and import the missing modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your app should look similar to this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0777c16b-6f65-4c68-86e8-514cb5535817.png)'
  prefs: []
  type: TYPE_IMG
- en: LemonMart with login
  prefs: []
  type: TYPE_NORMAL
- en: There's still some work to be done, in terms of implementing and showing/hiding
    the sidenav menu, profile and logout icons, given the user's authentication status.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conditional navigation is necessary in creating a frustration-free user experience.
    By selectively showing the elements that the user has access to and hiding the
    ones they don't, we allow the user to confidently navigate through the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by hiding the login component after a user logs in to the app:'
  prefs: []
  type: TYPE_NORMAL
- en: On the `home` component, import the `authService` in `home.component`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `authStatus` to a local variable named `displayLogin`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A property getter for `displayLogin` here is necessary, otherwise you may receive
    a Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after
    it was checked message. This error is a side effect of how the Angular component
    life-cycle and change detection works. This behavior may very well change in future
    Angular versions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the `app` component, subscribe to the authentication status and store the
    current value in a local variable named `displayAccountIcons`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `*ngIf` to hide all buttons meant for logged in users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when a user is logged out, your toolbar should look all clean with no
    buttons, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2734fd18-3722-4964-9ee8-1acbaef74920.png)'
  prefs: []
  type: TYPE_IMG
- en: LemonMart toolbar after log in
  prefs: []
  type: TYPE_NORMAL
- en: Common validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we move on, we need to implement validations for `loginForm`. As we
    implement more forms in [Chapter 15](3da8e826-b070-415b-b3ce-d535358db5de.xhtml),
    *Angular App Design and Recipes*, you will realize that it gets tedious, fast,
    to repeatedly type out form validations in either template or reactive forms.
    Part of the allure of reactive forms is that it is driven by code, so we can easily
    extract out the validations to a shared class, unit test, and reuse them:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `validations.ts` file under the `common` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement email and password validations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your password validation needs, you can use a `RegEx` pattern with
    the `Validations.pattern()` function to enforce password complexity rules or leverage
    the OWASP npm package, `owasp-password-strength-test`, to enable pass-phrases
    as well as set more flexible password requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `login` component with the new validations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: UI service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we start dealing with complicated workflows, such as the auth workflow, it
    is important to be able to programmatically display a toast notification for the
    user. In other cases, we may want to ask for a confirmation before executing a
    destructive action with a more intrusive pop-up notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter what component library you use, it gets tedious to recode the same
    boiler plate, just to display a quick notification. A UI service can neatly encapsulate
    a default implementation that can also be customized on a need basis:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `uiService` under `common`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a `showToast` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For a showDialog function, we must implement a basic dialog component:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new `simpleDialog` under the `common` folder provided in `app.module`
    with inline template and styling
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `SimpleDialogComponent` should not have app selector like  `selector:
    ''app-simple-dialog''` since we only plan to use it with `UiService`. Remove this
    property from your component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, implement a `showDialog` function to display the `SimpleDialogComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`ShowDialog` returns an `Observable<boolean>`, so you can implement a follow-on
    action, depending on what selection the user makes. Clicking on OK will return
    `true`, and Cancel will return `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: In `SimpleDialogComponent`, using `@Inject`, we're able to use all variables
    sent by `showDialog` to customize the content of the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to update `app.module.ts` and `material.module.ts` with the various
    dependencies that are being introduced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `login` component to display a toast message after login:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'A toast message will appear after a user logs in, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44e78459-77e7-49ec-9b24-6871bfcd4243.png)'
  prefs: []
  type: TYPE_IMG
- en: Material Snack bar
  prefs: []
  type: TYPE_NORMAL
- en: The `snackBar` will either take the full width of the screen or a portion depending
    on the size of the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Caching with cookie and localStorage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We must be able to cache the authentication status of the logged in user. Otherwise,
    with every page refresh, the user will have go through the login routine. We need
    to update `AuthService` so that it persists the auth status.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main ways to store data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cookie`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localStorage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sessionStorage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookies should not be used to store secure data, because they can be sniffed
    or stolen by bad actors. In addition, cookies can store 4 KB of data and can be
    set to expire.
  prefs: []
  type: TYPE_NORMAL
- en: '`localStorage` and `sessionStorage` are similar to each other. They are protected
    and isolated browser-side stores that allow for storing larger amounts of data
    for your application. You can''t set an expiration date-time on either stores.
    `sessionStorage` values are removed, when the browser window is closed. The values
    survive page reloads and restores.'
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Tokens are encrypted, and they include a timestamp for expiration,
    in essence, countering the weaknesses of `cookie` and `localStorage`. Either option
    should be secure to use with JWTs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing a caching service that can abstract away our method
    of caching authentication information that the `AuthService` can consume:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating an abstract `cacheService` that encapsulates the method of
    caching:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This cache service base class can be used to give caching capabilities to any
    service. It is not the same as creating a centralized cache service that you inject
    into another service. By avoiding a centralized value store, we avoid inter-dependencies
    between various services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `AuthService` to extend the `CacheService` and implement caching of
    the `authStatus`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The technique demonstrated here can be used to persist any kind of data and
    intentionally leverages RxJS events to update the cache. As you may note, we don't
    need to update the login function to call `setItem`, because it already calls
    `this.authStatus.next`, and we just tap in to the data stream. This helps with
    staying stateless and avoiding side effects, by decoupling functions from each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: When initializing the `BehaviorSubject`, take care to handle the `undefined/null`
    case, when loading data from the cache and still provide a default implementation.
  prefs: []
  type: TYPE_NORMAL
- en: You can implement your own custom cache expiration scheme in `setItem` and `getItem`
    functions or leverage a service created by a third party.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going after a high-security application, you may choose to only cache
    the JWT to ensure an additional layer security. In either case, the JWT should
    be cached separately, because the token must be sent to the server in the header
    with every request. It is important to understand how token-based authentication
    works well, to avoid revealing compromising secrets. In the next section, we will
    go over the JWT life cycle to improve your understanding.
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Token life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSON Web Tokens compliment a stateless REST API architecture with an encrypted
    token mechanism that allow for convenient, distributed, and high-performance authentication
    and authorization of requests sent by clients. There are three main components
    of a token-based authentication scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: Client-side, captures login information and hides disallowed actions for a good
    UX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-side, validates that every request is both authenticated and has the
    proper authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auth service, generates and validates encrypted tokens, independently verifies
    authentication and authorization status of user requests from a data store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A secure system presumes that data sent/received between the major components
    mentioned is encrypted in-transit. This means your REST API must be hosted with
    a properly configured SSL certificate, serving all API calls over HTTPS, so that
    user credentials are never exposed between the client and the server. Similarly,
    any database or third-party service call should happen over HTTPS. Furthermore,
    any data store storing passwords should utilize a secure one-way hashing algorithm
    with good salting practices. Any other sensitive user information should be encrypted
    at-rest with a secure two-way encryption algorithm. Following this layered approach
    to security is critical, because attackers will need to accomplish the unlikely
    feat of compromising all layers of security implemented at the same time to cause
    meaningful harm to your business.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next sequence diagram highlights the life-cycle of JWT-based authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/360df2dd-598c-403c-b9de-2037de5585cd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Life-Cycle of JWT-based authentication
  prefs: []
  type: TYPE_NORMAL
- en: Initially, a user logs in by providing their username and password. Once validated,
    the user's authentication status and role is encrypted to a JWT with an expiration
    date and time and is sent back to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Your Angular (or any other SPA) app can cache this token in local or session
    storage securely so that the user isn't forced to login with every request or
    worse yet, we don't store user credentials in the browser. Let's update the authentication
    service so that it can cache the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the service to be able to set, get, decode, and clear the token, as
    shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `setToken` during login and `clearToken` during logout as highlight as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Every subsequent request will contain the JWT in the request header. You should
    secure every API to check for and validate the token received. For example, if
    a user wanted to access their profile, the `AuthService` would validate the token
    to check whether the user authenticated, but a further database call is required
    to check whether the user is also authorized to view the data. This ensures an
    independent confirmation of the users' access to the system and prevents any abuse
    of an unexpired token.
  prefs: []
  type: TYPE_NORMAL
- en: If an authenticated user makes a call to an API, where they don't have the proper
    authorization, say if a clerk wants to get access to a list of all the users,
    then the `AuthService` will return a falsy status and the client will receive
    a 403 Forbidden response, which will be displayed as an error message to the user.
  prefs: []
  type: TYPE_NORMAL
- en: A user can make a request with an expired token; when this happens, a 401 Unauthorized
    response is sent to the client. As a good UX practice, we should automatically
    prompt the user to login again and let them resume their workflow without any
    data loss.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, real security is achieved by a robust server-side implementation
    and any client-side implementation is largely there to enable a good UX around
    good security practices.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP interceptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implement an HTTP interceptor to inject the JWT into the header of every request
    sent to the user and also gracefully handle authentication failures by asking
    the user to log in:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `authHttpInterceptor` under `auth`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that `AuthService` is leveraged to retrieve the token, and the `redirectUrl`
    is being set for the login component after a 401 error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `app` module to provide the interceptor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can observe the interceptor in action, while the app is fetching the `lemon.svg`
    file, in the Chrome Dev Tools | Network tab, here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4d4801c-60db-4e1e-be2c-cdad2bd26183.png)'
  prefs: []
  type: TYPE_IMG
- en: Request header for lemon.svg
  prefs: []
  type: TYPE_NORMAL
- en: Side navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enable mobile-first workflows and provide an easy navigation mechanism to quickly
    jump to desired functionality. Using the authentication service, given a user''s
    current role, only display the links for features they can access. We will be
    implementing the side navigation mock-up, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c72d8326-ae43-469d-876a-fcc533d94668.png)'
  prefs: []
  type: TYPE_IMG
- en: Side navigation mock-up
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the code for the side nav as a separate component, so that
    it is easier to maintain:'
  prefs: []
  type: TYPE_NORMAL
- en: Create and declare a `NavigationMenuComponent` in `app.module`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The side navigation isn't technically required until after a user is logged
    in. However, in order to be able to launch the side navigation menu from the toolbar,
    we need to be able to trigger it from `app.component`. Since this component will
    be simple, we will eagerly load it. To do this lazily, Angular does have a Dynamic
    Component Loader pattern, which has a high implementation overhead that will only
    make sense if multi-hundred kilobyte savings will be made.
  prefs: []
  type: TYPE_NORMAL
- en: '`SideNav` will be triggered from the toolbar, and it comes with a `<mat-sidenav-container>` parent
    container that hosts the `SideNav` itself and the content of the app. So we will
    need to render all app content by placing the `<router-outlet>` inside `<mat-sidenav-content>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Import `MatSidenavModule` and `MatListModule` to material.module
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Define some styles that will ensure that the web app will expand to fill the
    entire page and remain properly scrollable on desktop and mobile scenarios:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Import an `ObservableMedia` service in `AppComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the template with a responsive `SideNav` that will slide over the content
    in mobile or push the content aside in desktop scenarios:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding template leverages Angular Flex Layout media observable for a
    responsive implementation that was injected earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Since the links that will be shown inside the `SiveNav` will be of variable
    length and subject various role-based business rules, it is a good practice to
    implement it in a separate component.
  prefs: []
  type: TYPE_NORMAL
- en: Implement a property getter for `displayAccountIcons` and a `setTimeout` so
    that you can avoid errors like `ExpressionChangedAfterItHasBeenCheckedError`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement navigational links in `NavigationMenuComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`<mat-nav-list>` is functionally equivalent to `<mat-list>`, so you can use
    the documentation for that component for layout purposes. Observe the subheaders
    for Manager, Inventory, and Clerk here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f096272b-e0ed-42f3-a79f-ec26620e9798.png)'
  prefs: []
  type: TYPE_IMG
- en: Manager dashboard showing receipt lookup on desktop
  prefs: []
  type: TYPE_NORMAL
- en: '`routerLinkActive="active-link"` highlights the selected Receipts route, as
    shown in the preceding screenshot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you can see the difference in appearance and behavior on mobile
    devices as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd6e508b-2e56-4e89-921e-610dfc3b4ae0.png)'
  prefs: []
  type: TYPE_IMG
- en: Manager dashboard showing receipt lookup on mobile
  prefs: []
  type: TYPE_NORMAL
- en: Log out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''re caching the login status, we need to implement a log out experience:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `AuthService`, implement a `logout` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `logout` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you note, after a log out, user is navigated back to the home page.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based routing after login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the most elemental and important part of your application. With lazy
    loading, we have ensured only the bare minimum amount of assets will be loaded
    to enable a user to login.
  prefs: []
  type: TYPE_NORMAL
- en: Once a user logs in, they should be routed to the appropriate landing screen
    as per their user role, so they're not guessing how they need to use the app.
    For example, a cashier needs to only access the POS to check out customers, so
    they can automatically be routed to that screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'You find the mock up of the POS screen as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69c5d5f6-adf5-4a80-bf77-e412ca3d9a6f.png)'
  prefs: []
  type: TYPE_IMG
- en: Point-of-Sale screen mock-up
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s ensure that users get routed to the appropriate page after logging in
    by updating the `LoginComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `login` logic to route per role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, clerks and manager are routed to their landing screens to access
    the features they need to accomplish their tasks, as shown earlier. Since we implemented
    a default manager role, the corresponding landing experience will be launched
    automatically. The other side of the coin is intentional and unintentional attempts
    to access routes that a user isn't meant to have access to. In the next section,
    we will learn about router guards that can help check authentication and even
    load requisite data before the form is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Router Guards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Router Guards enable further decoupling and reuse of logic and greater control
    over the component lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the four major guards you will most likely use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CanActivate` and `CanActivateChild`, used for checking auth access to a route'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CanDeactivate`, used to ask permission before navigating away from a route'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Resolve`, allows for pre-fetching of data from route parameters'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CanLoad`, allows for custom logic to execute before loading feature module
    assets'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to the following sections for how to leverage `CanActivate` and `CanLoad` . `Resolve`
    guard will be covered in [Chapter 15](3da8e826-b070-415b-b3ce-d535358db5de.xhtml),
    *Angular App Design and Recipes*.
  prefs: []
  type: TYPE_NORMAL
- en: Auth Guard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Auth Guards enable good UX by allowing or disallowing accidental navigation
    to a feature module or component before it is loaded and any data requests are
    made to the server.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when a Manager logs in, they're automatically routed to the `/manager/home` path. The
    browser will cache this URL, and it will be completely plausible for a clerk to
    accidentally navigate to the same URL. Angular doesn't know whether a particular
    route is accessible to a user or not and, without an `AuthGuard`, it will happily
    render the Manager's home page and trigger server requests that will end up failing.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the robustness of your frontend implementation, every REST API
    you implement should be properly secured server-side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the router so that `ProfileComponent` can''t be activated without
    an authenticated user and the `ManagerModule` won''t load unless a manager is
    logging in using an `AuthGuard`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement an `AuthGuard` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `CanLoad` guard to prevent loading of lazily loaded module, such as
    Manager''s module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, when the `ManagerModule` is being loaded, `AuthGuard` will
    be activated during the `canLoad` event, and the `checkLogin` function will verify
    the authentication status of the user. If the guard returns `false`, the module
    will not be loaded. At this point, we don't have the metadata to check the role
    of the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `CanActivate` guard to prevent activation of individual components,
    such as user''s `profile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the case of `user-routing.module`, `AuthGuard` is activated during the `canActivate` event,
    and the `checkLogin` function controls where this route can be navigated to. Since
    the user is viewing their own profile, there's no need to check the user's role
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `CanActivate` or `CanActivateChild` with an `expectedRole` property to
    prevent activation of components by other users, such as `ManagerHomeComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Inside `ManagerModule`, we can verify whether the user is authorized to access
    a particular route. We can do this by defining some metadata in the route definition,
    like `expectedRole`, which will be passed into the `checkLogin` function by the `canActivate` event.
    If a user is authenticated but their role doesn't match `Role.Manager`, `AuthGuard`
    will return false and the navigation will be prevented.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that both `AuthService` and `AuthGuard` are provided in `app.module`
    and `manager.module` since they used in both contexts
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As always, before moving on ensure that all your tests pass by executing `npm
    test` and `npm run e2e`.
  prefs: []
  type: TYPE_NORMAL
- en: Auth Service Fake and Common Testing Providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to implement an `AuthServiceFake` so that our unit tests pass and use
    a pattern similar to `commonTestingModules` mentioned in [Chapter 12,](b49e4716-d083-4c8c-a083-bcf6cf182a6f.xhtml) *Create
    a Router-First Line-of-Business App*, to conveniently provider this fake across
    our spec files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that our fake will have the same public functions and properties
    as the actual `AuthService`, let''s first start with creating an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Add `IAuthService` to `auth.service.ts`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Make sure `AuthService` implements the interface
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Export `defaultAuthStatus` for reuse
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now we can create a fake that implements the same interface, but provides functions
    that don't have any dependencies to any external authentication system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `auth.service.fake.ts` under `auth`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `common.testing.ts` with `commonTestingProviders`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Observer the use of the fake in `app.component.spec.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The empty `commonTestingProviders` array we created earlier is being concatenated
    with fakes that are specific to `app.component`, so our new `AuthServiceFake`
    should apply automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the spec file for `AuthGuard` shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and apply this technique to all spec files that have a dependency on
    `AuthService` and `UiService`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The notable exception is in `auth.service.spec.ts` where you do *not *want
    to use the fake, since `AuthService` is the class under test, make sure it is
    configure shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition `SimpleDialogComponent` tests require stubbing out some external
    dependencies like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Remember, don't move on until all your tests are passing!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now be familiar with how to create high-quality authentication and
    authorization experiences. We started by going over the importance of completing
    and documenting high-level UX design of our entire app so that we can properly
    design a great conditional navigation experience. We created a reusable UI service
    so that we can conveniently inject alerts into the flow-control logic of our app.
  prefs: []
  type: TYPE_NORMAL
- en: We covered the fundamentals of token-based authentication and JWTs so that you
    don't leak any critical user information. We learned that caching and HTTP interceptors
    are necessary so that users don't have to input their login information with every
    request. Finally, we covered router guards to prevent users from stumbling onto
    screens they are not authorized to use, and we reaffirmed the point that the real
    security of your application should be implemented on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go over a comprehensive list of Angular recipes
    to complete the implementation of our line-of-business app—LemonMart.
  prefs: []
  type: TYPE_NORMAL
