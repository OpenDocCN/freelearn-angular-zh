["```ts\nlet isSaved: boolean = false; \n```", "```ts\nlet price: number = 101; \n```", "```ts\nlet decimal: number = 6; \nlet hex: number = 0xf00d; \nlet binary: number = 0b1010; \nlet octal: number = 0o744; \n```", "```ts\nlet authorName: string = \"Rajesh Gunasundaram\"; \n```", "```ts\nvar even:number[] = [2, 4, 6, 8, 10]; \n```", "```ts\nlet even:Array<number> = [2, 4, 6, 8, 10]; \n```", "```ts\nenum Day {Mon, Tue, Wed, Thu, Fri, Sat, Sun}; \nlet firstDay: Day = Day.Mon; \n```", "```ts\nlet mixedList:any[] = [1, \"I am string\", false]; \nmixedList [2] = \"no you are not\"; \n```", "```ts\nfunction alertMessage(): void { \n    alert(\"This function does not return any value\"); \n} \n```", "```ts\nfunction addCustomer(customerObj: {name: string}) { \n  console.log(customerObj.name); \n} \nlet customer = {id: 101, name: \"Rajesh Gunasundaram\"}; \naddCustomer(customer); \n```", "```ts\ninterface Customer { \n  name: string; \n} \nfunction addCustomer(customerObj: Customer) { \n  console.log(customerObj.name); \n}  \nlet customer = {id: 101, name: \"Rajesh Gunasundaram\"}; \naddCustomer(customer); \nCustomer interface. It only looks for the name property of the string type in the parameter and then allows it if present.\n```", "```ts\ninterface Customer { \n  id: number; \n  name: string; \n  bonus?: number; \n}  \nfunction addCustomer(customer: Customer) {  \n  if (customer.bonus) { \n    console.log(customer.bonus); \n  } \n}  \naddCustomer({id: 101, name: \"Rajesh Gunasundaram\"}); \n```", "```ts\ninterface AddCustomerFunc { \n  (firstName: string, lastName: string); void \n} \n```", "```ts\nlet addCustomer: AddCustomerFunc; \naddCustomer = function(firstName: string, lastName: string) { \n  console.log('Full Name: ' + firstName + ' ' + lastName); \n} \n```", "```ts\naddCustomer = function(fn: string, ln: string) {\nconsole.log('Full Name: ' + fn + ' ' + ln);\n} \n```", "```ts\ninterface CutomerNameArray { \n  [index: number]: string; \n}  \nlet customerNameList: CutomerNameArray; \ncustomerNameList = [\"Rajesh\", \"Gunasundaram\"]; \n```", "```ts\ninterface CustomerInterface { \n    id: number; \n    firstName: string; \n    lastName: string; \n    addCustomer(firstName: string, lastName: string); \n    getCustomer(id: number): Customer; \n}  \nclass Customer implements CustomerInterface { \n    id: number; \n    firstName: string; \n    lastName: string; \n    constructor() { } \n    addCustomer(firstName: string, lastName: string): void { \n        // code to add customer \n    } \n    getCustomer(id: number): Customer { \n        // code to return customer where the id match with id parameter \n    } \n}  \n```", "```ts\ninterface Manager { \n    hasPower: boolean; \n}\ninterface Employee extends Manager { \n    name: string; \n} \nlet employee = <Employee>{}; \nemployee.name = \"Rajesh Gunasundaram\"; \nemployee.hasPower = true; \n```", "```ts\ninterface Customer { \n    (name: string): string; \n    name: string; \n    deleteCustomer(id: number): void; \n} \nlet c: Customer; \nc('Rajesh Gunasundaram'); \nc.name = 'Rajesh Gunasundaram'; \nc.deleteCustomer(101); \n```", "```ts\nclass Customer { \n    name: string; \n    constructor(name: string) { \n        this.name = name; \n    } \n    logCustomer() { \n        console.log('customer name is ' + this.name); \n    } \n}  \nlet customer = new Customer(\"Rajesh Gunasundaram\"); \n```", "```ts\nvar Animal = function() { \n    this.sleep = function() { \n       console.log('sleeping'); \n    } \n    this.eat = function() { \n       console.log('eating'); \n    } \n} \n```", "```ts\nAnimal.prototype.bark = function() { \n    console.log('barking'); \n} \n```", "```ts\nvar a = new Animal(); \na.bark(); \n```", "```ts\nvar Dog = function() { \n    this.bark = new function() { \n       console.log('barking'); \n    } \n} \n```", "```ts\nDog.prototype = Object.create(animal.prototype); \nvar d = new Dog(); \nd.sleep(); \nd.eat(); \n```", "```ts\nclass SimpleCalculator { \n    z: number; \n    constructor() { } \n    addition(x: number, y: number) { \n        z = x + y; \n    } \n    subtraction(x: number, y: number) { \n        z = x - y; \n    } \n}  \nclass ComplexCalculator extends SimpleCalculator { \n    constructor() { super(); } \n    multiplication(x: number, y: number) { \n        z = x * y; \n    } \n    division(x: number, y: number) { \n        z = x / y; \n    } \n} \nvar calculator = new ComplexCalculator(); \ncalculator.addition(10, 20); \ncalculator.Substraction(20, 10); \ncalculator.multiplication(10, 20); \ncalculator.division(20, 10); \n```", "```ts\nclass SimpleCalculator { \n    private x: number; \n    private y: number; \n    z: number; \n    constructor(x: number, y: number) { \n       this.x = x; \n       this.y = y; \n    } \n    addition() { \n        z = x + y; \n    } \n    subtraction() { \n        z = x - y; \n    } \n} \nclass ComplexCalculator { \n    z: number; \n    constructor(private x: number, private y: number) { } \n    multiplication() { \n        z = this.x * this.y; \n    } \n    division() { \n        z = this.x / this.y; \n    } \n} \n```", "```ts\nvar updateCustomerNameAllowed = true; \nClass Customer { \n    Private _name: string; \n    get name: string { \n          return this._name; \n    } \n    set name(newName: string) { \n          if (updateCustomerNameAllowed == true) { \n                this._name = newName; \n          } \n          else { \n                alert(\"Error: Updating Customer name not allowed!\"); \n          } \n    } \n} \n```", "```ts\nclass Customer { \n     static bonusPercentage = 20; \n     constructor(public salary: number) {  } \n      calculateBonus() { \n          return this.salary * Customer.bonusPercentage/100; \n     } \n} \nvar customer = new Customer(10000); \nvar bonus = customer.calculateBonus(); \n```", "```ts\nnamespace Inventory { \n      Class Product { \n             constructor (public name: string, public quantity: number) {   } \n      } \n      // product is accessible \n      var p = new Product('mobile', 101); \n} \n// Product class is not accessible outside namespace \nvar p = new Inventory.Product('mobile', 101); \n```", "```ts\nnamespace Inventory { \n      export Class Product { \n             constructor (public name: string, public quantity: number) {   } \n      } \n} \n// Product class is now accessible outside Inventory namespace \nvar p = new Inventory.Product('mobile', 101); \n```", "```ts\n/// <reference path=\"Inventory.ts\" /> \n```", "```ts\nImport { inv } from \"./Inventory\"; \nvar p = new inv.Product('mobile', 101); \n```", "```ts\n//Named function \nfunction multiply(a, b) { \n    return a * b; \n} \n//Anonymous function \nvar result = function(a, b) { return a * b; }; \n```", "```ts\nvar multiply(a: number, b: number) => number =  \n          function(a: number, b: number): number { return a * b; }; \n```", "```ts\nfunction CutomerName(firstName: string, lastName: string, middleName?: string) { \n    if (middleName) \n        return firstName + \" \" + middleName + \" \" + lastName; \n    else \n        return firstName + \" \" + lastName; \n} \n//ignored optional parameter middleName \nvar customer1 = customerName(\"Rajesh\", \"Gunasundaram\");  \n//error, supplied too many parameters  \nvar customer2 = customerName(\"Scott\", \"Tiger\", \"Lion\", \"King\");   \n//supplied values for all \nvar customer3 = customerName(\"Scott\", \"Tiger\", \"Lion\");   \n```", "```ts\nfunction CutomerName(firstName: string, lastName: string, middleName: string = 'No Middle Name') { \n    if (middleName) \n        return firstName + \" \" + middleName + \" \" + lastName; \n    else \n        return firstName + \" \" + lastName; \n} \n```", "```ts\nfunction clientName(firstClient: string, ...restOfClient: string[]) { \n   console.log(firstClient + \" \" + restOfClient.join(\" \")); \n} \nclientName (\"Scott\", \"Steve\", \"Bill\", \"Sergey\", \"Larry\"); \n```", "```ts\nfunction returnNumberReceived(arg: number): number { \n    return arg; \n} \nfunction returnStringReceived(arg: string): string { \n    return arg; \n} \n```", "```ts\nfunction returnAnythingReceived (arg: any): any { \n    return arg; \n} \n```", "```ts\nfunction returnWhatReceived<T>(arg: T): T { \n    return arg; \n} \n```", "```ts\nvar stringOutput = returnWhatReceived<string>(\"return this\"); // type of output will be 'string' \nvar numberOutput = returnWhatReceived<number>(101); // type of output will be number \n```", "```ts\ninterface GenericFunc<T> { \n    (arg: T): T; \n} \nfunction func<T>(arg: T): T { \n    return arg; \n} \nvar myFunc: GenericFunc<number> = func; \n```", "```ts\nclass GenericClass<T> { \n    add: (a: T, b: T) => T; \n}  \nvar myGenericClass = new GenericClass<number>(); \nmyGenericClass.add = function(a, b) { return a + b; }; \n```", "```ts\n@authorize decorator on any other class:\n```", "```ts\nfunction authorize(target) { \n    // check the authorization of the use to access the \"target\" \n} \n```", "```ts\ndeclare type ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void; \n```", "```ts\n@freezed \nclass Customer {  \n  public firstName: string; \n  public lastName: string; \n  constructor(firstName : string, lastName : string) {  \n    this.firstName = firstName; \n    this.lastName = lastName; \n  } \n} \nfreezed decorator:\n```", "```ts\nfunction freezed(target: any) { \n    Object.freeze(target); \n} \n```", "```ts\nclass Hello { \n    @logging \n    increment(n: number) { \n        return n++; \n    } \n} \nlogging function:\n```", "```ts\nfunction logging(target: Object, key: string, value: any) { \n            value = function (...args: any[]) { \n            var result = value.apply(this, args); \n            console.log(JSON.stringify(args)) \n            return result; \n        } \n    }; \n} \n```", "```ts\nclass Customer {  \n  private _firstname: string; \n  private _lastname: string; \n  constructor(firstname: string, lastname: string) { \n        this._firstname = firstname; \n        this._lastname = lastname; \n  } \n  @logging(false) \n  get firstname() { return this._firstname; } \n  @logging(false) \n  get lastname() { return this._lastname; } \n} \n@logging decorator:\n```", "```ts\nfunction logging(value: boolean) { \n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) { \n        descriptor.logging = value; \n    }; \n} \n```", "```ts\ndeclare type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void; \nfirstname property is decorated with the @hashify property decorator:\n```", "```ts\nclass Customer {  \n  @hashify \n  public firstname: string; \n  public lastname: string; \n  constructor(firstname : string, lastname : string) {  \n    this.firstname = firstname; \n    this.lastname = lastname; \n  } \n} \n@hashify property decorator function:\n```", "```ts\nfunction hashify(target: any, key: string)\n { \n  var _value = this[key];\n  var getter = function ()\n    { \n        return '#' + _value; \n    }; \n  var setter = function (newValue)\n   { \n      _value = newValue; \n    }; \n  if (delete this[key])\n { \n    Object.defineProperty(target, key,\n { \n      get: getter, \n      set: setter, \n      enumerable: true, \n      configurable: true \n    }); \n  } \n} \n```", "```ts\ndeclare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void; \n```", "```ts\nclass Customer { \n    constructor() {    } \n    getName(@logging name: string) { \n        return name; \n    } \n} \n```", "```ts\nfunction logging(target: any, key : string, index : number) {  \n  console.log(target); \n  console.log(key); \n  console.log(index); \n} \n```", "```ts\nimport {Component} from '@angular/core' \n@Component({ \n  selector: 'my-component', \n  template: '<h1>Hello my Component</h1>' \n}) \nexport class MyComponent { \n  constructor() {  } \n} \n```"]