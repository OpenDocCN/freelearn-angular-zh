- en: Prepare Angular App for Production Release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don't ship it, it never happened. In the previous chapter, you created
    a local weather application that can retrieve current weather data. You have created
    some amount of value; however, if you don't put your app on the web, you end up
    creating zero value. Delivering something is difficult, delivering something to
    production is even more difficult. You want to follow a strategy that results
    in a reliable, high quality, and flexible release.
  prefs: []
  type: TYPE_NORMAL
- en: The app we created in [Chapter 9](7c897af2-bc94-4c2f-a5ad-8ae0b4bc0508.xhtml), *Create
    a Local Weather Web Application*, is fragile. We need to be able to deliver the
    frontend app separately from the backend app, which is a very important decoupling
    to retain the flexibility of being able to push separate app and server updates.
    In addition, decoupling will ensure that as the various tools and technologies
    in your application stack inevitably fall out of support or favor, you will be
    able to replace your frontend or backend without a full rewrite of your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Guard against null data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerize the app using Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy the app on the web using Zeit Now
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Required software is as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Community Edition Version 17.12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zeit Now Account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null guarding in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JavaScript, the `undefined` and `null` values are a persistent issue that
    must be proactively dealt with every step of the way. There are multiple ways
    to guard against `null` values in Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: Property Initialization
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Safe Navigation Operator `?.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Null Guarding with `*ngIf`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Property initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In statically-typed languages such as Java, it is drilled into you that proper
    variable initialization/instantiation is the key to error free operation. So let''s
    try that in `CurrentWeatherComponent` by initializing current with default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome of these changes will reduce console errors from 12 to 3, at which
    point you will only be seeing API call related errors. However, the app itself
    will not be in a presentable state, as you can see below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f84089f-b267-456c-880f-f229a904a8e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Results of Property Initialization
  prefs: []
  type: TYPE_NORMAL
- en: To make this view presentable to user, we will have to code for default values
    on every property on the template. So by fixing the null guarding issue by initialization,
    we created a default value handling issue. Both the initialization and the default
    value handling are *O(n)* scale tasks for developers. At its best, this strategy
    will be annoying to implement and at its worst, highly ineffective and error prone,
    requiring, at minimum, *O(2n)* effort per property.
  prefs: []
  type: TYPE_NORMAL
- en: Safe navigation operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular implements the safe navigation operation `?.` to prevent unintended
    traversals of undefined objects. So, instead of writing initialization code and
    having to deal with template values, let''s just update the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we didn''t have to make up defaults, and we let Angular deal with
    displaying undefined bindings. You will note that just like the initialization
    fix, the errors have been reduced from 12 to 3\. The app itself is in a somewhat
    better shape. There''s no more confusing data being displayed; however, it still
    is not in a presentable state, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf719932-a5c2-4a64-ba10-861ad126010e.png)'
  prefs: []
  type: TYPE_IMG
- en: Results of Safe Navigation Operator
  prefs: []
  type: TYPE_NORMAL
- en: You can probably imagine ways where the safe navigation operator can come in
    handy, in far more complicated scenarios. However, when deployed at scale, this
    type of coding still requires, at minimum, *O(n)* level of effort to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Null guarding with *ngIf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea strategy will be to use `*ngIf`, which is a structural directive, meaning
    Angular will stop traversing DOM tree elements beyond a falsy statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CurrentWeather` component, we can easily check to see whether the `current`
    variable is null or undefined before attempting to render the template:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the topmost `div` element with `*ngIf` to check whether `current` is
    an object, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now observe the console log and that no errors are being reported. You always
    ensure that your Angular application reports zero console errors. If you're still
    seeing errors in the console log, ensure that you have correctly reverted the
    `OpenWeather` URL to its correct state or kill and restart your `npm start` process.
    I highly recommend that you resolve any console errors before moving on. Once
    you've fixed all errors, ensure that you commit your code again.
  prefs: []
  type: TYPE_NORMAL
- en: Commit your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Containerizing the app using Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker [docker.io](http://docker.io) is an *open platform* for developing,
    shipping, and running applications. Docker combines a *lightweight* container
    virtualization platform with workflows and tooling that help manage and deploy
    applications. The most obvious difference between **Virtual Machines** (**VMs**)
    and Docker containers are that VMs usually are dozens of gigabytes in size and
    require gigabytes of memory, whereas containers are megabytes in disk and memory
    size requirements. Furthermore, the Docker platform abstracts away host **operating
    system** (**OS**) level configuration settings, so every piece of configuration
    that is needed to successfully run an application is encoded within the human-readable
    Dockerfile format, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding file describes a new container that inherits from a container
    named `duluca/minimal-node-web-server`, changes the working directory to `/usr/src/app`,
    and then copies the contents of `dist` folder from your development environment
    into the container's `public` folder. In this case, the parent image is configured
    with an Express.js server to act as a web server to serve the content inside the
    `public` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following diagram for a visual representation of what''s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e85a11d3-ea47-4e80-804d-ae9267b23407.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Context of a Docker Image
  prefs: []
  type: TYPE_NORMAL
- en: At the base layer is our host OS, such as Windows or macOS that runs the Docker
    runtime, which will be installed in the next section. The Docker runtime is capable
    of running self-contained Docker images, which is defined by the aforementioned
    `Dockerfile`. `duluca/minimal-node-web-server` is based off of the lightweight
    Linux operating system Alpine. Alpine is a completely pared down version of Linux
    that doesn't come with any GUI, drivers or even most CLI tools you may expect
    from a Linux system. As a result, the OS is around only ~5 MB in size. The base
    package then installs Node.js, which itself is around ~10 MB in size and my custom
    Node.js-based Express.js web server, resulting in a tiny ~15 MB image. The Express
    server is configured to serve the contents of the `/usr/src/app` folder. In the
    preceding `Dockerfile`, we merely copy the contents of the `/dist` folder in our
    development environment and place it into the `/usr/src/app` folder. We will later
    build and execute this image, which will run our Express web server containing
    the output of our `dist` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of Docker is that you can navigate to [https://hub.docker.com](https://hub.docker.com),
    search for `duluca/minimal-node-web-server`, read its `Dockerfile`, and trace
    its origins all the way back to the original base image that is the foundation
    of the web server. I encourage you to vet every Docker image you use in this manner
    to understand what exactly it brings to the table for your needs. You may find
    it either overkill or has features you never knew about that can make your life
    a lot easier. Note that the parent images require a specific version of `duluca/minimal-node-web-server` at `8.11.1`.
    This is quite intentional, and as the reader, you should choose the latest available
    version of a Docker image you find. However, if you don't specify a version number,
    you will always get the latest version of the image. As more versions of an image
    is published, you may pull a future version that may break your application. For
    this reason, always specify a version number for images you're depending on.
  prefs: []
  type: TYPE_NORMAL
- en: 'One such case is the HTTPS redirection support that is baked into `duluca/minimal-node-web-server`.
    You can spend countless hours trying to set up a nginx proxy to do the same thing,
    when all you need to do is add the following line to your Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Just like npm packages, Docker can bring great convenience and value, but you
    must take care to understand the tools you are working with.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 16](7ccc1261-21e7-44b9-aaf8-0079360288e7.xhtml), *Highly-Available
    Cloud Infrastructure on AWS,* we mention the use of a lower footprint docker image
    based on Nginx. If you're comfortable configuring `nginx`, you can use `duluca/minimal-nginx-web-server`
    as your base image.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to be able to build and run containers, you must first install the
    Docker execution environment on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Windows support of Docker can be challenging. You must have a PC with a CPU
    that supports virtualization extensions, which is not a guarantee on laptops.
    You must also have a Pro version of Windows with Hyper-V enabled. On the flip
    side, Windows Server 2016 has native support for Docker, which is an unprecedented
    amount of support shown by Microsoft toward the industry initiative to adopt Docker
    and containerization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Docker by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Execute `docker -v` to verify the installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up Docker scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s configure some Docker scripts that you can use to automated the
    building, testing, and publishing of your container. I have developed a set of
    scripts called **npm Scripts for Docker** that work on Windows 10 and macOS. You
    can get the latest version of these scripts at [bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker):'
  prefs: []
  type: TYPE_NORMAL
- en: Sign up for a Docker Hub account on [https://hub.docker.com/](https://hub.docker.com/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a public (free) repository for your application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfortunately, at the time of publication, Zeit doesn't support private Docker
    Hub repositories, so your only alternative is to publish your container publicly.
    If your image must remain private, I encourage you to set up an AWS ECS environment
    as described in [Chapter 16](7ccc1261-21e7-44b9-aaf8-0079360288e7.xhtml), *Highly-Available
    Cloud Infrastructure on AWS*. You can keep tabs on the issue by visiting Zeit
    Now's documentation at [zeit.co/docs/deployment-types/docker](https://zeit.co/docs/deployment-types/docker).
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `package.json` to add a new config property with the following configuration
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The namespace will be your DockerHub username. You will be defining what your
    repository is called during creation. An example image repository variable should
    look like `duluca/localcast-weather`. The image name is for easy identification
    of your container, while using Docker commands such as `docker ps`. I will call
    mine just `localcast-weather`. The port will define which port should be used
    to expose your application from inside the container. Since we use `5000` for
    development, pick a different one, like `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Add Docker scripts to `package.json` by copy-pasting the scripts from [bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker).
    Here's an annotated version of the scripts that explains each function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that with npm scripts, the `pre` and `post` keywords are used to execute
    helper scripts, respectively, before or after the execution of a given script
    and scripts are intentionally broken into smaller pieces to make it easier to
    read and maintain them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`npm run docker:build` will build your Angular application in `pre`, then build
    the Docker image using the `docker image build` command and tag the image with
    a version number in post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`npm run docker:tag` will tag an already built Docker image using the version
    number from the `version` property in `package.json` and the `latest` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`npm run docker:run` will remove any existing, prior version of an image and
    run the already built image using the `docker run` command. Note that the `imagePort`
    property is used as the external port of the Docker image, which is mapped to
    the internal port of the image that the Node.js server listens to, port `3000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`npm run docker:publish` will publish a built image to the configured repository,
    in this case, Docker Hub, using the `docker image push` command. First, the versioned
    image is published, followed by one tagged with `latest` in post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`npm run docker:clean` will remove a previously built version of the image
    from your system, using the `docker rm -f` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`npm run docker:taillogs` will display the internal console logs of a running
    Docker instance using the `docker log -f` command, a very useful tool when debugging
    your Docker instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`npm run docker:open:win` or `npm run docker:open:mac` will wait for 2 seconds
    and then launch the browser with the correct URL to your application using the
    `imagePort` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`npm run docker:debug` will build your image and run an instance of it in `pre`,
    open the browser, and then start displaying the internal logs of the container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install two development dependencies that are needed to ensure cross-platform
    functionality of the scripts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Customize the pre-build script to execute unit and e2e tests before building
    the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `npm run build` is provided the `--prod` argument, which achieves
    two things:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Development time payload of ~2.5 MB is optimized down to ~73kb or less
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The configuration items defined in `src/environments/environment.prod.ts`
    is used at runtime
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `src/environments/environment.prod.ts` to look like using your own `appId`
    from `OpenWeather`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We are modifying how `npm test` is executed, so the tests are run only once
    and the tool stops executing. The `--watch=false` option is provided to achieve
    this behavior, as opposed to the development-friendly default continuous execution
    behavior. In addition `npm run build` is provided with `--output-path dist` to
    ensure that `index.html` is published at the root of the folder.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `Dockerfile` with no file-extensions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the `Dockerfile`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to inspect the contents of your `dist` folder. Ensure that `index.html`
    is at the root of `dist`. Otherwise ensure that your `Dockerfile` copies the folder
    that has `index.html` at its root.
  prefs: []
  type: TYPE_NORMAL
- en: Execute `npm run predocker:build` to ensure that your application changes have
    been successful
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm run docker:build` to ensure that your image builds successfully
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While you can run any of the provided scripts individually, you really only
    need to remember two of them going forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '**npm run docker:debug **will test, build, tag, run, tail and launch your containerize
    app in a new browser window for testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**npm run docker:publish **will publish the image you just built and test to
    the online Docker repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Execute `docker:debug` in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You will note that the scripts display errors in the Terminal window. These
    are not necessarily indicators of a failure. The scripts are not polished, so
    they attempt both Windows and macOS compatible scripts parallelly, and during
    a first build, the clean command fails, because there's nothing to clean. By the
    time you read this, I may have published better scripts; if not, you're more than
    welcome to submit a pull request.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful `docker:debug` run should result in a new in-focus browser window
    with your application and the server logs being tailed in the terminal, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You should always run `docker ps` to check whether your image is running, when
    it was last updated, or if it is clashing with the existing images claiming the
    same port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute `docker:publish` in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You should observe a successful run in the Terminal window like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Over time, your local Docker cache may grow to a significant size, that is,
    on my laptop, roughly 40 GB over two years. You can use the `docker image prune`
    and `docker container prune` commands to reduce the size of your cache. For more
    detailed information, refer to the documentation at [https://docs.docker.com/config/pruning](https://docs.docker.com/config/pruning).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look into an easier way to interact with Docker next.
  prefs: []
  type: TYPE_NORMAL
- en: Docker extension in VS Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way to interact with Docker images and containers is through VS Code.
    If you have installed the `PeterJausovec.vscode-docker` Docker extension, as suggested
    in [Chapter 9](7c897af2-bc94-4c2f-a5ad-8ae0b4bc0508.xhtml)*, Create a Local Weather
    Web Application*, you will see an expandable title named DOCKER in the Explorer
    pane of VS Code, as pointed out with an arrow in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40d5e5e1-2f87-4b8e-af8a-fccc3466b3c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Docker extension in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through some of the functionality provided by the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Images** contains a list of all the container snapshots that exist on your
    system'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-clicking on a Docker image brings up a context menu to run various operations
    on it, like run, push and tag
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Containers** list all executable Docker containers that exist on your system,
    which you start, stop or attach to'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Registries** display the registries that you''re configured to connect to,
    like DockerHub or AWS Elastic Container Registry'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the extension makes it easier to interact with Docker, **npm Scripts for
    Docker** automate a lot of the chores related to building, tagging and testing
    and image. They are cross-platform and will work equally well in a continuous
    integration environment.
  prefs: []
  type: TYPE_NORMAL
- en: You may find it confusing to interact with npm scripts in general through the
    CLI. Let's look at VS Code's npm script support next.
  prefs: []
  type: TYPE_NORMAL
- en: NPM Scripts in VS Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'VS Code provides support for npm scripts out of the box. In order to enable
    npm script explorer, open VS Code settings and ensure that the `"npm.enableScriptExplorer":
    true` property is present. Once you do, you will see an expandable title named NPM
    SCRIPTS in the Explorer pane, as pointed out with an arrow here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86f456ab-00f5-4eed-aff6-74117f03454c.png)'
  prefs: []
  type: TYPE_IMG
- en: NPM Scripts in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: You can click on any script to launch the line that contains the script in `package.json`
    or right-click and select Run to execute the script.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying containerized app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If delivering something to production is difficult from a coding perspective,
    it is extremely difficult to do it right from an infrastructure perspective. In
    the later chapters, I will cover how to provision a world-class AWS **Elastic
    Container Service** (**ECS**) infrastructure for your applications, but that won't
    help if you need to quickly demonstrate an idea. Enter, Zeit Now.
  prefs: []
  type: TYPE_NORMAL
- en: Zeit Now
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zeit Now, [https://zeit.co/now](https://zeit.co/now), is a multi-cloud service
    that enables real-time global deployments of applications directly from the CLI.
    Now works with applications that either correctly implement `package.json` or
    a `Dockerfile`. Even though we have done both, we will prefer to deploy our Docker
    image, because a lot more magic is applied behind the scenes to make a `package.json`
    deployment work, whereas your Docker image can be deployed anywhere, including
    AWS ECS.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Now CLI tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s configure Zeit Now to work on your repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Zeit Now by executing `npm i -g now`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure correct installation by executing `now -v`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder under `local-weather-app` called `now`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `Dockerfile` under the new `now` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the file to pull from the image you just published:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, execute the `now` command in your terminal and follow the instructions
    to the finish configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Deploying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deploying on Zeit Now is very easy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change your working directory to `now` and execute the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Terminal window, the tool will report its progress and the URL from
    which you can access your now published app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to the URL listed on the second line and verify the publication of
    your app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that if you've made a configuration error along the way, your browser may
    display an error saying This page is trying to load unsafe scripts, allow and
    reload to see your app.
  prefs: []
  type: TYPE_NORMAL
- en: You can explore Zeit Now's paid features, which allow for advanced features
    such as automated scaling for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you are app is live on the internet!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to best avoid Angular console errors by guarding
    against null data. You configured your system to work with Docker and successfully
    containerized your web application with its own dedicated web server. You configured
    your project with npm scripts for Docker that can be leveraged by any team member.
    Finally, you have successfully delivered a web application in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know what takes to build a production-ready Angular application that
    is reliable, resilient, and containerized to allow for a flexible deployment strategy.
    In the next chapter, we will improve the apps feature set and make it look great
    using Angular Material.
  prefs: []
  type: TYPE_NORMAL
