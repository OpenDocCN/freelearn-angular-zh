["```ts\nexport interface Observer{ \n\n   notify(); \n} \n\n```", "```ts\nexport class HumanObserver implements Observer{ \n\n   constructor(private name:string){} \n\n   notify(){ \n\n               console.log(this.name, 'Notified'); \n   } \n} \n\n```", "```ts\nprivate name: string; \n\nconstructor(name:string){  \n      this.name = name; \n} \n\n```", "```ts\nexport class Subject{ \n\n   private observers:Observer[] = []; \n\n   /** \n   * Adding an observer to the list of observers \n   */ \n   attachObserver(observer:Observer):void{ \n\n               this.observers.push(observer); \n   } \n\n   /** \n   * Detaching an observer \n   */ \n   detachObserver(observer:Observer):void{\n      let index:number = this.observers.indexOf(observer);\n      if(index > -1){\n          this.observers.splice(index, 1);\n        }\n      else{\n       throw \"Unknown observer\";\n       }\n} \n\n   /** \n   * Notify all the observers in this.observers \n   */ \n   protected notifyObservers(){\n   for (var i = 0; i < this.observers.length; ++i) {  \n      this.observers[i].notify();\n       } \n    } \n} \n\n```", "```ts\nexport class IMDB extends Subject{ \n\n   private movies:string[] = []; \n\n   public addMovie(movie:string){ \n\n         this.movies.push(movie); \n         this.notifyObservers(); \n   } \n} \n\n```", "```ts\nlet imdb:IMDB = new IMDB(); \nlet mathieu:HumanObserver = new HumanObserver(\"Mathieu\"); \nimbd.attachObserver(mathieu); \nimbd.addMovie(\"Jaws\"); \n\n```", "```ts\n$ npm install -g  typescript ts-node\n$ ts-node myFile.ts\n\n```", "```ts\nimdb.detachObserver(mathieu); \nimdb.addMovie(\"Die Hard\"); \n\n```", "```ts\nexport interface Observer{ \n\n   notify(value?:any, subject?:Subject); \n} \n\nexport class HumanObserver implements Observer{ \n\n   constructor(private name:string){} \n\n   notify(value?:any, subject?:Subject){ \n\n         console.log(this.name, 'received', value, 'from', subject); \n   } \n} \n\n```", "```ts\nexport class Subject{ \n\n   private observers:Observer[] = []; \n\n   attachObserver(oberver:Observer):void{ \n\n         this.obervers.push(oberver); \n   } \n\n   detachObserver(observer:Observer):void{ \n         let index:number = this.obervers.indexOf(observer); \n         if(index > -1){ \n         this.observers.splice(index, 1); \n\n         }else{ \n\n         throw \"Unknown observer\"; \n         } \n   } \n\n   protected notifyObservers(value?:any){ \n\n         for (var i = 0; i < this.obervers.length; ++i) { \n\n         this.observers[i].notify(value, this); \n         } \n   } \n} \n\nexport class IMDB extends Subject{ \n\n   private movies:string[] = []; \n\n   public addMovie(movie:string){ \n\n         this.movies.push(movie); \n         this.notifyObservers(movie); \n   } \n} \n\n```", "```ts\n Mathieu received Jaws from IMDB { \n\n  observers: [ HumanObserver { name: 'Mathieu' } ], \n  movies: [ 'Jaws' ] } \n\n```", "```ts\n{ \n     \"movie_id\" : 1, \n     \"title\" : \"Iron Man\", \n     \"phase\" : \"Phase One: Avengers Assembled\", \n     \"category_name\" : \"Action\", \n     \"release_year\" : 2015, \n     \"running_time\" : 126, \n     \"rating_name\" : \"PG-13\", \n     \"disc_format_name\" : \"Blu-ray\", \n     \"number_discs\" : 1, \n     \"viewing_format_name\" : \"Widescreen\", \n     \"aspect_ratio_name\" : \" 2.35:1\", \n     \"status\" : 1, \n     \"release_date\" : \"May 2, 2008\", \n     \"budget\" : \"140,000,000\", \n     \"gross\" : \"318,298,180\", \n     \"time_stamp\" : \"2015-05-03\" \n}, \n\n```", "```ts\nIMDBAPI.fetchOneById(1); \nIMDBAPI.fetchByFields(MovieFields.release_date, 2015); \n\n```", "```ts\n    ng new angular-observable\n    ng init\n    ng serve\n\n```", "```ts\nexport class Movie { \n\n   public constructor( \n         private _movie_id:number, \n         private _title: string, \n         private _phase: string, \n         private _category_name: string, \n         private _release_year: number, \n         private _running_time: number, \n         private _rating_name: string, \n         private _disc_format_name: string, \n         private _number_discs: number, \n         private _viewing_format_name: string, \n         private _aspect_ratio_name: string, \n         private _status: string, \n         private _release_date: string, \n         private _budget: number, \n         private _gross: number, \n         private _time_stamp:Date){ \n   } \n\n   public toString = () : string => { \n\n         return `Movie (movie_id: ${this._movie_id}, \n         title: ${this._title}, \n         phase: ${this._phase}, \n         category_name: ${this._category_name}, \n         release_year: ${this._release_year}, \n         running_time: ${this._running_time}, \n         rating_name: ${this._rating_name}, \n         disc_format_name: ${this._disc_format_name}, \n          number_discs: ${this._number_discs}, \n         viewing_format_name: ${this._viewing_format_name}, \n         aspect_ratio_name: ${this._aspect_ratio_name}, \n         status: ${this._status}, \n         release_date: ${this._release_date}, \n         budget: ${this._budget}, \n         gross: ${this._gross}, \n         time_stamp: ${this._time_stamp})`; \n\n   } \n   //GETTER \n   //SETTER \n} \n\nexport enum MovieFields{ \n   movie_id, \n   title, \n   phase, \n   category_name, \n   release_year, \n   running_time, \n   rating_name, \n   disc_format_name, \n   number_discs, \n   viewing_format_name, \n   aspect_ratio_name, \n   status, \n   release_date, \n   budget, \n   gross, \n   time_stamp \n} \n\n```", "```ts) and the `${}` syntax that allows the concatenation of strings and different variables.\n\nThen, we have an enumerator `MovieFields`, which will allow us to restrict the searchable field.\n\nMoving on, we need to generate the `IMDBAPI` class. As the `IMDBAPI` class will be potentially used everywhere in our program, we will make it a service. The advantage is that services can be injected into any component or directive. Moreover, we can choose whether we want Angular2 to create an instance of the `IMDBAPI` per injection or always inject the same instance. If the provider for the `IMDBAPI` is created at the application level, then the same instance of the `IMDBAPI` will be served to anyone requesting it. At the component level, however, a new instance of `IMDBAPI` will be created and served to the component each time said component is instantiated. In our case, it makes more sense to have only one instance of the `IMDBAPI`, as it will not have any particular states that are susceptible to change from component to component. Let's generate the `IMDBAPI` service (`ng g s services`/`IMDBAPI`) and implement the two methods we defined earlier:\n\n```", "```ts\n\nHere's `IMDBAPIService` with the `fetchOneById` method:\n\n```", "```ts\n\n# Understanding the implementation\n\nLet's break it down chunk by chunk. First, the declaration of the service is pretty standard:\n\n```", "```ts\n\nServices are injectable. Consequently, we need to import and add the `@Injectable` annotation. We also import `Http`, `Movie`, `MovieFields`, `Observable`, and the operators of RxJS. **RxJS** stands for **Reactive Extensions for JavaScript**. It is an API to do `Observer`, iterator, and functional programming. When it comes to asynchronism in Angular2, you rely on RxJS for the most part.\n\nOne important thing to note is that we use RxJS 5.0, which is a complete rewrite, based on the same concept as RxJS 4.0.\n\nThe `IMDBAPIService` also has a reference to the path of our JSON file and a constructor to receive an injection of the `http` service. On the implementation of the `fetchOneById` method, we can see four distinct operations chained with each other: `get`, `flatMap`, `filter`, and `map`.\n\n*   Get returns an `Observable` onto the body of the `http` request.\n*   `flatMap` transforms the get `Observable` by applying a function that you specify to each item emitted by the source `Observable`, where that function returns an `Observable` that itself emits items. `flatMap` then merges the emissions of these resulting observables, emitting these merged results as its sequence. In our case, it means that we will apply the next two operations (that is `filter` and `map`) on all the items received from the `http` get.\n*   `filter` checks if the ID of the current movie is the one we are looking for\n*   `map` transforms the JSON representation of a movie into the `typescript` representation of a movie (that is the `Movie` class).\n\nThis last operation, while counter-intuitive, is mandatory. Indeed, one could think that the JSON representation and the `typescript` representation are identical, as they own the same fields. However, the `typescript` representation, also to its properties, defines functions such as `toString`, the getters, and the setters. Removing the map would return an `Object` instance--containing all the fields of a `Movie` without being one. Also, a typecast will not help you there. Indeed, the `typescript` transpiler will allow you to cast an `Object` into a `Movie`, but it still won't have the methods defined in the `Movie` class, as the concept of static typing disappears when the `typescript` is transpiled in JavaScript. The following would transpile fail at execution time with; `movie.movie_id(25)` TypeError: `movie.movie_id` is not a function at `Object.<anonymous>`.\n\n```", "```ts\n\nNow, if we want to use our `IMDB` service, further modifications are required in the code that was generated by the Angular CLI. First, we need to modify `app.module.ts` so it looks like this:\n\n```", "```ts\n\nThe lines in bold represent what have been added. We import our `IMDBAPIService` and `HTTP_PROVIDERS`. Both providers are declared at the application level, meaning that the instance that will be injected in the component or directive will always be the same.\n\nThen, we modify the `app.component.ts` file that was generated and add the following:\n\n```", "```ts\n\nOnce again, the bold lines of code represent the lines that were added in comparison to the generated file. We have added several properties to the `AppComponent`: movies, error, and finished. The first property is an array of Movie that will store the result of our queries, the second and the third flag for error and termination. In the constructor, we have an injection of the `IMDBAPIService`, and we subscribe to the result of the `fetchOneById` method. The `subscribe` method expects three callbacks:\n\n*   `Observer`: Receive the value yielded by the `Observer` method. It is the RxJs equivalent of the `notify()` method we saw earlier in this chapter.\n*   `onError` (Optional): Triggered if the `Observer` object yields an error.\n*   `onComplete` (Optional): Triggered on completion.\n\nFinally, we can modify the `app.component.html` file to map the movies property of the `AppComponent` array:\n\n```", "```ts\n\nThe produced output of our code is:\n\n![](img/4ad5912d-0990-441d-badb-f71764f9cf50.png)\n\nWe can see that the first movie item has been correctly inserted into our `ul`/`li` HTML structure. What's really interesting about this code is the order in which things execute. Analyzing the log helps us to grasp the true power of asynchronism in Angular with RxJs. Here's what the console looks like after the execution of our code:\n\n```", "```ts\n\nAs you can see, `AngularObservableAppComponent` was notified that a movie matching the query was found before the `filter` function had analyzed all the items. As a reminder, the order to the operations inside the `fetchOneById` by `id` was: `get`, `flatMap`, `filter`, `map`, and we have logging statements in the `filter` and `map` methods. So, here, the filter operation analyzes the first item, which happens to be the one we are looking for `(movie_id===1)` and forwards it to the map operation that transforms it into a `Movie`. This `Movie` is sent right away to `AngularObservableAppComponent`. We clearly see that the received object in the `AngularObservableAppComponent` component is from type movie, as the console gives us our overriding of the `toString` method. Then, the `filter` operation continues with the rest of the items. None of them match; consequently, we do not have any more notifications.\n\nLet's test this further with a second method: `IMDBAPI.fetchByField`:\n\n```", "```ts\n\nFor the `fetchByField` method, we use the same mechanisms as `fetchById`. Unsurprisingly, the operations stay the same: `get`, `flatMap`, `filter`, and `map`. The only change is in the `filter` operation, where we now have to `filter` on a `field` received as parameter `return (movie[MovieFields[field]] === value)`.\n\nThis statement can be a bit overwhelming to the TypeScript or JavaScript newcomer. First, the `MovieFields[field]` part is explained by the fact that `enum` will be transpiled into the following JavaScript function:\n\n```", "```ts\n\nConsequently, the value of `MovieFields.release_year` is, in fact, `4` and `MovieFields` is a static array. So, `movie[MovieFields[field]]` is interpreted as a `movie[\"release_year is\"]` in our current example.\n\nThe next subtlety is that every object in JavaScript is represented as an associative array, where the variable name acts as a key. Therefore, `movie[\"release_year\"]` is equivalent to `movie.release_year`. This allows us to retrieve the value of any property only by knowing its name. Modify the constructor of `AngularObservableAppComponent` to look like the following:\n\n```", "```ts\n\nThis will have the impact shown in the following screenshot:\n\n![](img/295a388f-1911-4c40-9913-a485d0bf1989.png)\n\nNow we have five matches instead of one. On the analysis of the console, we can see that the notifications still come as soon as a suitable object is found, and not when they have all been filtered:\n\n```", "```ts\n\nNow, the other strength of this design pattern is the ability to unsubscribe yourself. To do so, you only have to acquire a reference to your subscription and call the `unsubscribe()` method, shown as follows:\n\n```", "```ts\n\nHere, we unsubscribe after the third notification. To add to all this, the `Observable` object will even detect that nobody's observing anymore and will stop whatever it was doing. Indeed, the previous code with `unsubscribe` produces:\n\n```", "```ts\n\nEverything stops after the third notification.\n\nThe code for this `Observer` implementation is at [http://bit.ly/mastering-angular2-chap7-part2](http://bit.ly/mastering-angular2-chap7-part2).\n\n# Promises\n\nPromises are another useful asynchronous concept available in Angular. Conceptually, promises implement a totally different pattern. A `Promise` is a value that will be resolved or rejected in the future. Like the `Observer` pattern, they can be used to manage async programming. So, why bother to have two concepts to do the same thing? Well, the verbosity of `Observer` allows one thing that `Promise` does not: unsubscribe. The main difference that may lead to a decision about which one to use is the ability of `Observable` to catch many subsequent asynchronous events, while `Promise` can manage a single asynchronous event. To emphasise the differences between `Observer` and `Promise`, we will take the same example as before, fetching movies from a JSON API.\n\nThe `AngularObservableAppComponent` component will make an asynchronous call to the `IMDBAPIService` and, upon the answer, will update the HTML view.\n\nHere's the `fetchOneById` method using `Promise` instead of `Observable`:\n\n```", "```ts\n\nAs shown by this code, we went from `flatMap`, `filter`, `map` to `flatMap`, `filter`, `toPromise`, and `then`. The new operations, `toPromise` and `then` create a `Promise` object that will contain the result of the `filter` operation and, on completion of the `filter` operation, the `then` operation will be executed. The `then` operation can be thought of as a map; it does the same thing. To use this code, we also have to change the way we call `IMDBAPIService` in `AngularObservableAppComponent`, to the following:\n\n```", "```ts\n\nOnce again, we can see a `then` operation that will be executed when the promise from `IMDBAPIService.FetchOneById` has completed. The `then` operation accepts two callbacks: `onCompletion` and `onError`. The second callback, `onError`, is optional.\n\nNow, `onCompletion` callback will only be executed once `Promise` has completed, as shown in the console:\n\n```", "```ts\n\nWhile the modification of `IMDBAPIService` was minimal for the `fetchOneById` method, we will have to change `fetchByField` more consequently. Indeed, `onComplete` callback will only be executed once, so we need to return an array of `Movie`, and not only one `Movie`. Here's the implementation of the `fetchByField` method:\n\n```", "```ts\n\nTo implement this, I trade `flatMap` for a classical map as the first operation. In the map, I acquire the reference to the JSON movie array directly and apply the `field` filter. The result is transformed into a promise and processed in the `then` operation. The `then` operation receives an array of JSON movies and transforms it into an array of `Movie`. This produces an array of `Movie` which is returned, as the promised result, to the caller. The call in `AngularObservableAppComponent` is also a bit different, as we now expect an array:\n\n```", "```ts\n\nAnother way to use `Promise` is through the `fork`/`join` paradigm. Indeed, it is possible to launch many processes (`fork`) and wait for all the promises to complete before sending the aggregated result to the caller (`join`). It is therefore relatively easy to supercharge the `fetchByField` method, as it can run in many fields with logic or.\n\nHere are the three very short methods we need to implement to the logic or:\n\n```", "```ts\n\nHere, I provide two convenient methods, `byfield` and/or that take a `MovieField` and a value as an argument and create a new `Promise`. They both return this for chaining. The `fetch` method joins all the `Promise` together and merges their respective results. In `AngularObservableAppComponent`, we can now have the following:\n\n```"]