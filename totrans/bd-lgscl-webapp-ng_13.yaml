- en: Continuous Integration and API Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start building more complicated features for our LOB app, LemonMart,
    we need to ensure that every code push we create has passing tests, adheres to
    the coding standards, and is an executable artifact that team members can run
    tests against, as we continue to further develop our application. Simultaneously,
    we need to start thinking about how our application will communicate with a backend
    server. Whether you, your team or another team will be creating the new APIs,
    it will be important that the API design accommodates the needs of both the frontend
    and backend architectures. To ensure a smooth development process, a robust mechanism
    is needed to create an accessible, living piece of documentation for the API.
    **Continuous Integration** (**CI**) can solve the first problem and Swagger is
    perfect to address API design, documentation, and testing needs.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration is critical to ensuring a quality deliverable by building
    and executing tests on every code push. Setting up a CI environment can be time
    consuming and requires specialized knowledge of the tool being used. CircleCI
    is an established, cloud-based CI service with a free tier and helpful articles
    to get you started with as little configuration as possible. We will go over a
    Docker-based approach that can be run on most CI services, keeping your specific
    configuration knowledge relevant and CI service knowledge down to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of full-stack development is that you will likely be developing
    the frontend and backend of your application around the same time. Whether you
    work by yourself, as a team, or with multiple teams, it is critical to establish
    a data contract to ensure that you won't run into eleventh-hour integration challenges.
    We will use Swagger to define a data contract for a REST API and then create a
    mock server that your Angular application can make HTTP calls to. For backend
    development, Swagger can act as a great starting point to generate boilerplate
    code and can go forward as living documentation and testing UI for your API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: CI with CircleCI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API design with Swagger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter requires the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A free CircleCI account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim of Continuous Integration is to enable a consistent and repeatable environment
    to build, test, and generate deployable artifacts of your application with every
    code push. Before a pushing code, a developer should have a reasonable expectation
    that their build will pass; therefore creating a reliable CI environment that
    automates commands that developers can also run in their local machines is paramount.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing build environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to ensure a consistent build environment across various OS platforms,
    developer machines, and Continuous Integration environments, you may containerize
    your build environment. Note that there are at least half-a-dozen common CI tools
    currently in use. Learning the ins and outs of each tool is almost an impossible
    task to achieve. Containerization of your build environment is an advanced concept
    that goes above and beyond of what is currently expected of CI tools. However,
    containerization is a great way to standardize over 90% of your build infrastructure,
    and can be executed in almost any CI environment. With this approach, the skills
    you learn and the build configuration you create becomes far more valuable, because
    both your knowledge and the tools you create become transferable and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: There are many strategies to containerize your build environment with different
    levels of granularity and performance expectations. For the purpose of this book,
    we will focus on reusability and ease of use. Instead of creating a complicated,
    interdependent set of Docker images that may allow for more efficient fail-first
    and recovery paths, we will focus on a single and straightforward workflow. Newer
    versions of Docker have a great feature called multi-stage builds, which allow
    you to define a multi image process in an easy-to-read manner and maintain a singular `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the process, you can extract an optimized container image as our
    deliverable artifact, shedding the complexity of images used previously in the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder your single `Dockerfile` would look like the sample below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Multi-stage works by using multiple `FROM` statements in a single `Dockerfile`,
    where each stage can perform a task and make any resources within its instance
    available to other stages. In a build environment, we can implement various build-related
    tasks as their own stages, and then copy the end result, such as the `dist` folder
    of an Angular build to the final image, which contains a web server. In this case,
    we will implement three stages of images:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Builder**: Used to build a production version of your Angular app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tester**: Used to run unit and e2e tests against a headless Chrome instances'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web Server**: The final result only containing the optimized production bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-stage builds require Docker version 17.05 or higher. To read more about
    multi-stage builds, read the documentation at [https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/).
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new file to implement the multi-stage configuration, named
    `Dockerfile.integration`, at the root of your project.
  prefs: []
  type: TYPE_NORMAL
- en: Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first stage is `builder`. We need a lightweight build environment that
    can ensure consistent builds across the board. For this purpose, I''ve created
    a sample Alpine-based Node build environment complete with npm, bash, and git
    tools. For more information on why we''re using Alpine and Node, refer to [Chapter
    10](4628e6f3-23d6-4aa7-a842-d1df666718de.xhtml),* Prepare Angular App for Production
    Release*, in the *Containerizing the App using Docker* section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement a new npm script to build your Angular app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Inherit from a Node.js based build environment like `node:10.1`  or `duluca/minimal-node-build-env:8.11.2`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement your environment specific build script, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that at the time of publishing a bug in low-level npm tooling is preventing `node` based
    images  from successfully installing Angular dependencies. This means that the
    sample `Dockerfile` below is based on an older version of Node and npm with `duluca/minimal-node-build-env:8.9.4`.
    In the future, when the bugs are sorted out an updated build environment will
    be able to leverage `npm ci` to install dependencies, which brings significant
    speed gains over the `npm install` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the source code is being pulled from GitHub by the
    container. I have chosen to do that for the sake of keeping the sample simple,
    because it works the same way in both local and remote continuous integration
    environments. However, your CI server will already have a copy of the source code,
    which you'll want to copy from your CI environment and then into the container.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the `RUN git clone $GIT_REPO .` command, you can copy source code
    with the `COPY $SRC_CODE_LOCATION .` command from your CI server or your local
    machine. If you do this, you will have to implement a `.dockerignore` file that
    somewhat resembles your `.gitignore` file to ensure that secrets aren't leaked,
    `node_modules` is not copied and the configuration is repeatable in other environments.
    In a CI environment, you will want to override the environment variable `$SRC_CODE_LOCATION` so
    that the source directory of the `COPY` command is correct. Feel free to create
    multiple versions of the `Dockerfile` that may fit your various needs.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, I have built a minimal Node build environment `duluca/minimal-node-build-env` based
    on `node-alpine`, which you can observe on Docker Hub at [https://hub.docker.com/r/duluca/minimal-node-build-env](https://hub.docker.com/r/duluca/minimal-node-build-env).
    This image is about ten times smaller than `node`. The size of Docker images have
    a real impact on build times, since the CI server or your team members will spend
    extra time pulling a larger image. Choose the environment that best fits your
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging build environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on your particular needs, your initial setup of the builder portion
    of the `Dockerfile` may be frustrating. To test out new commands or debug errors,
    you may need to directly interact with the build environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To interactively experiment and/or debug within the build environment, execute
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can test or debug commands within this temporary environment before baking
    them into your `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: Tester
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second stage is `tester`. By default, the Angular CLI generates a testing
    requirement that is geared toward a development environment. This will not work
    in a continuous integration environment; we must configure Angular to work against
    a headless browser that can execute without the assistance of a GPU and further,
    a containerized environment to execute the tests against.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a headless browser for Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The protractor testing tool officially supports running against Chrome in headless
    mode. In order to execute Angular tests in a continuous integration environment,
    you will need to configure your test runner, Karma, to run with a headless Chrome
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `karma.conf.js` to include a new headless browser option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `ChromiumNoSandbox` custom launcher encapsulates all the configuration elements
    needed for a good default setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `protractor` configuration to run in headless mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In order to test your application for responsive scenarios, you can use the
    `--window-size` option, as shown earlier, to change the browser settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `package.json` scripts to select the new browser option in production
    build scenarios:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that `test:prod` doesn't include `npm run e2e`. e2e tests are integration
    tests that take longer to execute, so  think twice about including them as part
    of your critical build pipeline. e2e tests will not run on the lightweight testing
    environment mentioned in the next section, so they will require more resources
    and time to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring testing environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a lightweight testing environment, we will be leveraging an Alpine-based
    installation of the Chromium browser:'
  prefs: []
  type: TYPE_NORMAL
- en: Inherit from `slapers/alpine-node-chromium`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Append the following configuration to `Docker.integration`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding script will copy the production build from the `builder` stage
    and execute your test scripts in a predictable manner.
  prefs: []
  type: TYPE_NORMAL
- en: Web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The third and final stage generates the container that will be your web server.
    Once this stage is complete, the prior stages will be discarded and the end result
    will be an optimized sub-10 MB container:'
  prefs: []
  type: TYPE_NORMAL
- en: Containerize your application with Docker
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append the `FROM` statement at the end of the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`COPY` the production ready code from `builder` as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and test your multi-stage `Dockerfile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you are pulling code from GitHub, ensure that your code is committed and
    pushed before building the container, since it will pull your source code directly
    from the repository. Use the `--no-cache` option to ensure that new source code
    is pulled. If you are copying code from your local or CI environment, then do
    *not* use `--no-cache` as you won't the speed gains from being able to reuse previously
    built container layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save your script as a new npm script named `build:ci` as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: CircleCI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CircleCI makes it easy to get started with a free tier and great documentation
    for beginners and pros alike. If you have unique enterprise needs, CircleCI can
    be brought on premise, behind corporate firewalls, or as a private deployment
    in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'CircleCI has pre-baked build environments for virtual configuration of free
    setups, but it can also run builds using Docker containers, making it a solution
    that scales to user skills and needs, as mentioned in the *Containerizing Build
    Environment* section:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a CircleCI account at [https://circleci.com/](https://circleci.com/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sign up with GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4f65be58-723e-4ff6-b5c4-78c8f84b8b55.png)'
  prefs: []
  type: TYPE_IMG
- en: CircleCI Sign up page
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a6a16149-7840-4de0-9131-712aeb53638b.png)'
  prefs: []
  type: TYPE_IMG
- en: CircleCI Projects Page
  prefs: []
  type: TYPE_NORMAL
- en: On the next screen, you have an option to select Linux or macOS build environments.
    The macOS build environments are very useful for building iOS or macOS apps. However,
    there is no free-tier for those environments; only Linux instances with 1x parallelism
    are free.
  prefs: []
  type: TYPE_NORMAL
- en: Search for lemon-mart and click on Setup project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Linux
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Platform 2.0
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Language as Other, since we'll use a custom containerized build environment
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your source code, create a folder named `.circleci` and add a file named `config.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding file, a `build` job is defined, which is based on CircleCI's
    pre-built `docker:17.12.0-ce-git` image, containing the Docker and git CLI tools
    within itself. We then define build `steps`, which checks out the source code
    from GitHub with `checkout`, informs CircleCI to set up a Docker-within-Docker
    environment with the `setup_remote_docker` command and then executes the `docker
    build -f Dockerfile.integration .` command to initiate our custom build process.
  prefs: []
  type: TYPE_NORMAL
- en: In order to optimize builds, you should experiment with layer caching and copying
    source code from the already checked out source code in CircleCI.
  prefs: []
  type: TYPE_NORMAL
- en: Sync your changes to Github
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On CircleCI, click to Create your project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If everything goes well, you will have passing, *green*, build. As shown in
    the following screenshot, build #4 was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dafc6e0c-df81-4ae3-abf7-edd373a0c589.png)'
  prefs: []
  type: TYPE_IMG
- en: Green build on CircleCI
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, the CI server is running, building the app in stage 1, then running
    the tests in stage 2, and then building the web server in stage 3\. Note that
    we are not doing anything with this web server container image, such as deploying
    it to a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to deploy your image, you will need to implement a deploy step. In
    this step, you can deploy to a multitude of targets such as Docker Hub, Zeit Now,
    Heroku, or AWS ECS. The integration to these targets will involve multiple steps.
    At a highlevel, these steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Install target-specific CLI tool with a separate run step
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure Docker with login credentials specific to the target environment,
    storing said credentials as CircleCI environment variables
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `docker push` to submit the resulting web server image to the target's Docker
    registry
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute a platform-specific `deploy` command to instruct the target to run the
    Docker image that was just pushed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An example of how to configure such a deployment on AWS ECS from your local
    development environment is covered in [Chapter 16](7ccc1261-21e7-44b9-aaf8-0079360288e7.xhtml),
    *Highly-Available Cloud Infrastructure on AWS*.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage report
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A good way to understand the amount and the trends of unit tests coverage for
    your Angular project is through a code coverage report. In order to generate the
    report for your app, execute the following command from your project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting report will be created as HTML under a folder name coverage;
    execute the following command to view it in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the folder-level sample coverage report generated by `istanbul.js` for
    LemonMart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f1960d4-072a-4579-ac6b-1e6254264a97.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Istanbul code coverage report for LemonMart
  prefs: []
  type: TYPE_NORMAL
- en: 'You can drill down on a particular folder, like `src/app/auth`, and get a file-level
    report, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c13d8f4f-f833-4c65-b82f-287045b70272.png)'
  prefs: []
  type: TYPE_IMG
- en: Istanbul code coverage report for src/app/auth
  prefs: []
  type: TYPE_NORMAL
- en: 'You can further drill down to get line-level coverage for a given file, like
    `cache.service.ts`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc3e1e82-8e8b-4ced-9009-ed54ba11e845.png)'
  prefs: []
  type: TYPE_IMG
- en: Istanbul Code Coverage Report for cache.service.ts
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding image you can see that lines 5, 12, 17-18 and 21-22 are not
    covered by any test. The Iicon denotes that the if path was not taken. We can
    increase our code coverage by implementing unit tests that exercise the functions
    that are contained within `CacheService`. As an exercise, the reader should attempt
    to atleast cover one of these functions with a new unit test and observe the code
    coverage report change.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, your CI server configuration should generate and host the code coverage
    report with every test run in a readily accessible manner. Implement these commands
    as script in `package.json` and execute them in your CI pipeline. This configuration
    is left as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Install `http-server` as a development dependency to your project.
  prefs: []
  type: TYPE_NORMAL
- en: API design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In full-stack development, nailing down the API design early on is important.
    The API design itself is closely correlated with how your data contract will look.
    You may create RESTful endpoints or use the next-gen GraphQL technology. In designing
    your API, frontend and backend developers should closely collaborate to achieve
    shared design goals. Some high-level goals are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimize data transmitted between client and server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stick to well-established design patterns (that is, pagination)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design to reduce business logic present in the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flatten data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not expose database keys or relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version endpoints from the get go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design around major data components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important not to reinvent the wheel and take a disciplined, if not strict,
    approach to designing your API. The downstream effect of missteps in API design
    can be profound and impossible to correct once your application goes live.
  prefs: []
  type: TYPE_NORMAL
- en: I will go into details of designing around major data components and implement
    a sample Swagger endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Designing around major data components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It helps to organize your APIs around major data components. This will roughly
    match how you consume data in various components in your Angular application.
    We will start off by defining our major data components by creating a rough data
    entity diagram and then implementing a sample API for the user data entity with
    swagger.
  prefs: []
  type: TYPE_NORMAL
- en: Defining entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by taking a stab at what kind of entities you would like to store
    and how these entities might relate to one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a sample design for LemonMart, created using [draw.io](http://draw.io):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/132edb42-b0ab-435e-9d27-8c61b2fae794.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data entity diagram for LemonMart
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, whether your entities are stored in a SQL or NoSQL database
    is inconsequential. My suggestion is to stick to what you know, but if you're
    starting from scratch, a NoSQL database like MongoDB will offer the most amount
    of flexibility as your implementation and requirements evolve.
  prefs: []
  type: TYPE_NORMAL
- en: Roughly speaking, you will need CRUD APIs for each entity. You can use Swagger
    to design your APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swagger will allow you to design your web API. For teams, it can act as an interface
    between frontend and backend teams. Additionally, with API mocking, you can develop
    and complete API features before the implementation of the APIs even begins.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement a sample Users API as we move on, to demonstrate how Swagger
    works.
  prefs: []
  type: TYPE_NORMAL
- en: The sample project comes with recommended extensions for VS Code. Swagger Viewer
    allows us to preview the YAML file without running any additional tools.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Swagger YAML file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most widely used and supported version of the Swagger spec is `swagger:
    ''2.0''`. The following example is given using the newer, standards-based, `openapi:
    3.0.0`. The sample code repository contains both examples. However, at the time
    of publishing, most tooling in the Swagger ecosystem relies on version 2.0.'
  prefs: []
  type: TYPE_NORMAL
- en: The sample code repository can be found at [github.com/duluca/lemon-mart-swagger-server](http://github.com/duluca/lemon-mart-swagger-server).
  prefs: []
  type: TYPE_NORMAL
- en: For your mock API server, you should create a separate git repository, so that
    this contract between your frontend and backend can be maintained separately.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new GitHub repository, called `lemon-mart-swagger-server`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start defining a YAML file with general information and target servers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Under `components`, define shared data `schemas`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Under `components`, add shared `parameters`, making it easy to reuse common
    patterns like paginated endpoints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Under `paths`, define a `get` endpoint for the `/users` path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Under `paths`, add `get` user by ID and `update` user by ID endpoints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To validate your Swagger file, you can use the online editor at [editor.swagger.io](https://editor.swagger.io).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the use of `style: form` and `explode: false`, which are the simplest
    way to configure an endpoint that expects basic form data. For more parameter
    serialization options or to simulate authentication endpoints and a slew of other
    possible configurations, refer to the documentation at [swagger.io/docs/specification/](https://swagger.io/docs/specification/).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Swagger server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using your YAML file, you can generate a mock Node.js server using the Swagger
    Code Gen tool.
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI 3.0 with unofficial tooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the earlier section, this section will use version 2 of the
    YAML file, which can generate a server using the official tooling. There are,
    however, other tools out there that can generate some code, but not complete enough
    to be easy to use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If using OpenAPI 3.0 on the project folder, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Under a new folder, called `server`, you should now have a Node Express server
    generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install dependencies for the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You must then manually implement the missing stubs to complete the implementation
    of the server.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger 2.0 with official tooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using official tooling and version 2.0, you can automate API creation and response
    generation. Once official tooling fully supports them, OpenAPI 3.0, the same instructions
    should apply:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Publish your YAML file on a URI that will be accessible by your machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In your project folder, execute the following command, replacing `<uri>` with
    the one pointing at your YAML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the preceding section, this will create a Node Express server under
    the server directory. In order to execute this server, carry on with the following
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Install the server's dependencies with `npm install`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm start`. Your mock server should now be up and running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `http://localhost:3000/docs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try out the API for `get /users`; you''ll note that the items property is empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5232c3e1-da5f-4aef-b66a-e15a886d30bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Swagger UI - Users endpoint
  prefs: []
  type: TYPE_NORMAL
- en: However, you should be receiving dummy data. We will correct this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out `get /user/{id}`; you''ll see that you''re receiving some dummy data
    back:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6e2ad6a5-bff4-42cd-b195-0e0d03d31ae4.png)'
  prefs: []
  type: TYPE_IMG
- en: Swagger UI - User by ID endpoint
  prefs: []
  type: TYPE_NORMAL
- en: The difference in behavior is because, by default, the Node Express server uses
    controllers generated under `server/controllers/Default.js` to read random data
    generated during server creation from `server/service/DefaultService.js`. However,
    you can disable the default controllers and force Swagger into a better default
    stubbing mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `index.js` to force the use of stubs and comment out controllers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Try out the `/users` endpoint again
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see here, the response is higher quality by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f75896ae-de7d-4ffc-8e71-1938fdc51bc7.png)'
  prefs: []
  type: TYPE_IMG
- en: Swagger UI - Users endpoint with dummy data
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding, `total` is a whole number, `role` is defined correctly, and
    `items` is a valid array structure.
  prefs: []
  type: TYPE_NORMAL
- en: To enable better and more customized data mocking, you can edit `DefaultService.js`.
    In this case, you would want to update the `usersGET` function to return an array
    of customized users.
  prefs: []
  type: TYPE_NORMAL
- en: Enable Cross-Origin Resource Sharing (CORS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you''re able to use your server from your application, you will need
    to configure it to allow for **Cross-Origin Resource Sharing** (**CORS**) so that
    your Angular application hosted on `http://localhost:5000` can communicate with
    your mock server hosted on `http://localhost:3000`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `cors` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `index.js` to use `cors`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that `app.use(cors())` is called right before `initializeMiddleware`;
    otherwise, other Express middleware may interfere with the functionality of `cors()`.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying and publishing Swagger server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can verify your Swagger server setup through the SwaggerUI, which will be
    located at `http://localhost:3000/docs`, or you can achieve a more integrated
    environment with the Preview Swagger extension in VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will demonstrate how you can use this extension to test your API from within
    VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the YAML file in Explorer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Shift* + *Alt* + *P *and execute the Preview Swagger command
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see an interactive window to test your configuration, as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0ed1b78b-5dfb-45ec-8e63-5c8d276900d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Preview Swagger Extension in Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Get button for /users
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Try it out to see the results
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In OpenAPI 3.0.0, instead of schemes, you will see a list of servers, including
    local and remote resources. This is a very convenient tool to explore various
    data sources as you code your frontend application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have verified your Swagger server, you can publish your server
    to make it accessible to team members or **Automated Acceptance Test** (**AAT**)
    environments that require a predictable dataset to execute successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Perform the following steps*:*
  prefs: []
  type: TYPE_NORMAL
- en: Add npm Scripts for Docker to the root level `package.json` file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `Dockerfile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Once you build the container, you are ready to deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: I have published a sample server on Docker Hub at [https://hub.docker.com/r/duluca/lemon-mart-swagger-server](https://hub.docker.com/r/duluca/lemon-mart-swagger-server).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create a container-based Continuous Integration
    environment. We leveraged CircleCI as a cloud-based CI service and highlighted
    the fact that you can deploy the outcome of your builds to all major cloud hosting
    providers. If you enable such automated deployment, you will achieve **Continuous Deployment**
    (**CD**). With a CI/CD pipeline, you can share every iteration of your app with
    clients and team members and quickly deliver bug fixes or new features to your
    end users.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the importance of good API design and established Swagger
    as a tool that is beneficial to frontend and backend developers alike to define
    and develop against a live data-contract. If you create a Swagger mock server,
    you can enable team members to pull the mock server image and use it to develop
    their frontend applications before backend implementation is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Both CircleCI and Swagger are highly sophisticated tools in their own ways.
    The techniques mentioned in this chapter are straightforward on purpose, but they
    are meant to enable sophisticated workflows, giving you a taste of the true power
    of such tools. You can improve upon the efficiency and the capability of this
    technique vastly, but the techniques will depend on your specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with CI and mocked APIs that we can send real HTTP requests to, we are
    ready to iterate rapidly while ensuring a high-quality deliverable. In the next
    chapter, we will dive deep into designing an authorization and authentication
    experience for your line-of-business app using token-based authentication and
    conditional navigation techniques to enable a smooth user experience, continuing
    the Router-first approach.
  prefs: []
  type: TYPE_NORMAL
