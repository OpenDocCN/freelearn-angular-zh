- en: Angular App Design and Recipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will complete the implementation of LemonMart. As part of
    the router-first approach, I will demonstrate the creation of reusable routable components
    that also support data binding - the ability to lay out components using auxiliary
    routes of the router, using resolve guards to reduce boilerplate code and leveraging
    class, interfaces, enums, validators, and pipes to maximize code reuse. In addition,
    we will create multi-step forms and implement data tables with pagination, and
    explore responsive design. Along the way, in this book, we will have touched upon
    most of the major functionality that Angular and Angular Material has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the training wheels are off. I will provide general guidance
    to get you started on an implementation; however, it will be up to you to try
    and complete the implementation on your own. If you need assistance, you may refer
    to the complete source code that is provided with the book or refer to up-to-date
    sample on GitHub at [Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented class design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routable reusable components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching service responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP POST requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-step responsive forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve guards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Master/detail views using auxiliary routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data tables with pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User class and object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have only worked with interfaces to represent data, and we still
    want to continue using interfaces when passing data around various components
    and services. However, there's a need to create a default object to initialize
    a `BehaviorSubject`. In **Object-oriented Programming** (**OOP**), it makes a
    lot of sense for the `User` object to own this functionality instead of a service.
    So, let's implement a `User` class to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `user/user` folder, define an `IUser` interface and a `User` class
    provided in `UserModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that by defining all properties with default values in the constructors
    as `public` properties, we hit two birds with one stone; otherwise, we will need
    to define properties and initialize them separately. This way, we achieve a concise
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also implement calculated properties for use in templates, such as
    being able to conveniently display the `fullName` of a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using a `static BuildUser` function, you can quickly hydrate the object with
    data received from the server. You can also implement the `toJSON()` function
    to customize the serialization behavior of your object before sending the data
    up to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a component that can display a given user''s information. A natural
    place for this information to be presented is when the user navigates to `/user/profile`.
    You can see the mock-up `User` profile file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eac254e3-0556-42ff-8841-6b44a5020fff.png)'
  prefs: []
  type: TYPE_IMG
- en: User profile mock-up
  prefs: []
  type: TYPE_NORMAL
- en: 'User information is also displayed mocked up elsewhere in the app, at `/manager/users`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9b855d5-243b-4cc0-b625-511856a1f3b8.png)'
  prefs: []
  type: TYPE_IMG
- en: Manager user management mock-up
  prefs: []
  type: TYPE_NORMAL
- en: To maximize code reuse, we need to ensure that you design a `User` component
    that can be used in both contexts.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's complete the implementation of two user profile-related
    screens.
  prefs: []
  type: TYPE_NORMAL
- en: User profile with multi-step auth-enabled responsive forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's implement a multi-step input form to capture user profile information.
    We will also make this multi-step form responsive for mobile devices using media
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with adding some helper data that will help us display an input
    form with options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Install a helper library to programmatically access TypeScript enum values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Add new validation rules to `common/validations.ts`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now implement `profile.component.ts` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Upon load, we request the current user from `userService`, but this will take
    a while, so we must first build an empty form with `this.buildUserForm()`. On
    this function, you can also implement a resolve guard, as discussed in a later
    section, to load a user based on their `userId` provided on a route, and pass
    that data into `buildUserForm(routeUser)` and skip loading `currentUser` to increase
    reusability of this component.
  prefs: []
  type: TYPE_NORMAL
- en: Form groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our form has many input fields, so we will use a `FormGroup`, created by `this.formBuilder.group`
    to house our various `FormControl` objects. Additionally, children `FormGroup`
    objects will allow us to maintain the correct shape of the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start building the `buildUserForm` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`buildUserForm` optionally accepts an `IUser` to prefill the form, otherwise
    all fields are set to their default values. The `userForm` itself is the top-level
    `FormGroup`. Various `FormControls` are added to it, such as `email`, with validators
    attached to them as needed. Note how `name` and `address` are their own `FormGroup`
    objects. This parent-child relationship ensures proper structure of the form data,
    when serialized to JSON, which fits the structure of `IUser`, in a manner that
    the rest of our application and server-side code can utilize.'
  prefs: []
  type: TYPE_NORMAL
- en: You will completing the implementation of the `userForm` independently following
    the sample code provided for the chapter and I will be going over sections of
    the code piece by piece over the next few sections to explain certain key capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Stepper and responsive layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular Material Stepper ships with the MatStepperModule. The stepper allows
    for form inputs to be broken up into multiple steps so that the user is not overwhelmed
    with processing dozens of input fields all at once. The user can still track their
    place in the process and as a side effect, as the developer we breakup our `<form>`
    implementation and enforce validation rules on a step-by-step basis or create
    optional workflows where certain steps can be skipped or required. As with all
    Material user controls, the stepper has been designed with a responsive UX in
    mind. In the next few sections, we will implement three steps covering different
    form-input techniques in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: Account Information
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input validation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Responsive layout with media queries
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculated properties
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: DatePicker
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Contact Information
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type ahead support
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic form arrays
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read-only views
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and clearing data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s prep the User module for some new Material modules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `user-material.module` containing the following Material modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure `user.module` correctly imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new `user-material.module`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The baseline  `app-material.module`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Required  `FormsModule`, `ReactiveFormsModule` and `FlexLayoutModule`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: As we start adding sub material modules, it makes sense to rename our root `material.module.ts`
    file to `app-material.modules.ts` inline with how `app-routing.module.ts` is named.
    Going forward, I will be using the latter convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, start implementing the first row of the Account Information step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Take care to understand how the stepper and the form configuration works so
    far, you should be seeing the first row render, pulling mock data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/32843e4b-d12a-4a66-9b97-6c034e13732b.png)'
  prefs: []
  type: TYPE_IMG
- en: Multi-step form - Step 1
  prefs: []
  type: TYPE_NORMAL
- en: In order to complete the implementation of the form please refer to the sample
    code provided for this chapter or the reference implementation on [GitHub.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During your implementation, you will notice that the Review step uses a directive
    named `<app-view-user>`. A minimal version of this component is implemented in
    the ViewUser component section below. However, feel free to implement the capability
    inline for now and refactor your code during the Reusable component with binding
    and route data section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see what a completed implementation of
    the multi-step form looks like on a desktop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9a485ac-1bb5-4881-9c2f-bffcee671f75.png)'
  prefs: []
  type: TYPE_IMG
- en: Multi-step form on desktop
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that adding `fxLayout.lt-sm="column"` on a row with `fxLayout="row"` enables
    a responsive layout of the form, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8d82436-fc54-4675-8091-cf033e2123d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Multi-step form on mobile
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how the Date of Birth field works in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Calculated properties and DatePicker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you like to display calculated properties based on user input, you can follow
    the pattern shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage of calculated properties in the template looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here it is in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8aff43df-f604-43cf-9eed-4fb412b9163d.png)'
  prefs: []
  type: TYPE_IMG
- en: Selecting date with DatePicker
  prefs: []
  type: TYPE_NORMAL
- en: 'After the date is selected, the calculated age is displayed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65a05b6a-4266-4a78-816f-1749e2a0bab1.png)'
  prefs: []
  type: TYPE_IMG
- en: Calculated age property
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next step, Contact Information and see how we can
    enable a convenient way to display and input the state portion of the address
    field.
  prefs: []
  type: TYPE_NORMAL
- en: Type ahead support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `buildUserForm`, we set a listener on `address.state` to support a type
    ahead filtering drop-down experience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'On the template, implement `mat-autocomplete` bound to the filtered states
    array with an `async` pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how it looks when a user enters the `V` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efe44748-d14c-4d5e-b990-004fd345bd1f.png)'
  prefs: []
  type: TYPE_IMG
- en: Dropdown with Typeahead Support
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let's enable the input of multiple phone numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic form arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note that `phones` is an array, potentially allowing for many inputs. We can
    implement this by building a `FormArray` with `this.formBuilder.array` and with
    several helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`BuildPhoneArray` supports initializing a form with a single phone input or
    filling it with the existing data, working in tandem with `BuildPhoneFormControl`.
    The latter function comes in handy when a user clicks on an Add button to create
    a new row for entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `phonesArray` property getter is a common pattern to make it easier to
    access certain form properties. However, in this case, it is also necessary, because
    `get(''phones'')` must be typecast to `FormArray` so that we can access the `length`
    property on it on the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `remove` function is implemented inline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how it should be working:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fb49d34-6c03-4edb-86a6-43d3183d8068.png)'
  prefs: []
  type: TYPE_IMG
- en: Multiple inputs using FormArray
  prefs: []
  type: TYPE_NORMAL
- en: Now that we're done with inputing data, we can move on to the last step of the
    stepper, Review. However, as it was mentioned earlier, the Review step uses the `app-view-user`
    directive to display its data. Let's build that view first.
  prefs: []
  type: TYPE_NORMAL
- en: ViewUser component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's a minimal implementation of the `<app-view-user>` directive that is a
    prerequisite for the Review step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `viewUser` component under `user` as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The component above uses input binding with `@Input` to get user data, compliant
    with the `IUser` interface, from an outside component. We implement the `ngOnChanges`
    event, which fires whenever the bound data changes. In this event, we hydrate
    the simple JSON object stored in `this.user` as an instance of the class `User`
    with  `User.BuildUser` and assign it to `this.currentUser`. The template uses
    this variable, because calculated properties like `currentUser.fullName` will
    only work if the data resides in an instance of the class `User`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to complete the multi-step form.
  prefs: []
  type: TYPE_NORMAL
- en: Review component and Save form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the last step of the multistep form, users should be able to review and
    then save the form data. As a good practice, a successful `POST` request will
    return the data that was saved back to the browser. We can then reload the form
    with the information received back from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are errors, they''ll be set to `userError` to be displayed. Before
    saving, we will present the data in a compact form in a reusable component that
    we can bind the form data to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the final product should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f8afd93-786d-4ae7-b43b-d665971ae9a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Review step
  prefs: []
  type: TYPE_NORMAL
- en: Note the option to reset the form. Adding an alert dialog to confirm resetting
    of user input data would be good UX.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the user profile input is done, we are about midway into our eventual
    goal of creating a master/detail view where a Manager can click on a user and
    view their profile details. We still have a lot more code to add, and along the
    way, we have fallen into a pattern of adding lots of boilerplate code to load
    the requisite data for a component. In the next section, we will learn about resolve
    guards so that we can simplify our code and reduce boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: Resolve guard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A resolve guard is a type of a router guard, as mentioned in [Chapter 14](c1386d03-1f04-49e0-a623-bc5c64be089c.xhtml),* Design
    Authentication and Authorization.* A resolve guard can load necessary data for
    a component by reading record IDs from route parameters, asynchronously load the
    data and have it ready by the time the component activates and initializes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The major advantages for a resolve guard includes reusability of loading logic,
    reduction of boilerplate code, and also shedding dependencies, because the component
    can receive the data it needs without having to import any service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `user.resolve.ts` class under `user/user`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use a resolve guard as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `routerLink` will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'On the ` ngOnInit` hook of the target component, you can read the resolved
    user like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can observe this behavior in action in the next two sections, after we update `ViewUserComponent` and
    the router to leverage the resolve guard.
  prefs: []
  type: TYPE_NORMAL
- en: Reusable component with binding and route data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s refactor the `viewUser` component, so that we can reuse it in multiple
    contexts. One where it can load its own data using a resolve guard, suitable for
    a master/detail view and another, where we can bind the current user to it, as
    we have done in the Review step of the multi-step input form we built in the prior
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `viewUser` component with the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We now have two independent events. One for `ngOnChanges`, which handles what
    value gets assigned to `this.currentUser`, if `this.user` has been bound to. `ngOnInit`
    will only fire once, when the component is first initialized or has been routed
    to. In this case, if any data for the route has been resolved then it'll be assigned
    to `this.currentUser`.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to use this component across multiple lazy loaded modules, we must
    wrap it in its own module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `shared-components.module.ts` under `app`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that you import `SharedComponentsModule` module into each feature module
    you intended to use `ViewUserComponent` in. In our case, these will be `User`
    and `Manager` modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove `ViewUserComponent` from the `User` module declarations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have the key pieces in place to begin the implementation of master/detail
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Master/detail view auxiliary routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The true power of router-first architecture comes to fruition with the use of
    auxiliary routes, where we can influence the layout of components solely through
    router configuration, allowing for rich scenarios where we can remix the existing
    components into different layouts. Auxiliary routes are routes that are independent
    of each other where they can render content in named outlets that have been defined
    in the markup, such as `<router-outlet name="master">` or `<router-outlet name="detail">`.
    Furthermore, auxiliary routes can have their own parameters, browser history,
    children, and nested auxiliaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will implement a basic master/detail view using
    auxiliary routes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement a simple component with two named outlets defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Create a `userTable` component under `manager`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update `manager-routing.module` to define the auxiliary routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This means that when a user navigates to `/manager/users`, they'll see the `UserTableComponent`,
    because it is implemented with the `default` path.
  prefs: []
  type: TYPE_NORMAL
- en: Provide `UserResolve` in `manager.module` since `viewUser` depends on it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a temporary button in `userTable`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider that a user clicks on a View detail button like the one defined above,
    then `ViewUserComponent` will be rendered for the user with the given `userId`.
    In the next screenshot, you can see what the View Details button will look like
    after we implement the data table in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27e24385-6a13-4375-8905-4e0a4da346c9.png)'
  prefs: []
  type: TYPE_IMG
- en: View Details button
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have as many combinations and alternative components defined for master
    and detail, allowing for an infinite possibilities of dynamic layouts. However,
    setting up the `routerLink` can be a frustrating experience. Depending on the
    exact condition, you have to either supply or not supply all or some outlets in
    the link. For example, for the preceding scenario, if the link was `[''/manager/users'',
    { outlets: { master: [''''], detail: [''user'', {userId: row.id}] } }]`, the route
    will silently fail to load. Expect these quirks to be ironed out in future Angular
    releases.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that, we've completed the implementation of the resolve guard for `ViewUserComponent`,
    you can use Chrome Dev Tools to see the data being loaded correctly. Before debugging,
    ensure that the mock server we created in [Chapter 13,](215237a5-318b-4de2-82a8-4e40e438b228.xhtml)
    *Continuous Integration and API Design*, is running.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that mock server is running by executing either `docker run -p 3000:3000
    -t duluca/lemon-mart-swagger-server` or `npm run mock:standalone`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Chrome Dev Tools, set a break point right after `this.currentUser` is assigned
    to, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6af6ebd9-acd6-4797-acf2-f02135a7c6a9.png)'
  prefs: []
  type: TYPE_IMG
- en: Dev Tools Debugging ViewUserComponent
  prefs: []
  type: TYPE_NORMAL
- en: You will observe that `this.currentUser` is correctly set without any boilerplate
    code for loading data inside the `ngOnInit` function, showing the true benefit
    of a resolve guard. `ViewUserComponent` is the detail view; now let's implement
    the master view as a data table with pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Data table with pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created the scaffolding to lay out our master/detail view. In the master
    outlet, we will have a paginated data table of users, so let's implement `UserTableComponent`,
    which will contain a `MatTableDataSource` property named `dataSource`. We will
    need to be able to fetch user data in bulk using standard pagination controls
    like `pageSize` and `pagesToSkip` and be able to further narrow down the selection
    with user provided `searchText`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by adding the necessary functionality to the `UserService`.
  prefs: []
  type: TYPE_NORMAL
- en: Implement a new interface `IUsers` to describe the data structure of paginated
    data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Add `getUsers` to `UserService`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up `UserTable` with pagination, sorting, and filtering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After initializing the pagination, sorting, and the filter properties, we use
    the `merge` method to listen for changes in all three data streams. If one changes,
    the whole `pipe` is triggered, which contains a call to `this.userService.getUsers`.
    Results are then mapped to the table's `datasource` property, otherwise errors
    are caught and handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `manager-material.module` containing the following Material modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure `manager.module` correctly imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new `manager-material.module`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The baseline  `app-material.module`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Required  `FormsModule`, `ReactiveFormsModule` and `FlexLayoutModule`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, implement the `userTable` template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With just the master view, the table looks like this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9bdc8f6-da44-4279-bf37-70dcff4e8794.png)'
  prefs: []
  type: TYPE_IMG
- en: UserTable
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the View icon, `ViewUserComponent` will get rendered in the
    detail outlet, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b31311fa-24cf-44b1-884b-14d612c84a12.png)'
  prefs: []
  type: TYPE_IMG
- en: Master/Detail view
  prefs: []
  type: TYPE_NORMAL
- en: You can then wire up the Edit button and pass the `userId` to the `UserProfile` so
    that the data can be edited and updated. Alternatively, you can render the `UserProfile`
    in place in the detail outlet.
  prefs: []
  type: TYPE_NORMAL
- en: Data table with pagination completes the implementation of LemonMart for the
    purpose of this book. Now let's make sure all our tests our passing, before we
    move on.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Unit Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we introduced a new `userService`, create a fake implementation for it,
    using the same pattern from `authService` and `commonTestingProviders` with it.
  prefs: []
  type: TYPE_NORMAL
- en: Implement `IUserService` interface for `UserService`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Implement the fake user service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Add the user service fake to `commonTestingProviders`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Add `SharedComponentsModule` to `commonTestingModules`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Instantiate default data for `UserTableComponent`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After fixing up its providers and imports, you will notice `UserTableComponent`
    is still failing to create. This is because, the component initialization logic
    requires `dataSource` to be defined. If undefined, the component can''t be created.
    However, we can easily modify component properties in the second `beforeEach`
    method, which executes after the `TestBed` has injected real, mocked or fake dependencies
    to the component class. See the changes bolded below for test data setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'By now, you may have noticed that just by updating some of our central configuration
    some tests are passing and the rest of tests can be resolved by applying the various
    patterns we have been using throughout the book. For example `user-management.component.spec.ts`
    uses the common testing modules and providers we have created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When you are working with providers and fakes, keep in mind what module, component,
    service or class is under test and take care to only provide fakes of dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewUserComponent` is a special case, where we can''t use our common testing
    modules and providers, otherwise we would end up creating a circular dependency.
    In this case, manually specify the modules that need to be imported.'
  prefs: []
  type: TYPE_NORMAL
- en: Continue fixing unit test configurations until all of them are passing!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this book, we didn't cover any functional unit testing, where we would test
    some business logic to test its correctness. Instead, we focused on keeping the
    auto-generated tests in working order. I highly recommend implementing unit tests
    to cover key business logic using the excellent framework provided by Angular
    out-of-the-box.
  prefs: []
  type: TYPE_NORMAL
- en: You always have the option to write even further elemental unit tests, testing
    classes and functions in isolation using Jasmine. Jasmine has rich test double
    functionality, able to mock and spy on dependencies. It is easier and cheaper
    to write and maintain these kinds of elemental unit tests. However, this topic
    is a deep one in its own right and is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we completed going over all major Angular app design considerations,
    along with recipes, to be able to implement a line-of-business app with ease.
    We talked about applying object-oriented class design to make hydrating or serializing
    data easier. We created reusable components that can be activated by the router
    or embedded within another component with data binding. We showed that you can
    `POST` data to the server and cache responses. We also created a rich multistep
    input forms that is responsive to changing screen sizes. We removed boilerplate
    code from components by leveraging a resolve guard to load user data. We then
    implemented a master/detail view using auxiliary routes and demonstrated how to
    build data tables with pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, by using the router-first design, architecture, and implementation
    approach, we approached our application's design with a good high-level understanding
    of what we wanted to achieve. Also, by identifying reuse opportunities early on,
    we were able to optimize our implementation strategy to implement reusable components
    ahead of time without running the risk of grossly over-engineering our solution.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will set up a highly-available infrastructure on AWS
    to host LemonMart. We will update the project with new scripts to enable no-downtime
    Blue-Green deployments.
  prefs: []
  type: TYPE_NORMAL
